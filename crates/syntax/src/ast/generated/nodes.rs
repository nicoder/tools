//! Generated by `syntax_codegen`, do not edit by hand.

#![allow(clippy::all)]
use crate::{
	ast::{support, AstChildren, AstNode},
	SyntaxKind::{self, *},
	SyntaxNode, SyntaxToken,
};
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AbstractClassDeclaration {
	pub(crate) syntax: SyntaxNode,
}
impl AbstractClassDeclaration {
	pub fn body(&self) -> Option<ClassBody> {
		support::child(&self.syntax)
	}
	pub fn decorator(&self) -> AstChildren<Decorator> {
		support::children(&self.syntax)
	}
	pub fn inner_children(&self) -> Option<ClassHeritage> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::TYPE_IDENTIFIER)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AbstractMethodSignature {
	pub(crate) syntax: SyntaxNode,
}
impl AbstractMethodSignature {
	pub fn inner_children(&self) -> Option<AccessibilityModifier> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<AbstractMethodSignatureName> {
		support::child(&self.syntax)
	}
	pub fn parameters(&self) -> Option<FormalParameters> {
		support::child(&self.syntax)
	}
	pub fn return_type(&self) -> Option<AbstractMethodSignatureReturnType> {
		support::child(&self.syntax)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AbstractToken {
	pub(crate) syntax: SyntaxNode,
}
impl AbstractToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AccessibilityModifier {
	pub(crate) syntax: SyntaxNode,
}
impl AccessibilityModifier {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AmbientDeclaration {
	pub(crate) syntax: SyntaxNode,
}
impl AmbientDeclaration {
	pub fn inner_children(&self) -> AstChildren<AmbientDeclarationInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AmpAmpEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl AmpAmpEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AmpAmpToken {
	pub(crate) syntax: SyntaxNode,
}
impl AmpAmpToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AmpEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl AmpEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AmpToken {
	pub(crate) syntax: SyntaxNode,
}
impl AmpToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AnyToken {
	pub(crate) syntax: SyntaxNode,
}
impl AnyToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Arguments {
	pub(crate) syntax: SyntaxNode,
}
impl Arguments {
	pub fn inner_children(&self) -> AstChildren<ArgumentsInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Array {
	pub(crate) syntax: SyntaxNode,
}
impl Array {
	pub fn inner_children(&self) -> AstChildren<ArrayInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayPattern {
	pub(crate) syntax: SyntaxNode,
}
impl ArrayPattern {
	pub fn inner_children(&self) -> AstChildren<ArrayPatternInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrayType {
	pub(crate) syntax: SyntaxNode,
}
impl ArrayType {
	pub fn inner_children(&self) -> Option<PrimaryType> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ArrowFunction {
	pub(crate) syntax: SyntaxNode,
}
impl ArrowFunction {
	pub fn body(&self) -> Option<ArrowFunctionBody> {
		support::child(&self.syntax)
	}
	pub fn parameter(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::IDENTIFIER)
	}
	pub fn parameters(&self) -> Option<FormalParameters> {
		support::child(&self.syntax)
	}
	pub fn return_type(&self) -> Option<ArrowFunctionReturnType> {
		support::child(&self.syntax)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AsExpression {
	pub(crate) syntax: SyntaxNode,
}
impl AsExpression {
	pub fn inner_children(&self) -> AstChildren<AsExpressionInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AsToken {
	pub(crate) syntax: SyntaxNode,
}
impl AsToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Asserts {
	pub(crate) syntax: SyntaxNode,
}
impl Asserts {
	pub fn inner_children(&self) -> Option<AssertsInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssertsToken {
	pub(crate) syntax: SyntaxNode,
}
impl AssertsToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignmentExpression {
	pub(crate) syntax: SyntaxNode,
}
impl AssignmentExpression {
	pub fn left(&self) -> Option<AssignmentExpressionLeft> {
		support::child(&self.syntax)
	}
	pub fn right(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AssignmentPattern {
	pub(crate) syntax: SyntaxNode,
}
impl AssignmentPattern {
	pub fn left(&self) -> Option<Pattern> {
		support::child(&self.syntax)
	}
	pub fn right(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AsyncToken {
	pub(crate) syntax: SyntaxNode,
}
impl AsyncToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AtToken {
	pub(crate) syntax: SyntaxNode,
}
impl AtToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AugmentedAssignmentExpression {
	pub(crate) syntax: SyntaxNode,
}
impl AugmentedAssignmentExpression {
	pub fn left(&self) -> Option<AugmentedAssignmentExpressionLeft> {
		support::child(&self.syntax)
	}
	pub fn right(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AwaitExpression {
	pub(crate) syntax: SyntaxNode,
}
impl AwaitExpression {
	pub fn inner_children(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct AwaitToken {
	pub(crate) syntax: SyntaxNode,
}
impl AwaitToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BangEqEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl BangEqEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BangEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl BangEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BangToken {
	pub(crate) syntax: SyntaxNode,
}
impl BangToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BinaryExpression {
	pub(crate) syntax: SyntaxNode,
}
impl BinaryExpression {
	pub fn left(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
	pub fn operator(&self) -> Option<BinaryExpressionOperator> {
		support::child(&self.syntax)
	}
	pub fn right(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BooleanToken {
	pub(crate) syntax: SyntaxNode,
}
impl BooleanToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BquoteToken {
	pub(crate) syntax: SyntaxNode,
}
impl BquoteToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakStatement {
	pub(crate) syntax: SyntaxNode,
}
impl BreakStatement {
	pub fn label(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::STATEMENT_IDENTIFIER)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct BreakToken {
	pub(crate) syntax: SyntaxNode,
}
impl BreakToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallExpression {
	pub(crate) syntax: SyntaxNode,
}
impl CallExpression {
	pub fn arguments(&self) -> Option<CallExpressionArguments> {
		support::child(&self.syntax)
	}
	pub fn function(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
	pub fn type_arguments(&self) -> Option<TypeArguments> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CallSignature {
	pub(crate) syntax: SyntaxNode,
}
impl CallSignature {
	pub fn parameters(&self) -> Option<FormalParameters> {
		support::child(&self.syntax)
	}
	pub fn return_type(&self) -> Option<CallSignatureReturnType> {
		support::child(&self.syntax)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CaretEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl CaretEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CaretToken {
	pub(crate) syntax: SyntaxNode,
}
impl CaretToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CaseToken {
	pub(crate) syntax: SyntaxNode,
}
impl CaseToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CatchClause {
	pub(crate) syntax: SyntaxNode,
}
impl CatchClause {
	pub fn body(&self) -> Option<StatementBlock> {
		support::child(&self.syntax)
	}
	pub fn parameter(&self) -> Option<CatchClauseParameter> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CatchToken {
	pub(crate) syntax: SyntaxNode,
}
impl CatchToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Class {
	pub(crate) syntax: SyntaxNode,
}
impl Class {
	pub fn body(&self) -> Option<ClassBody> {
		support::child(&self.syntax)
	}
	pub fn decorator(&self) -> AstChildren<Decorator> {
		support::children(&self.syntax)
	}
	pub fn inner_children(&self) -> Option<ClassHeritage> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::TYPE_IDENTIFIER)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClassBody {
	pub(crate) syntax: SyntaxNode,
}
impl ClassBody {
	pub fn inner_children(&self) -> AstChildren<ClassBodyInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClassDeclaration {
	pub(crate) syntax: SyntaxNode,
}
impl ClassDeclaration {
	pub fn body(&self) -> Option<ClassBody> {
		support::child(&self.syntax)
	}
	pub fn decorator(&self) -> AstChildren<Decorator> {
		support::children(&self.syntax)
	}
	pub fn inner_children(&self) -> Option<ClassHeritage> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::TYPE_IDENTIFIER)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClassHeritage {
	pub(crate) syntax: SyntaxNode,
}
impl ClassHeritage {
	pub fn inner_children(&self) -> AstChildren<ClassHeritageInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ClassToken {
	pub(crate) syntax: SyntaxNode,
}
impl ClassToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ColonToken {
	pub(crate) syntax: SyntaxNode,
}
impl ColonToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct CommaToken {
	pub(crate) syntax: SyntaxNode,
}
impl CommaToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Comment {
	pub(crate) syntax: SyntaxNode,
}
impl Comment {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ComputedPropertyName {
	pub(crate) syntax: SyntaxNode,
}
impl ComputedPropertyName {
	pub fn inner_children(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConditionalType {
	pub(crate) syntax: SyntaxNode,
}
impl ConditionalType {
	pub fn alternative(&self) -> Option<ConditionalTypeAlternative> {
		support::child(&self.syntax)
	}
	pub fn consequence(&self) -> Option<ConditionalTypeConsequence> {
		support::child(&self.syntax)
	}
	pub fn left(&self) -> Option<ConditionalTypeLeft> {
		support::child(&self.syntax)
	}
	pub fn right(&self) -> Option<ConditionalTypeRight> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstToken {
	pub(crate) syntax: SyntaxNode,
}
impl ConstToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Constraint {
	pub(crate) syntax: SyntaxNode,
}
impl Constraint {
	pub fn inner_children(&self) -> Option<ConstraintInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstructSignature {
	pub(crate) syntax: SyntaxNode,
}
impl ConstructSignature {
	pub fn inner_children(&self) -> AstChildren<ConstructSignatureInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ConstructorType {
	pub(crate) syntax: SyntaxNode,
}
impl ConstructorType {
	pub fn inner_children(&self) -> AstChildren<ConstructorTypeInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueStatement {
	pub(crate) syntax: SyntaxNode,
}
impl ContinueStatement {
	pub fn label(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::STATEMENT_IDENTIFIER)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ContinueToken {
	pub(crate) syntax: SyntaxNode,
}
impl ContinueToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DashDashToken {
	pub(crate) syntax: SyntaxNode,
}
impl DashDashToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DashEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl DashEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DashQmarkColonToken {
	pub(crate) syntax: SyntaxNode,
}
impl DashQmarkColonToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DashToken {
	pub(crate) syntax: SyntaxNode,
}
impl DashToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DebuggerStatement {
	pub(crate) syntax: SyntaxNode,
}
impl DebuggerStatement {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DebuggerToken {
	pub(crate) syntax: SyntaxNode,
}
impl DebuggerToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DeclareToken {
	pub(crate) syntax: SyntaxNode,
}
impl DeclareToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Decorator {
	pub(crate) syntax: SyntaxNode,
}
impl Decorator {
	pub fn inner_children(&self) -> Option<DecoratorInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefaultToken {
	pub(crate) syntax: SyntaxNode,
}
impl DefaultToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DefaultType {
	pub(crate) syntax: SyntaxNode,
}
impl DefaultType {
	pub fn inner_children(&self) -> Option<DefaultTypeInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DeleteToken {
	pub(crate) syntax: SyntaxNode,
}
impl DeleteToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DoStatement {
	pub(crate) syntax: SyntaxNode,
}
impl DoStatement {
	pub fn body(&self) -> Option<Statement> {
		support::child(&self.syntax)
	}
	pub fn condition(&self) -> Option<ParenthesizedExpression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DoToken {
	pub(crate) syntax: SyntaxNode,
}
impl DoToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DollarLbraceToken {
	pub(crate) syntax: SyntaxNode,
}
impl DollarLbraceToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DotDotDotToken {
	pub(crate) syntax: SyntaxNode,
}
impl DotDotDotToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DotToken {
	pub(crate) syntax: SyntaxNode,
}
impl DotToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct DquoteToken {
	pub(crate) syntax: SyntaxNode,
}
impl DquoteToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ElseClause {
	pub(crate) syntax: SyntaxNode,
}
impl ElseClause {
	pub fn inner_children(&self) -> Option<Statement> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ElseToken {
	pub(crate) syntax: SyntaxNode,
}
impl ElseToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EmptyStatement {
	pub(crate) syntax: SyntaxNode,
}
impl EmptyStatement {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumAssignment {
	pub(crate) syntax: SyntaxNode,
}
impl EnumAssignment {
	pub fn inner_children(&self) -> Option<EnumAssignmentInnerChildren> {
		support::child(&self.syntax)
	}
	pub fn value(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumBody {
	pub(crate) syntax: SyntaxNode,
}
impl EnumBody {
	pub fn inner_children(&self) -> AstChildren<EnumBodyInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumDeclaration {
	pub(crate) syntax: SyntaxNode,
}
impl EnumDeclaration {
	pub fn body(&self) -> Option<EnumBody> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::IDENTIFIER)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EnumToken {
	pub(crate) syntax: SyntaxNode,
}
impl EnumToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EqEqEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl EqEqEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EqEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl EqEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EqGtToken {
	pub(crate) syntax: SyntaxNode,
}
impl EqGtToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EqToken {
	pub(crate) syntax: SyntaxNode,
}
impl EqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct EscapeSequence {
	pub(crate) syntax: SyntaxNode,
}
impl EscapeSequence {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExistentialType {
	pub(crate) syntax: SyntaxNode,
}
impl ExistentialType {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExportClause {
	pub(crate) syntax: SyntaxNode,
}
impl ExportClause {
	pub fn inner_children(&self) -> AstChildren<ExportSpecifier> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExportSpecifier {
	pub(crate) syntax: SyntaxNode,
}
impl ExportSpecifier {
	pub fn alias(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::IDENTIFIER)
	}
	pub fn name(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::IDENTIFIER)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExportStatement {
	pub(crate) syntax: SyntaxNode,
}
impl ExportStatement {
	pub fn declaration(&self) -> Option<Declaration> {
		support::child(&self.syntax)
	}
	pub fn decorator(&self) -> AstChildren<Decorator> {
		support::children(&self.syntax)
	}
	pub fn inner_children(&self) -> Option<ExportStatementInnerChildren> {
		support::child(&self.syntax)
	}
	pub fn source(&self) -> Option<StringLiteral> {
		support::child(&self.syntax)
	}
	pub fn value(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExportToken {
	pub(crate) syntax: SyntaxNode,
}
impl ExportToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExpressionStatement {
	pub(crate) syntax: SyntaxNode,
}
impl ExpressionStatement {
	pub fn inner_children(&self) -> Option<ExpressionStatementInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExtendsClause {
	pub(crate) syntax: SyntaxNode,
}
impl ExtendsClause {
	pub fn inner_children(&self) -> AstChildren<ExtendsClauseInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ExtendsToken {
	pub(crate) syntax: SyntaxNode,
}
impl ExtendsToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct False {
	pub(crate) syntax: SyntaxNode,
}
impl False {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FinallyClause {
	pub(crate) syntax: SyntaxNode,
}
impl FinallyClause {
	pub fn body(&self) -> Option<StatementBlock> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FinallyToken {
	pub(crate) syntax: SyntaxNode,
}
impl FinallyToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FlowMaybeType {
	pub(crate) syntax: SyntaxNode,
}
impl FlowMaybeType {
	pub fn inner_children(&self) -> Option<PrimaryType> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForInStatement {
	pub(crate) syntax: SyntaxNode,
}
impl ForInStatement {
	pub fn body(&self) -> Option<Statement> {
		support::child(&self.syntax)
	}
	pub fn left(&self) -> Option<ForInStatementLeft> {
		support::child(&self.syntax)
	}
	pub fn right(&self) -> Option<ForInStatementRight> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForStatement {
	pub(crate) syntax: SyntaxNode,
}
impl ForStatement {
	pub fn body(&self) -> Option<Statement> {
		support::child(&self.syntax)
	}
	pub fn condition(&self) -> Option<ForStatementCondition> {
		support::child(&self.syntax)
	}
	pub fn increment(&self) -> Option<ForStatementIncrement> {
		support::child(&self.syntax)
	}
	pub fn initializer(&self) -> Option<ForStatementInitializer> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ForToken {
	pub(crate) syntax: SyntaxNode,
}
impl ForToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FormalParameters {
	pub(crate) syntax: SyntaxNode,
}
impl FormalParameters {
	pub fn inner_children(&self) -> AstChildren<FormalParametersInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FromToken {
	pub(crate) syntax: SyntaxNode,
}
impl FromToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Function {
	pub(crate) syntax: SyntaxNode,
}
impl Function {
	pub fn body(&self) -> Option<StatementBlock> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::IDENTIFIER)
	}
	pub fn parameters(&self) -> Option<FormalParameters> {
		support::child(&self.syntax)
	}
	pub fn return_type(&self) -> Option<FunctionReturnType> {
		support::child(&self.syntax)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionDeclaration {
	pub(crate) syntax: SyntaxNode,
}
impl FunctionDeclaration {
	pub fn body(&self) -> Option<StatementBlock> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::IDENTIFIER)
	}
	pub fn parameters(&self) -> Option<FormalParameters> {
		support::child(&self.syntax)
	}
	pub fn return_type(&self) -> Option<FunctionDeclarationReturnType> {
		support::child(&self.syntax)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionSignature {
	pub(crate) syntax: SyntaxNode,
}
impl FunctionSignature {
	pub fn name(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::IDENTIFIER)
	}
	pub fn parameters(&self) -> Option<FormalParameters> {
		support::child(&self.syntax)
	}
	pub fn return_type(&self) -> Option<FunctionSignatureReturnType> {
		support::child(&self.syntax)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionToken {
	pub(crate) syntax: SyntaxNode,
}
impl FunctionToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct FunctionType {
	pub(crate) syntax: SyntaxNode,
}
impl FunctionType {
	pub fn inner_children(&self) -> AstChildren<FunctionTypeInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GeneratorFunction {
	pub(crate) syntax: SyntaxNode,
}
impl GeneratorFunction {
	pub fn body(&self) -> Option<StatementBlock> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::IDENTIFIER)
	}
	pub fn parameters(&self) -> Option<FormalParameters> {
		support::child(&self.syntax)
	}
	pub fn return_type(&self) -> Option<GeneratorFunctionReturnType> {
		support::child(&self.syntax)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GeneratorFunctionDeclaration {
	pub(crate) syntax: SyntaxNode,
}
impl GeneratorFunctionDeclaration {
	pub fn body(&self) -> Option<StatementBlock> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::IDENTIFIER)
	}
	pub fn parameters(&self) -> Option<FormalParameters> {
		support::child(&self.syntax)
	}
	pub fn return_type(&self) -> Option<GeneratorFunctionDeclarationReturnType> {
		support::child(&self.syntax)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GenericType {
	pub(crate) syntax: SyntaxNode,
}
impl GenericType {
	pub fn inner_children(&self) -> AstChildren<GenericTypeInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GetToken {
	pub(crate) syntax: SyntaxNode,
}
impl GetToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GlobalToken {
	pub(crate) syntax: SyntaxNode,
}
impl GlobalToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GtEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl GtEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GtGtEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl GtGtEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GtGtGtEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl GtGtGtEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GtGtGtToken {
	pub(crate) syntax: SyntaxNode,
}
impl GtGtGtToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GtGtToken {
	pub(crate) syntax: SyntaxNode,
}
impl GtGtToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct GtToken {
	pub(crate) syntax: SyntaxNode,
}
impl GtToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct HashBangLine {
	pub(crate) syntax: SyntaxNode,
}
impl HashBangLine {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Identifier {
	pub(crate) syntax: SyntaxNode,
}
impl Identifier {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfStatement {
	pub(crate) syntax: SyntaxNode,
}
impl IfStatement {
	pub fn alternative(&self) -> Option<ElseClause> {
		support::child(&self.syntax)
	}
	pub fn condition(&self) -> Option<ParenthesizedExpression> {
		support::child(&self.syntax)
	}
	pub fn consequence(&self) -> Option<Statement> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IfToken {
	pub(crate) syntax: SyntaxNode,
}
impl IfToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImplementsClause {
	pub(crate) syntax: SyntaxNode,
}
impl ImplementsClause {
	pub fn inner_children(&self) -> AstChildren<ImplementsClauseInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImplementsToken {
	pub(crate) syntax: SyntaxNode,
}
impl ImplementsToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Import {
	pub(crate) syntax: SyntaxNode,
}
impl Import {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportAlias {
	pub(crate) syntax: SyntaxNode,
}
impl ImportAlias {
	pub fn inner_children(&self) -> AstChildren<ImportAliasInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportClause {
	pub(crate) syntax: SyntaxNode,
}
impl ImportClause {
	pub fn inner_children(&self) -> AstChildren<ImportClauseInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportRequireClause {
	pub(crate) syntax: SyntaxNode,
}
impl ImportRequireClause {
	pub fn inner_children(&self) -> AstChildren<ImportRequireClauseInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportSpecifier {
	pub(crate) syntax: SyntaxNode,
}
impl ImportSpecifier {
	pub fn alias(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::IDENTIFIER)
	}
	pub fn name(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::IDENTIFIER)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportStatement {
	pub(crate) syntax: SyntaxNode,
}
impl ImportStatement {
	pub fn inner_children(&self) -> Option<ImportStatementInnerChildren> {
		support::child(&self.syntax)
	}
	pub fn source(&self) -> Option<StringLiteral> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ImportToken {
	pub(crate) syntax: SyntaxNode,
}
impl ImportToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InToken {
	pub(crate) syntax: SyntaxNode,
}
impl InToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexSignature {
	pub(crate) syntax: SyntaxNode,
}
impl IndexSignature {
	pub fn inner_children(&self) -> AstChildren<IndexSignatureInnerChildren> {
		support::children(&self.syntax)
	}
	pub fn sign(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::DASH_TOKEN)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IndexTypeQuery {
	pub(crate) syntax: SyntaxNode,
}
impl IndexTypeQuery {
	pub fn inner_children(&self) -> Option<IndexTypeQueryInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InferToken {
	pub(crate) syntax: SyntaxNode,
}
impl InferToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InferType {
	pub(crate) syntax: SyntaxNode,
}
impl InferType {
	pub fn inner_children(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::TYPE_IDENTIFIER)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InstanceofToken {
	pub(crate) syntax: SyntaxNode,
}
impl InstanceofToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InterfaceDeclaration {
	pub(crate) syntax: SyntaxNode,
}
impl InterfaceDeclaration {
	pub fn body(&self) -> Option<ObjectType> {
		support::child(&self.syntax)
	}
	pub fn inner_children(&self) -> Option<ExtendsClause> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::TYPE_IDENTIFIER)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InterfaceToken {
	pub(crate) syntax: SyntaxNode,
}
impl InterfaceToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct InternalModule {
	pub(crate) syntax: SyntaxNode,
}
impl InternalModule {
	pub fn body(&self) -> Option<StatementBlock> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<InternalModuleName> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IntersectionType {
	pub(crate) syntax: SyntaxNode,
}
impl IntersectionType {
	pub fn inner_children(&self) -> AstChildren<IntersectionTypeInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct IsToken {
	pub(crate) syntax: SyntaxNode,
}
impl IsToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct JsxAttribute {
	pub(crate) syntax: SyntaxNode,
}
impl JsxAttribute {
	pub fn inner_children(&self) -> AstChildren<JsxAttributeInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct JsxClosingElement {
	pub(crate) syntax: SyntaxNode,
}
impl JsxClosingElement {
	pub fn name(&self) -> Option<JsxClosingElementName> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct JsxElement {
	pub(crate) syntax: SyntaxNode,
}
impl JsxElement {
	pub fn close_tag(&self) -> Option<JsxClosingElement> {
		support::child(&self.syntax)
	}
	pub fn inner_children(&self) -> AstChildren<JsxElementInnerChildren> {
		support::children(&self.syntax)
	}
	pub fn open_tag(&self) -> Option<JsxOpeningElement> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct JsxExpression {
	pub(crate) syntax: SyntaxNode,
}
impl JsxExpression {
	pub fn inner_children(&self) -> Option<JsxExpressionInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct JsxFragment {
	pub(crate) syntax: SyntaxNode,
}
impl JsxFragment {
	pub fn inner_children(&self) -> AstChildren<JsxFragmentInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct JsxNamespaceName {
	pub(crate) syntax: SyntaxNode,
}
impl JsxNamespaceName {
	pub fn inner_children(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::IDENTIFIER)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct JsxOpeningElement {
	pub(crate) syntax: SyntaxNode,
}
impl JsxOpeningElement {
	pub fn attribute(&self) -> AstChildren<JsxOpeningElementAttribute> {
		support::children(&self.syntax)
	}
	pub fn name(&self) -> Option<JsxOpeningElementName> {
		support::child(&self.syntax)
	}
	pub fn type_arguments(&self) -> Option<TypeArguments> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct JsxSelfClosingElement {
	pub(crate) syntax: SyntaxNode,
}
impl JsxSelfClosingElement {
	pub fn attribute(&self) -> AstChildren<JsxSelfClosingElementAttribute> {
		support::children(&self.syntax)
	}
	pub fn name(&self) -> Option<JsxSelfClosingElementName> {
		support::child(&self.syntax)
	}
	pub fn type_arguments(&self) -> Option<TypeArguments> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct JsxText {
	pub(crate) syntax: SyntaxNode,
}
impl JsxText {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct KeyofToken {
	pub(crate) syntax: SyntaxNode,
}
impl KeyofToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LabeledStatement {
	pub(crate) syntax: SyntaxNode,
}
impl LabeledStatement {
	pub fn inner_children(&self) -> Option<Statement> {
		support::child(&self.syntax)
	}
	pub fn label(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::STATEMENT_IDENTIFIER)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LbracePipeToken {
	pub(crate) syntax: SyntaxNode,
}
impl LbracePipeToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LbraceToken {
	pub(crate) syntax: SyntaxNode,
}
impl LbraceToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LbrackToken {
	pub(crate) syntax: SyntaxNode,
}
impl LbrackToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LetToken {
	pub(crate) syntax: SyntaxNode,
}
impl LetToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LexicalDeclaration {
	pub(crate) syntax: SyntaxNode,
}
impl LexicalDeclaration {
	pub fn inner_children(&self) -> AstChildren<VariableDeclarator> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LiteralType {
	pub(crate) syntax: SyntaxNode,
}
impl LiteralType {
	pub fn inner_children(&self) -> Option<LiteralTypeInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LookupType {
	pub(crate) syntax: SyntaxNode,
}
impl LookupType {
	pub fn inner_children(&self) -> AstChildren<LookupTypeInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LparenToken {
	pub(crate) syntax: SyntaxNode,
}
impl LparenToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LtEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl LtEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LtLtEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl LtLtEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LtLtToken {
	pub(crate) syntax: SyntaxNode,
}
impl LtLtToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct LtToken {
	pub(crate) syntax: SyntaxNode,
}
impl LtToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MappedTypeClause {
	pub(crate) syntax: SyntaxNode,
}
impl MappedTypeClause {
	pub fn inner_children(&self) -> AstChildren<MappedTypeClauseInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MemberExpression {
	pub(crate) syntax: SyntaxNode,
}
impl MemberExpression {
	pub fn object(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
	pub fn property(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::PROPERTY_IDENTIFIER)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MetaProperty {
	pub(crate) syntax: SyntaxNode,
}
impl MetaProperty {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodDefinition {
	pub(crate) syntax: SyntaxNode,
}
impl MethodDefinition {
	pub fn body(&self) -> Option<StatementBlock> {
		support::child(&self.syntax)
	}
	pub fn inner_children(&self) -> Option<AccessibilityModifier> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<MethodDefinitionName> {
		support::child(&self.syntax)
	}
	pub fn parameters(&self) -> Option<FormalParameters> {
		support::child(&self.syntax)
	}
	pub fn return_type(&self) -> Option<MethodDefinitionReturnType> {
		support::child(&self.syntax)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct MethodSignature {
	pub(crate) syntax: SyntaxNode,
}
impl MethodSignature {
	pub fn inner_children(&self) -> Option<AccessibilityModifier> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<MethodSignatureName> {
		support::child(&self.syntax)
	}
	pub fn parameters(&self) -> Option<FormalParameters> {
		support::child(&self.syntax)
	}
	pub fn return_type(&self) -> Option<MethodSignatureReturnType> {
		support::child(&self.syntax)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Module {
	pub(crate) syntax: SyntaxNode,
}
impl Module {
	pub fn body(&self) -> Option<StatementBlock> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<ModuleName> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ModuleToken {
	pub(crate) syntax: SyntaxNode,
}
impl ModuleToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamedImports {
	pub(crate) syntax: SyntaxNode,
}
impl NamedImports {
	pub fn inner_children(&self) -> AstChildren<ImportSpecifier> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamespaceImport {
	pub(crate) syntax: SyntaxNode,
}
impl NamespaceImport {
	pub fn inner_children(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::IDENTIFIER)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NamespaceToken {
	pub(crate) syntax: SyntaxNode,
}
impl NamespaceToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NestedIdentifier {
	pub(crate) syntax: SyntaxNode,
}
impl NestedIdentifier {
	pub fn inner_children(&self) -> AstChildren<NestedIdentifierInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NestedTypeIdentifier {
	pub(crate) syntax: SyntaxNode,
}
impl NestedTypeIdentifier {
	pub fn module(&self) -> Option<NestedTypeIdentifierModule> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::TYPE_IDENTIFIER)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NewExpression {
	pub(crate) syntax: SyntaxNode,
}
impl NewExpression {
	pub fn arguments(&self) -> Option<Arguments> {
		support::child(&self.syntax)
	}
	pub fn constructor(&self) -> Option<PrimaryExpression> {
		support::child(&self.syntax)
	}
	pub fn type_arguments(&self) -> Option<TypeArguments> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NewToken {
	pub(crate) syntax: SyntaxNode,
}
impl NewToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NonNullExpression {
	pub(crate) syntax: SyntaxNode,
}
impl NonNullExpression {
	pub fn inner_children(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Null {
	pub(crate) syntax: SyntaxNode,
}
impl Null {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Number {
	pub(crate) syntax: SyntaxNode,
}
impl Number {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct NumberToken {
	pub(crate) syntax: SyntaxNode,
}
impl NumberToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Object {
	pub(crate) syntax: SyntaxNode,
}
impl Object {
	pub fn inner_children(&self) -> AstChildren<ObjectInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ObjectAssignmentPattern {
	pub(crate) syntax: SyntaxNode,
}
impl ObjectAssignmentPattern {
	pub fn left(&self) -> Option<ObjectAssignmentPatternLeft> {
		support::child(&self.syntax)
	}
	pub fn right(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ObjectPattern {
	pub(crate) syntax: SyntaxNode,
}
impl ObjectPattern {
	pub fn inner_children(&self) -> AstChildren<ObjectPatternInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ObjectType {
	pub(crate) syntax: SyntaxNode,
}
impl ObjectType {
	pub fn inner_children(&self) -> AstChildren<ObjectTypeInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OfToken {
	pub(crate) syntax: SyntaxNode,
}
impl OfToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OmittingTypeAnnotation {
	pub(crate) syntax: SyntaxNode,
}
impl OmittingTypeAnnotation {
	pub fn inner_children(&self) -> Option<OmittingTypeAnnotationInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OptingTypeAnnotation {
	pub(crate) syntax: SyntaxNode,
}
impl OptingTypeAnnotation {
	pub fn inner_children(&self) -> Option<OptingTypeAnnotationInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OptionalParameter {
	pub(crate) syntax: SyntaxNode,
}
impl OptionalParameter {
	pub fn decorator(&self) -> AstChildren<Decorator> {
		support::children(&self.syntax)
	}
	pub fn inner_children(&self) -> AstChildren<OptionalParameterInnerChildren> {
		support::children(&self.syntax)
	}
	pub fn value(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct OptionalType {
	pub(crate) syntax: SyntaxNode,
}
impl OptionalType {
	pub fn inner_children(&self) -> Option<OptionalTypeInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Pair {
	pub(crate) syntax: SyntaxNode,
}
impl Pair {
	pub fn key(&self) -> Option<PairKey> {
		support::child(&self.syntax)
	}
	pub fn value(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PairPattern {
	pub(crate) syntax: SyntaxNode,
}
impl PairPattern {
	pub fn key(&self) -> Option<PairPatternKey> {
		support::child(&self.syntax)
	}
	pub fn value(&self) -> Option<Pattern> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenthesizedExpression {
	pub(crate) syntax: SyntaxNode,
}
impl ParenthesizedExpression {
	pub fn inner_children(&self) -> AstChildren<ParenthesizedExpressionInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ParenthesizedType {
	pub(crate) syntax: SyntaxNode,
}
impl ParenthesizedType {
	pub fn inner_children(&self) -> Option<ParenthesizedTypeInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PercentEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl PercentEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PercentToken {
	pub(crate) syntax: SyntaxNode,
}
impl PercentToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PipeEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl PipeEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PipePipeEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl PipePipeEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PipePipeToken {
	pub(crate) syntax: SyntaxNode,
}
impl PipePipeToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PipeRbraceToken {
	pub(crate) syntax: SyntaxNode,
}
impl PipeRbraceToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PipeToken {
	pub(crate) syntax: SyntaxNode,
}
impl PipeToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PlusEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl PlusEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PlusPlusToken {
	pub(crate) syntax: SyntaxNode,
}
impl PlusPlusToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PlusToken {
	pub(crate) syntax: SyntaxNode,
}
impl PlusToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PredefinedType {
	pub(crate) syntax: SyntaxNode,
}
impl PredefinedType {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PrivateToken {
	pub(crate) syntax: SyntaxNode,
}
impl PrivateToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Program {
	pub(crate) syntax: SyntaxNode,
}
impl Program {
	pub fn inner_children(&self) -> AstChildren<ProgramInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PropertyIdentifier {
	pub(crate) syntax: SyntaxNode,
}
impl PropertyIdentifier {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PropertySignature {
	pub(crate) syntax: SyntaxNode,
}
impl PropertySignature {
	pub fn inner_children(&self) -> Option<AccessibilityModifier> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<PropertySignatureName> {
		support::child(&self.syntax)
	}
	pub fn ty(&self) -> Option<TypeAnnotation> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ProtectedToken {
	pub(crate) syntax: SyntaxNode,
}
impl ProtectedToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PublicFieldDefinition {
	pub(crate) syntax: SyntaxNode,
}
impl PublicFieldDefinition {
	pub fn inner_children(&self) -> Option<AccessibilityModifier> {
		support::child(&self.syntax)
	}
	pub fn name(&self) -> Option<PublicFieldDefinitionName> {
		support::child(&self.syntax)
	}
	pub fn ty(&self) -> Option<TypeAnnotation> {
		support::child(&self.syntax)
	}
	pub fn value(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct PublicToken {
	pub(crate) syntax: SyntaxNode,
}
impl PublicToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QmarkColonToken {
	pub(crate) syntax: SyntaxNode,
}
impl QmarkColonToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QmarkDotToken {
	pub(crate) syntax: SyntaxNode,
}
impl QmarkDotToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QmarkQmarkEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl QmarkQmarkEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QmarkQmarkToken {
	pub(crate) syntax: SyntaxNode,
}
impl QmarkQmarkToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct QmarkToken {
	pub(crate) syntax: SyntaxNode,
}
impl QmarkToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RbraceToken {
	pub(crate) syntax: SyntaxNode,
}
impl RbraceToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RbrackToken {
	pub(crate) syntax: SyntaxNode,
}
impl RbrackToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReadonlyToken {
	pub(crate) syntax: SyntaxNode,
}
impl ReadonlyToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReadonlyType {
	pub(crate) syntax: SyntaxNode,
}
impl ReadonlyType {
	pub fn inner_children(&self) -> Option<ReadonlyTypeInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Regex {
	pub(crate) syntax: SyntaxNode,
}
impl Regex {
	pub fn flags(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::REGEX_FLAGS)
	}
	pub fn pattern(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::REGEX_PATTERN)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RegexFlags {
	pub(crate) syntax: SyntaxNode,
}
impl RegexFlags {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RegexPattern {
	pub(crate) syntax: SyntaxNode,
}
impl RegexPattern {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RequireToken {
	pub(crate) syntax: SyntaxNode,
}
impl RequireToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RequiredParameter {
	pub(crate) syntax: SyntaxNode,
}
impl RequiredParameter {
	pub fn decorator(&self) -> AstChildren<Decorator> {
		support::children(&self.syntax)
	}
	pub fn inner_children(&self) -> AstChildren<RequiredParameterInnerChildren> {
		support::children(&self.syntax)
	}
	pub fn value(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestPattern {
	pub(crate) syntax: SyntaxNode,
}
impl RestPattern {
	pub fn inner_children(&self) -> Option<RestPatternInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RestType {
	pub(crate) syntax: SyntaxNode,
}
impl RestType {
	pub fn inner_children(&self) -> Option<RestTypeInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnStatement {
	pub(crate) syntax: SyntaxNode,
}
impl ReturnStatement {
	pub fn inner_children(&self) -> Option<ReturnStatementInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ReturnToken {
	pub(crate) syntax: SyntaxNode,
}
impl ReturnToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct RparenToken {
	pub(crate) syntax: SyntaxNode,
}
impl RparenToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SemiToken {
	pub(crate) syntax: SyntaxNode,
}
impl SemiToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SequenceExpression {
	pub(crate) syntax: SyntaxNode,
}
impl SequenceExpression {
	pub fn left(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
	pub fn right(&self) -> Option<SequenceExpressionRight> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SetToken {
	pub(crate) syntax: SyntaxNode,
}
impl SetToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ShorthandPropertyIdentifier {
	pub(crate) syntax: SyntaxNode,
}
impl ShorthandPropertyIdentifier {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ShorthandPropertyIdentifierPattern {
	pub(crate) syntax: SyntaxNode,
}
impl ShorthandPropertyIdentifierPattern {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SlashEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl SlashEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SlashToken {
	pub(crate) syntax: SyntaxNode,
}
impl SlashToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SpreadElement {
	pub(crate) syntax: SyntaxNode,
}
impl SpreadElement {
	pub fn inner_children(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SquoteToken {
	pub(crate) syntax: SyntaxNode,
}
impl SquoteToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StarEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl StarEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StarStarEqToken {
	pub(crate) syntax: SyntaxNode,
}
impl StarStarEqToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StarStarToken {
	pub(crate) syntax: SyntaxNode,
}
impl StarStarToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StarToken {
	pub(crate) syntax: SyntaxNode,
}
impl StarToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StatementBlock {
	pub(crate) syntax: SyntaxNode,
}
impl StatementBlock {
	pub fn inner_children(&self) -> AstChildren<Statement> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StatementIdentifier {
	pub(crate) syntax: SyntaxNode,
}
impl StatementIdentifier {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StaticToken {
	pub(crate) syntax: SyntaxNode,
}
impl StaticToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StringLiteral {
	pub(crate) syntax: SyntaxNode,
}
impl StringLiteral {
	pub fn inner_children(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::ESCAPE_SEQUENCE)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct StringToken {
	pub(crate) syntax: SyntaxNode,
}
impl StringToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SubscriptExpression {
	pub(crate) syntax: SyntaxNode,
}
impl SubscriptExpression {
	pub fn index(&self) -> Option<SubscriptExpressionIndex> {
		support::child(&self.syntax)
	}
	pub fn object(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Super {
	pub(crate) syntax: SyntaxNode,
}
impl Super {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SwitchBody {
	pub(crate) syntax: SyntaxNode,
}
impl SwitchBody {
	pub fn inner_children(&self) -> AstChildren<SwitchBodyInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SwitchCase {
	pub(crate) syntax: SyntaxNode,
}
impl SwitchCase {
	pub fn inner_children(&self) -> AstChildren<Statement> {
		support::children(&self.syntax)
	}
	pub fn value(&self) -> Option<SwitchCaseValue> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SwitchDefault {
	pub(crate) syntax: SyntaxNode,
}
impl SwitchDefault {
	pub fn inner_children(&self) -> AstChildren<Statement> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SwitchStatement {
	pub(crate) syntax: SyntaxNode,
}
impl SwitchStatement {
	pub fn body(&self) -> Option<SwitchBody> {
		support::child(&self.syntax)
	}
	pub fn value(&self) -> Option<ParenthesizedExpression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SwitchToken {
	pub(crate) syntax: SyntaxNode,
}
impl SwitchToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct SymbolToken {
	pub(crate) syntax: SyntaxNode,
}
impl SymbolToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TargetToken {
	pub(crate) syntax: SyntaxNode,
}
impl TargetToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TemplateString {
	pub(crate) syntax: SyntaxNode,
}
impl TemplateString {
	pub fn inner_children(&self) -> AstChildren<TemplateStringInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TemplateSubstitution {
	pub(crate) syntax: SyntaxNode,
}
impl TemplateSubstitution {
	pub fn inner_children(&self) -> Option<TemplateSubstitutionInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TernaryExpression {
	pub(crate) syntax: SyntaxNode,
}
impl TernaryExpression {
	pub fn alternative(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
	pub fn condition(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
	pub fn consequence(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct This {
	pub(crate) syntax: SyntaxNode,
}
impl This {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ThrowStatement {
	pub(crate) syntax: SyntaxNode,
}
impl ThrowStatement {
	pub fn inner_children(&self) -> Option<ThrowStatementInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct ThrowToken {
	pub(crate) syntax: SyntaxNode,
}
impl ThrowToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TildeToken {
	pub(crate) syntax: SyntaxNode,
}
impl TildeToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct True {
	pub(crate) syntax: SyntaxNode,
}
impl True {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryStatement {
	pub(crate) syntax: SyntaxNode,
}
impl TryStatement {
	pub fn body(&self) -> Option<StatementBlock> {
		support::child(&self.syntax)
	}
	pub fn finalizer(&self) -> Option<FinallyClause> {
		support::child(&self.syntax)
	}
	pub fn handler(&self) -> Option<CatchClause> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TryToken {
	pub(crate) syntax: SyntaxNode,
}
impl TryToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TupleType {
	pub(crate) syntax: SyntaxNode,
}
impl TupleType {
	pub fn inner_children(&self) -> AstChildren<TupleTypeInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeAliasDeclaration {
	pub(crate) syntax: SyntaxNode,
}
impl TypeAliasDeclaration {
	pub fn name(&self) -> Option<SyntaxToken> {
		support::token(&self.syntax, SyntaxKind::TYPE_IDENTIFIER)
	}
	pub fn type_parameters(&self) -> Option<TypeParameters> {
		support::child(&self.syntax)
	}
	pub fn value(&self) -> Option<TypeAliasDeclarationValue> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeAnnotation {
	pub(crate) syntax: SyntaxNode,
}
impl TypeAnnotation {
	pub fn inner_children(&self) -> Option<TypeAnnotationInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeArguments {
	pub(crate) syntax: SyntaxNode,
}
impl TypeArguments {
	pub fn inner_children(&self) -> AstChildren<TypeArgumentsInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeAssertion {
	pub(crate) syntax: SyntaxNode,
}
impl TypeAssertion {
	pub fn inner_children(&self) -> AstChildren<TypeAssertionInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeIdentifier {
	pub(crate) syntax: SyntaxNode,
}
impl TypeIdentifier {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParameter {
	pub(crate) syntax: SyntaxNode,
}
impl TypeParameter {
	pub fn inner_children(&self) -> AstChildren<TypeParameterInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeParameters {
	pub(crate) syntax: SyntaxNode,
}
impl TypeParameters {
	pub fn inner_children(&self) -> AstChildren<TypeParameter> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypePredicate {
	pub(crate) syntax: SyntaxNode,
}
impl TypePredicate {
	pub fn inner_children(&self) -> AstChildren<TypePredicateInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypePredicateAnnotation {
	pub(crate) syntax: SyntaxNode,
}
impl TypePredicateAnnotation {
	pub fn inner_children(&self) -> Option<TypePredicate> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeQuery {
	pub(crate) syntax: SyntaxNode,
}
impl TypeQuery {
	pub fn inner_children(&self) -> Option<TypeQueryInnerChildren> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeToken {
	pub(crate) syntax: SyntaxNode,
}
impl TypeToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct TypeofToken {
	pub(crate) syntax: SyntaxNode,
}
impl TypeofToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnaryExpression {
	pub(crate) syntax: SyntaxNode,
}
impl UnaryExpression {
	pub fn argument(&self) -> Option<UnaryExpressionArgument> {
		support::child(&self.syntax)
	}
	pub fn operator(&self) -> Option<UnaryExpressionOperator> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct Undefined {
	pub(crate) syntax: SyntaxNode,
}
impl Undefined {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UnionType {
	pub(crate) syntax: SyntaxNode,
}
impl UnionType {
	pub fn inner_children(&self) -> AstChildren<UnionTypeInnerChildren> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct UpdateExpression {
	pub(crate) syntax: SyntaxNode,
}
impl UpdateExpression {
	pub fn argument(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
	pub fn operator(&self) -> Option<UpdateExpressionOperator> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VarToken {
	pub(crate) syntax: SyntaxNode,
}
impl VarToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariableDeclaration {
	pub(crate) syntax: SyntaxNode,
}
impl VariableDeclaration {
	pub fn inner_children(&self) -> AstChildren<VariableDeclarator> {
		support::children(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VariableDeclarator {
	pub(crate) syntax: SyntaxNode,
}
impl VariableDeclarator {
	pub fn name(&self) -> Option<VariableDeclaratorName> {
		support::child(&self.syntax)
	}
	pub fn ty(&self) -> Option<TypeAnnotation> {
		support::child(&self.syntax)
	}
	pub fn value(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct VoidToken {
	pub(crate) syntax: SyntaxNode,
}
impl VoidToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileStatement {
	pub(crate) syntax: SyntaxNode,
}
impl WhileStatement {
	pub fn body(&self) -> Option<Statement> {
		support::child(&self.syntax)
	}
	pub fn condition(&self) -> Option<ParenthesizedExpression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WhileToken {
	pub(crate) syntax: SyntaxNode,
}
impl WhileToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WithStatement {
	pub(crate) syntax: SyntaxNode,
}
impl WithStatement {
	pub fn body(&self) -> Option<Statement> {
		support::child(&self.syntax)
	}
	pub fn object(&self) -> Option<ParenthesizedExpression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct WithToken {
	pub(crate) syntax: SyntaxNode,
}
impl WithToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct YieldExpression {
	pub(crate) syntax: SyntaxNode,
}
impl YieldExpression {
	pub fn inner_children(&self) -> Option<Expression> {
		support::child(&self.syntax)
	}
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub struct YieldToken {
	pub(crate) syntax: SyntaxNode,
}
impl YieldToken {}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AbstractMethodSignatureName {
	ComputedPropertyName(ComputedPropertyName),
	Number(Number),
	PropertyIdentifier(PropertyIdentifier),
	StringLiteral(StringLiteral),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AbstractMethodSignatureReturnType {
	Asserts(Asserts),
	TypeAnnotation(TypeAnnotation),
	TypePredicateAnnotation(TypePredicateAnnotation),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AmbientDeclarationInnerChildren {
	ConstructorType(ConstructorType),
	Declaration(Declaration),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	PropertyIdentifier(PropertyIdentifier),
	ReadonlyType(ReadonlyType),
	StatementBlock(StatementBlock),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ArgumentsInnerChildren {
	Expression(Expression),
	SpreadElement(SpreadElement),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ArrayInnerChildren {
	Expression(Expression),
	SpreadElement(SpreadElement),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ArrayPatternInnerChildren {
	AssignmentPattern(AssignmentPattern),
	Pattern(Pattern),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ArrowFunctionBody {
	Expression(Expression),
	StatementBlock(StatementBlock),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ArrowFunctionReturnType {
	Asserts(Asserts),
	TypeAnnotation(TypeAnnotation),
	TypePredicateAnnotation(TypePredicateAnnotation),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AsExpressionInnerChildren {
	ConstructorType(ConstructorType),
	Expression(Expression),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	TemplateString(TemplateString),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AssertsInnerChildren {
	Identifier(Identifier),
	This(This),
	TypePredicate(TypePredicate),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AssignmentExpressionLeft {
	ArrayPattern(ArrayPattern),
	Identifier(Identifier),
	MemberExpression(MemberExpression),
	NonNullExpression(NonNullExpression),
	ObjectPattern(ObjectPattern),
	ParenthesizedExpression(ParenthesizedExpression),
	SubscriptExpression(SubscriptExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum AugmentedAssignmentExpressionLeft {
	Identifier(Identifier),
	MemberExpression(MemberExpression),
	NonNullExpression(NonNullExpression),
	ParenthesizedExpression(ParenthesizedExpression),
	SubscriptExpression(SubscriptExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum BinaryExpressionOperator {
	AmpAmpToken(AmpAmpToken),
	AmpToken(AmpToken),
	BangEqEqToken(BangEqEqToken),
	BangEqToken(BangEqToken),
	CaretToken(CaretToken),
	DashToken(DashToken),
	EqEqEqToken(EqEqEqToken),
	EqEqToken(EqEqToken),
	GtEqToken(GtEqToken),
	GtGtGtToken(GtGtGtToken),
	GtGtToken(GtGtToken),
	GtToken(GtToken),
	InToken(InToken),
	InstanceofToken(InstanceofToken),
	LtEqToken(LtEqToken),
	LtLtToken(LtLtToken),
	LtToken(LtToken),
	PercentToken(PercentToken),
	PipePipeToken(PipePipeToken),
	PipeToken(PipeToken),
	PlusToken(PlusToken),
	QmarkQmarkToken(QmarkQmarkToken),
	SlashToken(SlashToken),
	StarStarToken(StarStarToken),
	StarToken(StarToken),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum CallExpressionArguments {
	Arguments(Arguments),
	TemplateString(TemplateString),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum CallSignatureReturnType {
	Asserts(Asserts),
	TypeAnnotation(TypeAnnotation),
	TypePredicateAnnotation(TypePredicateAnnotation),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum CatchClauseParameter {
	ArrayPattern(ArrayPattern),
	Identifier(Identifier),
	ObjectPattern(ObjectPattern),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ClassBodyInnerChildren {
	AbstractMethodSignature(AbstractMethodSignature),
	Decorator(Decorator),
	IndexSignature(IndexSignature),
	MethodDefinition(MethodDefinition),
	MethodSignature(MethodSignature),
	PublicFieldDefinition(PublicFieldDefinition),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ClassHeritageInnerChildren {
	ExtendsClause(ExtendsClause),
	ImplementsClause(ImplementsClause),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ConditionalTypeAlternative {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ConditionalTypeConsequence {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ConditionalTypeLeft {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ConditionalTypeRight {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ConstraintInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ConstructSignatureInnerChildren {
	FormalParameters(FormalParameters),
	TypeAnnotation(TypeAnnotation),
	TypeParameters(TypeParameters),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ConstructorTypeInnerChildren {
	ConstructorType(ConstructorType),
	FormalParameters(FormalParameters),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	TypeParameters(TypeParameters),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Declaration {
	AbstractClassDeclaration(AbstractClassDeclaration),
	AmbientDeclaration(AmbientDeclaration),
	ClassDeclaration(ClassDeclaration),
	EnumDeclaration(EnumDeclaration),
	FunctionDeclaration(FunctionDeclaration),
	FunctionSignature(FunctionSignature),
	GeneratorFunctionDeclaration(GeneratorFunctionDeclaration),
	ImportAlias(ImportAlias),
	InterfaceDeclaration(InterfaceDeclaration),
	InternalModule(InternalModule),
	LexicalDeclaration(LexicalDeclaration),
	Module(Module),
	TypeAliasDeclaration(TypeAliasDeclaration),
	VariableDeclaration(VariableDeclaration),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DecoratorInnerChildren {
	CallExpression(CallExpression),
	Identifier(Identifier),
	MemberExpression(MemberExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum DefaultTypeInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum EnumAssignmentInnerChildren {
	ComputedPropertyName(ComputedPropertyName),
	Number(Number),
	PropertyIdentifier(PropertyIdentifier),
	StringLiteral(StringLiteral),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum EnumBodyInnerChildren {
	ComputedPropertyName(ComputedPropertyName),
	EnumAssignment(EnumAssignment),
	Number(Number),
	PropertyIdentifier(PropertyIdentifier),
	StringLiteral(StringLiteral),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ExportStatementInnerChildren {
	ExportClause(ExportClause),
	FunctionSignature(FunctionSignature),
	Identifier(Identifier),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Expression {
	AsExpression(AsExpression),
	AssignmentExpression(AssignmentExpression),
	AugmentedAssignmentExpression(AugmentedAssignmentExpression),
	AwaitExpression(AwaitExpression),
	BinaryExpression(BinaryExpression),
	InternalModule(InternalModule),
	JsxElement(JsxElement),
	JsxFragment(JsxFragment),
	JsxSelfClosingElement(JsxSelfClosingElement),
	NewExpression(NewExpression),
	PrimaryExpression(PrimaryExpression),
	TernaryExpression(TernaryExpression),
	TypeAssertion(TypeAssertion),
	UnaryExpression(UnaryExpression),
	UpdateExpression(UpdateExpression),
	YieldExpression(YieldExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ExpressionStatementInnerChildren {
	Expression(Expression),
	SequenceExpression(SequenceExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ExtendsClauseInnerChildren {
	Expression(Expression),
	GenericType(GenericType),
	NestedTypeIdentifier(NestedTypeIdentifier),
	TypeIdentifier(TypeIdentifier),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ForInStatementLeft {
	ArrayPattern(ArrayPattern),
	Identifier(Identifier),
	MemberExpression(MemberExpression),
	NonNullExpression(NonNullExpression),
	ObjectPattern(ObjectPattern),
	ParenthesizedExpression(ParenthesizedExpression),
	SubscriptExpression(SubscriptExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ForInStatementRight {
	Expression(Expression),
	SequenceExpression(SequenceExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ForStatementCondition {
	EmptyStatement(EmptyStatement),
	ExpressionStatement(ExpressionStatement),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ForStatementIncrement {
	Expression(Expression),
	SequenceExpression(SequenceExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ForStatementInitializer {
	EmptyStatement(EmptyStatement),
	ExpressionStatement(ExpressionStatement),
	LexicalDeclaration(LexicalDeclaration),
	VariableDeclaration(VariableDeclaration),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FormalParametersInnerChildren {
	OptionalParameter(OptionalParameter),
	RequiredParameter(RequiredParameter),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FunctionDeclarationReturnType {
	Asserts(Asserts),
	TypeAnnotation(TypeAnnotation),
	TypePredicateAnnotation(TypePredicateAnnotation),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FunctionReturnType {
	Asserts(Asserts),
	TypeAnnotation(TypeAnnotation),
	TypePredicateAnnotation(TypePredicateAnnotation),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FunctionSignatureReturnType {
	Asserts(Asserts),
	TypeAnnotation(TypeAnnotation),
	TypePredicateAnnotation(TypePredicateAnnotation),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum FunctionTypeInnerChildren {
	ConstructorType(ConstructorType),
	FormalParameters(FormalParameters),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	TypeParameters(TypeParameters),
	TypePredicate(TypePredicate),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GeneratorFunctionDeclarationReturnType {
	Asserts(Asserts),
	TypeAnnotation(TypeAnnotation),
	TypePredicateAnnotation(TypePredicateAnnotation),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GeneratorFunctionReturnType {
	Asserts(Asserts),
	TypeAnnotation(TypeAnnotation),
	TypePredicateAnnotation(TypePredicateAnnotation),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum GenericTypeInnerChildren {
	NestedTypeIdentifier(NestedTypeIdentifier),
	TypeArguments(TypeArguments),
	TypeIdentifier(TypeIdentifier),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ImplementsClauseInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ImportAliasInnerChildren {
	Identifier(Identifier),
	NestedIdentifier(NestedIdentifier),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ImportClauseInnerChildren {
	Identifier(Identifier),
	NamedImports(NamedImports),
	NamespaceImport(NamespaceImport),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ImportRequireClauseInnerChildren {
	Identifier(Identifier),
	StringLiteral(StringLiteral),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ImportStatementInnerChildren {
	ImportClause(ImportClause),
	ImportRequireClause(ImportRequireClause),
	StringLiteral(StringLiteral),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum IndexSignatureInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	Identifier(Identifier),
	InferType(InferType),
	IntersectionType(IntersectionType),
	MappedTypeClause(MappedTypeClause),
	OmittingTypeAnnotation(OmittingTypeAnnotation),
	OptingTypeAnnotation(OptingTypeAnnotation),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	TypeAnnotation(TypeAnnotation),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum IndexTypeQueryInnerChildren {
	GenericType(GenericType),
	NestedTypeIdentifier(NestedTypeIdentifier),
	TypeIdentifier(TypeIdentifier),
	TypeQuery(TypeQuery),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum InternalModuleName {
	Identifier(Identifier),
	NestedIdentifier(NestedIdentifier),
	StringLiteral(StringLiteral),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum IntersectionTypeInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum JsxAttributeInnerChildren {
	JsxElement(JsxElement),
	JsxExpression(JsxExpression),
	JsxFragment(JsxFragment),
	JsxNamespaceName(JsxNamespaceName),
	JsxSelfClosingElement(JsxSelfClosingElement),
	PropertyIdentifier(PropertyIdentifier),
	StringLiteral(StringLiteral),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum JsxClosingElementName {
	Identifier(Identifier),
	JsxNamespaceName(JsxNamespaceName),
	NestedIdentifier(NestedIdentifier),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum JsxElementInnerChildren {
	JsxElement(JsxElement),
	JsxExpression(JsxExpression),
	JsxFragment(JsxFragment),
	JsxSelfClosingElement(JsxSelfClosingElement),
	JsxText(JsxText),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum JsxExpressionInnerChildren {
	Expression(Expression),
	SequenceExpression(SequenceExpression),
	SpreadElement(SpreadElement),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum JsxFragmentInnerChildren {
	JsxElement(JsxElement),
	JsxExpression(JsxExpression),
	JsxFragment(JsxFragment),
	JsxSelfClosingElement(JsxSelfClosingElement),
	JsxText(JsxText),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum JsxOpeningElementAttribute {
	JsxAttribute(JsxAttribute),
	JsxExpression(JsxExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum JsxOpeningElementName {
	Identifier(Identifier),
	JsxNamespaceName(JsxNamespaceName),
	NestedIdentifier(NestedIdentifier),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum JsxSelfClosingElementAttribute {
	JsxAttribute(JsxAttribute),
	JsxExpression(JsxExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum JsxSelfClosingElementName {
	Identifier(Identifier),
	JsxNamespaceName(JsxNamespaceName),
	NestedIdentifier(NestedIdentifier),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LiteralTypeInnerChildren {
	False(False),
	Number(Number),
	StringLiteral(StringLiteral),
	True(True),
	UnaryExpression(UnaryExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum LookupTypeInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MappedTypeClauseInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MethodDefinitionName {
	ComputedPropertyName(ComputedPropertyName),
	Number(Number),
	PropertyIdentifier(PropertyIdentifier),
	StringLiteral(StringLiteral),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MethodDefinitionReturnType {
	Asserts(Asserts),
	TypeAnnotation(TypeAnnotation),
	TypePredicateAnnotation(TypePredicateAnnotation),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MethodSignatureName {
	ComputedPropertyName(ComputedPropertyName),
	Number(Number),
	PropertyIdentifier(PropertyIdentifier),
	StringLiteral(StringLiteral),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum MethodSignatureReturnType {
	Asserts(Asserts),
	TypeAnnotation(TypeAnnotation),
	TypePredicateAnnotation(TypePredicateAnnotation),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ModuleName {
	Identifier(Identifier),
	NestedIdentifier(NestedIdentifier),
	StringLiteral(StringLiteral),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum NestedIdentifierInnerChildren {
	Identifier(Identifier),
	NestedIdentifier(NestedIdentifier),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum NestedTypeIdentifierModule {
	Identifier(Identifier),
	NestedIdentifier(NestedIdentifier),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ObjectAssignmentPatternLeft {
	ArrayPattern(ArrayPattern),
	ObjectPattern(ObjectPattern),
	ShorthandPropertyIdentifierPattern(ShorthandPropertyIdentifierPattern),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ObjectInnerChildren {
	MethodDefinition(MethodDefinition),
	Pair(Pair),
	ShorthandPropertyIdentifier(ShorthandPropertyIdentifier),
	SpreadElement(SpreadElement),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ObjectPatternInnerChildren {
	ObjectAssignmentPattern(ObjectAssignmentPattern),
	PairPattern(PairPattern),
	RestPattern(RestPattern),
	ShorthandPropertyIdentifierPattern(ShorthandPropertyIdentifierPattern),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ObjectTypeInnerChildren {
	CallSignature(CallSignature),
	ConstructSignature(ConstructSignature),
	ExportStatement(ExportStatement),
	IndexSignature(IndexSignature),
	MethodSignature(MethodSignature),
	PropertySignature(PropertySignature),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum OmittingTypeAnnotationInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum OptingTypeAnnotationInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum OptionalParameterInnerChildren {
	AccessibilityModifier(AccessibilityModifier),
	Pattern(Pattern),
	This(This),
	TypeAnnotation(TypeAnnotation),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum OptionalTypeInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PairKey {
	ComputedPropertyName(ComputedPropertyName),
	Number(Number),
	PropertyIdentifier(PropertyIdentifier),
	StringLiteral(StringLiteral),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PairPatternKey {
	ComputedPropertyName(ComputedPropertyName),
	Number(Number),
	PropertyIdentifier(PropertyIdentifier),
	StringLiteral(StringLiteral),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ParenthesizedExpressionInnerChildren {
	Expression(Expression),
	SequenceExpression(SequenceExpression),
	TypeAnnotation(TypeAnnotation),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ParenthesizedTypeInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Pattern {
	ArrayPattern(ArrayPattern),
	Identifier(Identifier),
	ObjectPattern(ObjectPattern),
	RestPattern(RestPattern),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PrimaryExpression {
	Array(Array),
	ArrowFunction(ArrowFunction),
	CallExpression(CallExpression),
	Class(Class),
	False(False),
	Function(Function),
	GeneratorFunction(GeneratorFunction),
	Identifier(Identifier),
	Import(Import),
	MemberExpression(MemberExpression),
	MetaProperty(MetaProperty),
	NonNullExpression(NonNullExpression),
	Null(Null),
	Number(Number),
	Object(Object),
	ParenthesizedExpression(ParenthesizedExpression),
	Regex(Regex),
	StringLiteral(StringLiteral),
	SubscriptExpression(SubscriptExpression),
	Super(Super),
	TemplateString(TemplateString),
	This(This),
	True(True),
	Undefined(Undefined),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PrimaryType {
	ArrayType(ArrayType),
	ConditionalType(ConditionalType),
	ExistentialType(ExistentialType),
	FlowMaybeType(FlowMaybeType),
	GenericType(GenericType),
	IndexTypeQuery(IndexTypeQuery),
	LiteralType(LiteralType),
	LookupType(LookupType),
	NestedTypeIdentifier(NestedTypeIdentifier),
	ObjectType(ObjectType),
	ParenthesizedType(ParenthesizedType),
	PredefinedType(PredefinedType),
	This(This),
	TupleType(TupleType),
	TypeIdentifier(TypeIdentifier),
	TypeQuery(TypeQuery),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ProgramInnerChildren {
	HashBangLine(HashBangLine),
	Statement(Statement),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PropertySignatureName {
	ComputedPropertyName(ComputedPropertyName),
	Number(Number),
	PropertyIdentifier(PropertyIdentifier),
	StringLiteral(StringLiteral),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum PublicFieldDefinitionName {
	ComputedPropertyName(ComputedPropertyName),
	Number(Number),
	PropertyIdentifier(PropertyIdentifier),
	StringLiteral(StringLiteral),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ReadonlyTypeInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RequiredParameterInnerChildren {
	AccessibilityModifier(AccessibilityModifier),
	Pattern(Pattern),
	This(This),
	TypeAnnotation(TypeAnnotation),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RestPatternInnerChildren {
	ArrayPattern(ArrayPattern),
	Identifier(Identifier),
	ObjectPattern(ObjectPattern),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum RestTypeInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ReturnStatementInnerChildren {
	Expression(Expression),
	SequenceExpression(SequenceExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SequenceExpressionRight {
	Expression(Expression),
	SequenceExpression(SequenceExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum Statement {
	BreakStatement(BreakStatement),
	ContinueStatement(ContinueStatement),
	DebuggerStatement(DebuggerStatement),
	Declaration(Declaration),
	DoStatement(DoStatement),
	EmptyStatement(EmptyStatement),
	ExportStatement(ExportStatement),
	ExpressionStatement(ExpressionStatement),
	ForInStatement(ForInStatement),
	ForStatement(ForStatement),
	IfStatement(IfStatement),
	ImportStatement(ImportStatement),
	LabeledStatement(LabeledStatement),
	ReturnStatement(ReturnStatement),
	StatementBlock(StatementBlock),
	SwitchStatement(SwitchStatement),
	ThrowStatement(ThrowStatement),
	TryStatement(TryStatement),
	WhileStatement(WhileStatement),
	WithStatement(WithStatement),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SubscriptExpressionIndex {
	Expression(Expression),
	SequenceExpression(SequenceExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SwitchBodyInnerChildren {
	SwitchCase(SwitchCase),
	SwitchDefault(SwitchDefault),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum SwitchCaseValue {
	Expression(Expression),
	SequenceExpression(SequenceExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TemplateStringInnerChildren {
	EscapeSequence(EscapeSequence),
	TemplateSubstitution(TemplateSubstitution),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TemplateSubstitutionInnerChildren {
	Expression(Expression),
	SequenceExpression(SequenceExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum ThrowStatementInnerChildren {
	Expression(Expression),
	SequenceExpression(SequenceExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TupleTypeInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	OptionalParameter(OptionalParameter),
	OptionalType(OptionalType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	RequiredParameter(RequiredParameter),
	RestType(RestType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TypeAliasDeclarationValue {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TypeAnnotationInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TypeArgumentsInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TypeAssertionInnerChildren {
	Expression(Expression),
	TypeArguments(TypeArguments),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TypeParameterInnerChildren {
	Constraint(Constraint),
	DefaultType(DefaultType),
	TypeIdentifier(TypeIdentifier),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TypePredicateInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	Identifier(Identifier),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum TypeQueryInnerChildren {
	GenericType(GenericType),
	PrimaryExpression(PrimaryExpression),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum UnaryExpressionArgument {
	Expression(Expression),
	Number(Number),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum UnaryExpressionOperator {
	BangToken(BangToken),
	DashToken(DashToken),
	DeleteToken(DeleteToken),
	PlusToken(PlusToken),
	TildeToken(TildeToken),
	TypeofToken(TypeofToken),
	VoidToken(VoidToken),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum UnionTypeInnerChildren {
	ConstructorType(ConstructorType),
	FunctionType(FunctionType),
	InferType(InferType),
	IntersectionType(IntersectionType),
	PrimaryType(PrimaryType),
	ReadonlyType(ReadonlyType),
	UnionType(UnionType),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum UpdateExpressionOperator {
	DashDashToken(DashDashToken),
	PlusPlusToken(PlusPlusToken),
}
#[derive(Debug, Clone, PartialEq, Eq, Hash)]
pub enum VariableDeclaratorName {
	ArrayPattern(ArrayPattern),
	Identifier(Identifier),
	ObjectPattern(ObjectPattern),
}
impl AstNode for AbstractClassDeclaration {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ABSTRACT_CLASS_DECLARATION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AbstractMethodSignature {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ABSTRACT_METHOD_SIGNATURE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AbstractToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ABSTRACT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AccessibilityModifier {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ACCESSIBILITY_MODIFIER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AmbientDeclaration {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == AMBIENT_DECLARATION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AmpAmpEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == AMP_AMP_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AmpAmpToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == AMP_AMP_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AmpEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == AMP_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AmpToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == AMP_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AnyToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ANY_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Arguments {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ARGUMENTS
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Array {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ARRAY
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ArrayPattern {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ARRAY_PATTERN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ArrayType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ARRAY_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ArrowFunction {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ARROW_FUNCTION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AsExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == AS_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AsToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == AS_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Asserts {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ASSERTS
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AssertsToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ASSERTS_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AssignmentExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ASSIGNMENT_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AssignmentPattern {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ASSIGNMENT_PATTERN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AsyncToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ASYNC_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AtToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == AT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AugmentedAssignmentExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == AUGMENTED_ASSIGNMENT_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AwaitExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == AWAIT_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for AwaitToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == AWAIT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for BangEqEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == BANG_EQ_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for BangEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == BANG_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for BangToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == BANG_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for BinaryExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == BINARY_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for BooleanToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == BOOLEAN_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for BquoteToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == BQUOTE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for BreakStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == BREAK_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for BreakToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == BREAK_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for CallExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CALL_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for CallSignature {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CALL_SIGNATURE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for CaretEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CARET_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for CaretToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CARET_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for CaseToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CASE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for CatchClause {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CATCH_CLAUSE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for CatchToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CATCH_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Class {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CLASS
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ClassBody {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CLASS_BODY
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ClassDeclaration {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CLASS_DECLARATION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ClassHeritage {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CLASS_HERITAGE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ClassToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CLASS_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ColonToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == COLON_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for CommaToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == COMMA_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Comment {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == COMMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ComputedPropertyName {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == COMPUTED_PROPERTY_NAME
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ConditionalType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CONDITIONAL_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ConstToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CONST_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Constraint {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CONSTRAINT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ConstructSignature {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CONSTRUCT_SIGNATURE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ConstructorType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CONSTRUCTOR_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ContinueStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CONTINUE_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ContinueToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == CONTINUE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DashDashToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DASH_DASH_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DashEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DASH_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DashQmarkColonToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DASH_QMARK_COLON_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DashToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DASH_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DebuggerStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DEBUGGER_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DebuggerToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DEBUGGER_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DeclareToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DECLARE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Decorator {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DECORATOR
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DefaultToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DEFAULT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DefaultType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DEFAULT_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DeleteToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DELETE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DoStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DO_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DoToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DO_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DollarLbraceToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DOLLAR_LBRACE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DotDotDotToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DOT_DOT_DOT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DotToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DOT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for DquoteToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == DQUOTE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ElseClause {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ELSE_CLAUSE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ElseToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ELSE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for EmptyStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == EMPTY_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for EnumAssignment {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ENUM_ASSIGNMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for EnumBody {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ENUM_BODY
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for EnumDeclaration {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ENUM_DECLARATION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for EnumToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ENUM_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for EqEqEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == EQ_EQ_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for EqEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == EQ_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for EqGtToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == EQ_GT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for EqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for EscapeSequence {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == ESCAPE_SEQUENCE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ExistentialType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == EXISTENTIAL_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ExportClause {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == EXPORT_CLAUSE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ExportSpecifier {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == EXPORT_SPECIFIER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ExportStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == EXPORT_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ExportToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == EXPORT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ExpressionStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == EXPRESSION_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ExtendsClause {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == EXTENDS_CLAUSE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ExtendsToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == EXTENDS_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for False {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == FALSE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for FinallyClause {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == FINALLY_CLAUSE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for FinallyToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == FINALLY_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for FlowMaybeType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == FLOW_MAYBE_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ForInStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == FOR_IN_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ForStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == FOR_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ForToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == FOR_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for FormalParameters {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == FORMAL_PARAMETERS
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for FromToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == FROM_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Function {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == FUNCTION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for FunctionDeclaration {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == FUNCTION_DECLARATION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for FunctionSignature {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == FUNCTION_SIGNATURE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for FunctionToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == FUNCTION_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for FunctionType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == FUNCTION_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for GeneratorFunction {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == GENERATOR_FUNCTION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for GeneratorFunctionDeclaration {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == GENERATOR_FUNCTION_DECLARATION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for GenericType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == GENERIC_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for GetToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == GET_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for GlobalToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == GLOBAL_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for GtEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == GT_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for GtGtEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == GT_GT_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for GtGtGtEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == GT_GT_GT_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for GtGtGtToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == GT_GT_GT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for GtGtToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == GT_GT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for GtToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == GT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for HashBangLine {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == HASH_BANG_LINE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Identifier {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == IDENTIFIER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for IfStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == IF_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for IfToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == IF_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ImplementsClause {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == IMPLEMENTS_CLAUSE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ImplementsToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == IMPLEMENTS_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Import {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == IMPORT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ImportAlias {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == IMPORT_ALIAS
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ImportClause {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == IMPORT_CLAUSE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ImportRequireClause {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == IMPORT_REQUIRE_CLAUSE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ImportSpecifier {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == IMPORT_SPECIFIER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ImportStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == IMPORT_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ImportToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == IMPORT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for InToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == IN_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for IndexSignature {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == INDEX_SIGNATURE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for IndexTypeQuery {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == INDEX_TYPE_QUERY
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for InferToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == INFER_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for InferType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == INFER_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for InstanceofToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == INSTANCEOF_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for InterfaceDeclaration {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == INTERFACE_DECLARATION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for InterfaceToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == INTERFACE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for InternalModule {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == INTERNAL_MODULE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for IntersectionType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == INTERSECTION_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for IsToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == IS_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for JsxAttribute {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == JSX_ATTRIBUTE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for JsxClosingElement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == JSX_CLOSING_ELEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for JsxElement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == JSX_ELEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for JsxExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == JSX_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for JsxFragment {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == JSX_FRAGMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for JsxNamespaceName {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == JSX_NAMESPACE_NAME
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for JsxOpeningElement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == JSX_OPENING_ELEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for JsxSelfClosingElement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == JSX_SELF_CLOSING_ELEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for JsxText {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == JSX_TEXT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for KeyofToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == KEYOF_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for LabeledStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == LABELED_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for LbracePipeToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == LBRACE_PIPE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for LbraceToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == LBRACE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for LbrackToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == LBRACK_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for LetToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == LET_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for LexicalDeclaration {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == LEXICAL_DECLARATION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for LiteralType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == LITERAL_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for LookupType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == LOOKUP_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for LparenToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == LPAREN_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for LtEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == LT_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for LtLtEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == LT_LT_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for LtLtToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == LT_LT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for LtToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == LT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for MappedTypeClause {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == MAPPED_TYPE_CLAUSE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for MemberExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == MEMBER_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for MetaProperty {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == META_PROPERTY
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for MethodDefinition {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == METHOD_DEFINITION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for MethodSignature {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == METHOD_SIGNATURE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Module {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == MODULE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ModuleToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == MODULE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for NamedImports {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == NAMED_IMPORTS
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for NamespaceImport {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == NAMESPACE_IMPORT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for NamespaceToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == NAMESPACE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for NestedIdentifier {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == NESTED_IDENTIFIER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for NestedTypeIdentifier {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == NESTED_TYPE_IDENTIFIER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for NewExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == NEW_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for NewToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == NEW_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for NonNullExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == NON_NULL_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Null {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == NULL
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Number {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == NUMBER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for NumberToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == NUMBER_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Object {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == OBJECT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ObjectAssignmentPattern {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == OBJECT_ASSIGNMENT_PATTERN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ObjectPattern {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == OBJECT_PATTERN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ObjectType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == OBJECT_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for OfToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == OF_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for OmittingTypeAnnotation {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == OMITTING_TYPE_ANNOTATION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for OptingTypeAnnotation {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == OPTING_TYPE_ANNOTATION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for OptionalParameter {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == OPTIONAL_PARAMETER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for OptionalType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == OPTIONAL_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Pair {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PAIR
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PairPattern {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PAIR_PATTERN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ParenthesizedExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PARENTHESIZED_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ParenthesizedType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PARENTHESIZED_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PercentEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PERCENT_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PercentToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PERCENT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PipeEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PIPE_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PipePipeEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PIPE_PIPE_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PipePipeToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PIPE_PIPE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PipeRbraceToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PIPE_RBRACE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PipeToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PIPE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PlusEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PLUS_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PlusPlusToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PLUS_PLUS_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PlusToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PLUS_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PredefinedType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PREDEFINED_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PrivateToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PRIVATE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Program {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PROGRAM
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PropertyIdentifier {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PROPERTY_IDENTIFIER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PropertySignature {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PROPERTY_SIGNATURE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ProtectedToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PROTECTED_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PublicFieldDefinition {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PUBLIC_FIELD_DEFINITION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for PublicToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == PUBLIC_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for QmarkColonToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == QMARK_COLON_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for QmarkDotToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == QMARK_DOT_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for QmarkQmarkEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == QMARK_QMARK_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for QmarkQmarkToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == QMARK_QMARK_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for QmarkToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == QMARK_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for RbraceToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == RBRACE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for RbrackToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == RBRACK_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ReadonlyToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == READONLY_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ReadonlyType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == READONLY_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Regex {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == REGEX
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for RegexFlags {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == REGEX_FLAGS
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for RegexPattern {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == REGEX_PATTERN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for RequireToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == REQUIRE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for RequiredParameter {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == REQUIRED_PARAMETER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for RestPattern {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == REST_PATTERN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for RestType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == REST_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ReturnStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == RETURN_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ReturnToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == RETURN_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for RparenToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == RPAREN_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for SemiToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SEMI_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for SequenceExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SEQUENCE_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for SetToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SET_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ShorthandPropertyIdentifier {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SHORTHAND_PROPERTY_IDENTIFIER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ShorthandPropertyIdentifierPattern {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SHORTHAND_PROPERTY_IDENTIFIER_PATTERN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for SlashEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SLASH_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for SlashToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SLASH_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for SpreadElement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SPREAD_ELEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for SquoteToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SQUOTE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for StarEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == STAR_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for StarStarEqToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == STAR_STAR_EQ_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for StarStarToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == STAR_STAR_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for StarToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == STAR_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for StatementBlock {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == STATEMENT_BLOCK
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for StatementIdentifier {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == STATEMENT_IDENTIFIER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for StaticToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == STATIC_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for StringLiteral {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == STRING_LITERAL
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for StringToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == STRING_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for SubscriptExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SUBSCRIPT_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Super {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SUPER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for SwitchBody {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SWITCH_BODY
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for SwitchCase {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SWITCH_CASE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for SwitchDefault {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SWITCH_DEFAULT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for SwitchStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SWITCH_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for SwitchToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SWITCH_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for SymbolToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == SYMBOL_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TargetToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TARGET_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TemplateString {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TEMPLATE_STRING
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TemplateSubstitution {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TEMPLATE_SUBSTITUTION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TernaryExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TERNARY_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for This {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == THIS
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ThrowStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == THROW_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for ThrowToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == THROW_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TildeToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TILDE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for True {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TRUE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TryStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TRY_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TryToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TRY_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TupleType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TUPLE_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TypeAliasDeclaration {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TYPE_ALIAS_DECLARATION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TypeAnnotation {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TYPE_ANNOTATION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TypeArguments {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TYPE_ARGUMENTS
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TypeAssertion {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TYPE_ASSERTION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TypeIdentifier {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TYPE_IDENTIFIER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TypeParameter {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TYPE_PARAMETER
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TypeParameters {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TYPE_PARAMETERS
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TypePredicate {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TYPE_PREDICATE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TypePredicateAnnotation {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TYPE_PREDICATE_ANNOTATION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TypeQuery {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TYPE_QUERY
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TypeToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TYPE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for TypeofToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == TYPEOF_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for UnaryExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == UNARY_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for Undefined {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == UNDEFINED
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for UnionType {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == UNION_TYPE
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for UpdateExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == UPDATE_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for VarToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == VAR_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for VariableDeclaration {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == VARIABLE_DECLARATION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for VariableDeclarator {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == VARIABLE_DECLARATOR
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for VoidToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == VOID_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for WhileStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == WHILE_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for WhileToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == WHILE_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for WithStatement {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == WITH_STATEMENT
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for WithToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == WITH_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for YieldExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == YIELD_EXPRESSION
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl AstNode for YieldToken {
	fn can_cast(kind: SyntaxKind) -> bool {
		kind == YIELD_TOKEN
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		if Self::can_cast(syntax.kind()) {
			Some(Self { syntax })
		} else {
			None
		}
	}
	fn syntax(&self) -> &SyntaxNode {
		&self.syntax
	}
}
impl From<ComputedPropertyName> for AbstractMethodSignatureName {
	fn from(node: ComputedPropertyName) -> AbstractMethodSignatureName {
		AbstractMethodSignatureName::ComputedPropertyName(node)
	}
}
impl From<Number> for AbstractMethodSignatureName {
	fn from(node: Number) -> AbstractMethodSignatureName {
		AbstractMethodSignatureName::Number(node)
	}
}
impl From<PropertyIdentifier> for AbstractMethodSignatureName {
	fn from(node: PropertyIdentifier) -> AbstractMethodSignatureName {
		AbstractMethodSignatureName::PropertyIdentifier(node)
	}
}
impl From<StringLiteral> for AbstractMethodSignatureName {
	fn from(node: StringLiteral) -> AbstractMethodSignatureName {
		AbstractMethodSignatureName::StringLiteral(node)
	}
}
impl AstNode for AbstractMethodSignatureName {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::COMPUTED_PROPERTY_NAME
			| SyntaxKind::NUMBER
			| SyntaxKind::PROPERTY_IDENTIFIER
			| SyntaxKind::STRING_LITERAL => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::COMPUTED_PROPERTY_NAME => {
				AbstractMethodSignatureName::ComputedPropertyName(ComputedPropertyName { syntax })
			}
			SyntaxKind::NUMBER => AbstractMethodSignatureName::Number(Number { syntax }),
			SyntaxKind::PROPERTY_IDENTIFIER => {
				AbstractMethodSignatureName::PropertyIdentifier(PropertyIdentifier { syntax })
			}
			SyntaxKind::STRING_LITERAL => {
				AbstractMethodSignatureName::StringLiteral(StringLiteral { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			AbstractMethodSignatureName::ComputedPropertyName(it) => &it.syntax,
			AbstractMethodSignatureName::Number(it) => &it.syntax,
			AbstractMethodSignatureName::PropertyIdentifier(it) => &it.syntax,
			AbstractMethodSignatureName::StringLiteral(it) => &it.syntax,
		}
	}
}
impl From<Asserts> for AbstractMethodSignatureReturnType {
	fn from(node: Asserts) -> AbstractMethodSignatureReturnType {
		AbstractMethodSignatureReturnType::Asserts(node)
	}
}
impl From<TypeAnnotation> for AbstractMethodSignatureReturnType {
	fn from(node: TypeAnnotation) -> AbstractMethodSignatureReturnType {
		AbstractMethodSignatureReturnType::TypeAnnotation(node)
	}
}
impl From<TypePredicateAnnotation> for AbstractMethodSignatureReturnType {
	fn from(node: TypePredicateAnnotation) -> AbstractMethodSignatureReturnType {
		AbstractMethodSignatureReturnType::TypePredicateAnnotation(node)
	}
}
impl AstNode for AbstractMethodSignatureReturnType {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ASSERTS
			| SyntaxKind::TYPE_ANNOTATION
			| SyntaxKind::TYPE_PREDICATE_ANNOTATION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ASSERTS => AbstractMethodSignatureReturnType::Asserts(Asserts { syntax }),
			SyntaxKind::TYPE_ANNOTATION => {
				AbstractMethodSignatureReturnType::TypeAnnotation(TypeAnnotation { syntax })
			}
			SyntaxKind::TYPE_PREDICATE_ANNOTATION => {
				AbstractMethodSignatureReturnType::TypePredicateAnnotation(
					TypePredicateAnnotation { syntax },
				)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			AbstractMethodSignatureReturnType::Asserts(it) => &it.syntax,
			AbstractMethodSignatureReturnType::TypeAnnotation(it) => &it.syntax,
			AbstractMethodSignatureReturnType::TypePredicateAnnotation(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for AmbientDeclarationInnerChildren {
	fn from(node: ConstructorType) -> AmbientDeclarationInnerChildren {
		AmbientDeclarationInnerChildren::ConstructorType(node)
	}
}
impl From<Declaration> for AmbientDeclarationInnerChildren {
	fn from(node: Declaration) -> AmbientDeclarationInnerChildren {
		AmbientDeclarationInnerChildren::Declaration(node)
	}
}
impl From<FunctionType> for AmbientDeclarationInnerChildren {
	fn from(node: FunctionType) -> AmbientDeclarationInnerChildren {
		AmbientDeclarationInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for AmbientDeclarationInnerChildren {
	fn from(node: InferType) -> AmbientDeclarationInnerChildren {
		AmbientDeclarationInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for AmbientDeclarationInnerChildren {
	fn from(node: IntersectionType) -> AmbientDeclarationInnerChildren {
		AmbientDeclarationInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for AmbientDeclarationInnerChildren {
	fn from(node: PrimaryType) -> AmbientDeclarationInnerChildren {
		AmbientDeclarationInnerChildren::PrimaryType(node)
	}
}
impl From<PropertyIdentifier> for AmbientDeclarationInnerChildren {
	fn from(node: PropertyIdentifier) -> AmbientDeclarationInnerChildren {
		AmbientDeclarationInnerChildren::PropertyIdentifier(node)
	}
}
impl From<ReadonlyType> for AmbientDeclarationInnerChildren {
	fn from(node: ReadonlyType) -> AmbientDeclarationInnerChildren {
		AmbientDeclarationInnerChildren::ReadonlyType(node)
	}
}
impl From<StatementBlock> for AmbientDeclarationInnerChildren {
	fn from(node: StatementBlock) -> AmbientDeclarationInnerChildren {
		AmbientDeclarationInnerChildren::StatementBlock(node)
	}
}
impl From<UnionType> for AmbientDeclarationInnerChildren {
	fn from(node: UnionType) -> AmbientDeclarationInnerChildren {
		AmbientDeclarationInnerChildren::UnionType(node)
	}
}
impl AstNode for AmbientDeclarationInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::PROPERTY_IDENTIFIER
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::STATEMENT_BLOCK
			| SyntaxKind::UNION_TYPE => true,
			_ => Declaration::can_cast(kind) | PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				AmbientDeclarationInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				AmbientDeclarationInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => {
				AmbientDeclarationInnerChildren::InferType(InferType { syntax })
			}
			SyntaxKind::INTERSECTION_TYPE => {
				AmbientDeclarationInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::PROPERTY_IDENTIFIER => {
				AmbientDeclarationInnerChildren::PropertyIdentifier(PropertyIdentifier { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				AmbientDeclarationInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::STATEMENT_BLOCK => {
				AmbientDeclarationInnerChildren::StatementBlock(StatementBlock { syntax })
			}
			SyntaxKind::UNION_TYPE => {
				AmbientDeclarationInnerChildren::UnionType(UnionType { syntax })
			}
			kind if Declaration::can_cast(kind) => {
				AmbientDeclarationInnerChildren::Declaration(Declaration::cast(syntax)?)
			}
			kind if PrimaryType::can_cast(kind) => {
				AmbientDeclarationInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			AmbientDeclarationInnerChildren::ConstructorType(it) => &it.syntax,
			AmbientDeclarationInnerChildren::FunctionType(it) => &it.syntax,
			AmbientDeclarationInnerChildren::InferType(it) => &it.syntax,
			AmbientDeclarationInnerChildren::IntersectionType(it) => &it.syntax,
			AmbientDeclarationInnerChildren::PropertyIdentifier(it) => &it.syntax,
			AmbientDeclarationInnerChildren::ReadonlyType(it) => &it.syntax,
			AmbientDeclarationInnerChildren::StatementBlock(it) => &it.syntax,
			AmbientDeclarationInnerChildren::UnionType(it) => &it.syntax,
			AmbientDeclarationInnerChildren::Declaration(it) => &it.syntax(),
			AmbientDeclarationInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<Expression> for ArgumentsInnerChildren {
	fn from(node: Expression) -> ArgumentsInnerChildren {
		ArgumentsInnerChildren::Expression(node)
	}
}
impl From<SpreadElement> for ArgumentsInnerChildren {
	fn from(node: SpreadElement) -> ArgumentsInnerChildren {
		ArgumentsInnerChildren::SpreadElement(node)
	}
}
impl AstNode for ArgumentsInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::SPREAD_ELEMENT => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::SPREAD_ELEMENT => {
				ArgumentsInnerChildren::SpreadElement(SpreadElement { syntax })
			}
			kind if Expression::can_cast(kind) => {
				ArgumentsInnerChildren::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ArgumentsInnerChildren::SpreadElement(it) => &it.syntax,
			ArgumentsInnerChildren::Expression(it) => &it.syntax(),
		}
	}
}
impl From<Expression> for ArrayInnerChildren {
	fn from(node: Expression) -> ArrayInnerChildren {
		ArrayInnerChildren::Expression(node)
	}
}
impl From<SpreadElement> for ArrayInnerChildren {
	fn from(node: SpreadElement) -> ArrayInnerChildren {
		ArrayInnerChildren::SpreadElement(node)
	}
}
impl AstNode for ArrayInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::SPREAD_ELEMENT => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::SPREAD_ELEMENT => {
				ArrayInnerChildren::SpreadElement(SpreadElement { syntax })
			}
			kind if Expression::can_cast(kind) => {
				ArrayInnerChildren::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ArrayInnerChildren::SpreadElement(it) => &it.syntax,
			ArrayInnerChildren::Expression(it) => &it.syntax(),
		}
	}
}
impl From<AssignmentPattern> for ArrayPatternInnerChildren {
	fn from(node: AssignmentPattern) -> ArrayPatternInnerChildren {
		ArrayPatternInnerChildren::AssignmentPattern(node)
	}
}
impl From<Pattern> for ArrayPatternInnerChildren {
	fn from(node: Pattern) -> ArrayPatternInnerChildren {
		ArrayPatternInnerChildren::Pattern(node)
	}
}
impl AstNode for ArrayPatternInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ASSIGNMENT_PATTERN => true,
			_ => Pattern::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ASSIGNMENT_PATTERN => {
				ArrayPatternInnerChildren::AssignmentPattern(AssignmentPattern { syntax })
			}
			kind if Pattern::can_cast(kind) => {
				ArrayPatternInnerChildren::Pattern(Pattern::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ArrayPatternInnerChildren::AssignmentPattern(it) => &it.syntax,
			ArrayPatternInnerChildren::Pattern(it) => &it.syntax(),
		}
	}
}
impl From<Expression> for ArrowFunctionBody {
	fn from(node: Expression) -> ArrowFunctionBody {
		ArrowFunctionBody::Expression(node)
	}
}
impl From<StatementBlock> for ArrowFunctionBody {
	fn from(node: StatementBlock) -> ArrowFunctionBody {
		ArrowFunctionBody::StatementBlock(node)
	}
}
impl AstNode for ArrowFunctionBody {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::STATEMENT_BLOCK => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::STATEMENT_BLOCK => {
				ArrowFunctionBody::StatementBlock(StatementBlock { syntax })
			}
			kind if Expression::can_cast(kind) => {
				ArrowFunctionBody::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ArrowFunctionBody::StatementBlock(it) => &it.syntax,
			ArrowFunctionBody::Expression(it) => &it.syntax(),
		}
	}
}
impl From<Asserts> for ArrowFunctionReturnType {
	fn from(node: Asserts) -> ArrowFunctionReturnType {
		ArrowFunctionReturnType::Asserts(node)
	}
}
impl From<TypeAnnotation> for ArrowFunctionReturnType {
	fn from(node: TypeAnnotation) -> ArrowFunctionReturnType {
		ArrowFunctionReturnType::TypeAnnotation(node)
	}
}
impl From<TypePredicateAnnotation> for ArrowFunctionReturnType {
	fn from(node: TypePredicateAnnotation) -> ArrowFunctionReturnType {
		ArrowFunctionReturnType::TypePredicateAnnotation(node)
	}
}
impl AstNode for ArrowFunctionReturnType {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ASSERTS
			| SyntaxKind::TYPE_ANNOTATION
			| SyntaxKind::TYPE_PREDICATE_ANNOTATION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ASSERTS => ArrowFunctionReturnType::Asserts(Asserts { syntax }),
			SyntaxKind::TYPE_ANNOTATION => {
				ArrowFunctionReturnType::TypeAnnotation(TypeAnnotation { syntax })
			}
			SyntaxKind::TYPE_PREDICATE_ANNOTATION => {
				ArrowFunctionReturnType::TypePredicateAnnotation(TypePredicateAnnotation { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ArrowFunctionReturnType::Asserts(it) => &it.syntax,
			ArrowFunctionReturnType::TypeAnnotation(it) => &it.syntax,
			ArrowFunctionReturnType::TypePredicateAnnotation(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for AsExpressionInnerChildren {
	fn from(node: ConstructorType) -> AsExpressionInnerChildren {
		AsExpressionInnerChildren::ConstructorType(node)
	}
}
impl From<Expression> for AsExpressionInnerChildren {
	fn from(node: Expression) -> AsExpressionInnerChildren {
		AsExpressionInnerChildren::Expression(node)
	}
}
impl From<FunctionType> for AsExpressionInnerChildren {
	fn from(node: FunctionType) -> AsExpressionInnerChildren {
		AsExpressionInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for AsExpressionInnerChildren {
	fn from(node: InferType) -> AsExpressionInnerChildren {
		AsExpressionInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for AsExpressionInnerChildren {
	fn from(node: IntersectionType) -> AsExpressionInnerChildren {
		AsExpressionInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for AsExpressionInnerChildren {
	fn from(node: PrimaryType) -> AsExpressionInnerChildren {
		AsExpressionInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for AsExpressionInnerChildren {
	fn from(node: ReadonlyType) -> AsExpressionInnerChildren {
		AsExpressionInnerChildren::ReadonlyType(node)
	}
}
impl From<TemplateString> for AsExpressionInnerChildren {
	fn from(node: TemplateString) -> AsExpressionInnerChildren {
		AsExpressionInnerChildren::TemplateString(node)
	}
}
impl From<UnionType> for AsExpressionInnerChildren {
	fn from(node: UnionType) -> AsExpressionInnerChildren {
		AsExpressionInnerChildren::UnionType(node)
	}
}
impl AstNode for AsExpressionInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::TEMPLATE_STRING
			| SyntaxKind::UNION_TYPE => true,
			_ => Expression::can_cast(kind) | PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				AsExpressionInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				AsExpressionInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => AsExpressionInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				AsExpressionInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				AsExpressionInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::TEMPLATE_STRING => {
				AsExpressionInnerChildren::TemplateString(TemplateString { syntax })
			}
			SyntaxKind::UNION_TYPE => AsExpressionInnerChildren::UnionType(UnionType { syntax }),
			kind if Expression::can_cast(kind) => {
				AsExpressionInnerChildren::Expression(Expression::cast(syntax)?)
			}
			kind if PrimaryType::can_cast(kind) => {
				AsExpressionInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			AsExpressionInnerChildren::ConstructorType(it) => &it.syntax,
			AsExpressionInnerChildren::FunctionType(it) => &it.syntax,
			AsExpressionInnerChildren::InferType(it) => &it.syntax,
			AsExpressionInnerChildren::IntersectionType(it) => &it.syntax,
			AsExpressionInnerChildren::ReadonlyType(it) => &it.syntax,
			AsExpressionInnerChildren::TemplateString(it) => &it.syntax,
			AsExpressionInnerChildren::UnionType(it) => &it.syntax,
			AsExpressionInnerChildren::Expression(it) => &it.syntax(),
			AsExpressionInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<Identifier> for AssertsInnerChildren {
	fn from(node: Identifier) -> AssertsInnerChildren {
		AssertsInnerChildren::Identifier(node)
	}
}
impl From<This> for AssertsInnerChildren {
	fn from(node: This) -> AssertsInnerChildren {
		AssertsInnerChildren::This(node)
	}
}
impl From<TypePredicate> for AssertsInnerChildren {
	fn from(node: TypePredicate) -> AssertsInnerChildren {
		AssertsInnerChildren::TypePredicate(node)
	}
}
impl AstNode for AssertsInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::IDENTIFIER | SyntaxKind::THIS | SyntaxKind::TYPE_PREDICATE => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::IDENTIFIER => AssertsInnerChildren::Identifier(Identifier { syntax }),
			SyntaxKind::THIS => AssertsInnerChildren::This(This { syntax }),
			SyntaxKind::TYPE_PREDICATE => {
				AssertsInnerChildren::TypePredicate(TypePredicate { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			AssertsInnerChildren::Identifier(it) => &it.syntax,
			AssertsInnerChildren::This(it) => &it.syntax,
			AssertsInnerChildren::TypePredicate(it) => &it.syntax,
		}
	}
}
impl From<ArrayPattern> for AssignmentExpressionLeft {
	fn from(node: ArrayPattern) -> AssignmentExpressionLeft {
		AssignmentExpressionLeft::ArrayPattern(node)
	}
}
impl From<Identifier> for AssignmentExpressionLeft {
	fn from(node: Identifier) -> AssignmentExpressionLeft {
		AssignmentExpressionLeft::Identifier(node)
	}
}
impl From<MemberExpression> for AssignmentExpressionLeft {
	fn from(node: MemberExpression) -> AssignmentExpressionLeft {
		AssignmentExpressionLeft::MemberExpression(node)
	}
}
impl From<NonNullExpression> for AssignmentExpressionLeft {
	fn from(node: NonNullExpression) -> AssignmentExpressionLeft {
		AssignmentExpressionLeft::NonNullExpression(node)
	}
}
impl From<ObjectPattern> for AssignmentExpressionLeft {
	fn from(node: ObjectPattern) -> AssignmentExpressionLeft {
		AssignmentExpressionLeft::ObjectPattern(node)
	}
}
impl From<ParenthesizedExpression> for AssignmentExpressionLeft {
	fn from(node: ParenthesizedExpression) -> AssignmentExpressionLeft {
		AssignmentExpressionLeft::ParenthesizedExpression(node)
	}
}
impl From<SubscriptExpression> for AssignmentExpressionLeft {
	fn from(node: SubscriptExpression) -> AssignmentExpressionLeft {
		AssignmentExpressionLeft::SubscriptExpression(node)
	}
}
impl AstNode for AssignmentExpressionLeft {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ARRAY_PATTERN
			| SyntaxKind::IDENTIFIER
			| SyntaxKind::MEMBER_EXPRESSION
			| SyntaxKind::NON_NULL_EXPRESSION
			| SyntaxKind::OBJECT_PATTERN
			| SyntaxKind::PARENTHESIZED_EXPRESSION
			| SyntaxKind::SUBSCRIPT_EXPRESSION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ARRAY_PATTERN => {
				AssignmentExpressionLeft::ArrayPattern(ArrayPattern { syntax })
			}
			SyntaxKind::IDENTIFIER => AssignmentExpressionLeft::Identifier(Identifier { syntax }),
			SyntaxKind::MEMBER_EXPRESSION => {
				AssignmentExpressionLeft::MemberExpression(MemberExpression { syntax })
			}
			SyntaxKind::NON_NULL_EXPRESSION => {
				AssignmentExpressionLeft::NonNullExpression(NonNullExpression { syntax })
			}
			SyntaxKind::OBJECT_PATTERN => {
				AssignmentExpressionLeft::ObjectPattern(ObjectPattern { syntax })
			}
			SyntaxKind::PARENTHESIZED_EXPRESSION => {
				AssignmentExpressionLeft::ParenthesizedExpression(ParenthesizedExpression {
					syntax,
				})
			}
			SyntaxKind::SUBSCRIPT_EXPRESSION => {
				AssignmentExpressionLeft::SubscriptExpression(SubscriptExpression { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			AssignmentExpressionLeft::ArrayPattern(it) => &it.syntax,
			AssignmentExpressionLeft::Identifier(it) => &it.syntax,
			AssignmentExpressionLeft::MemberExpression(it) => &it.syntax,
			AssignmentExpressionLeft::NonNullExpression(it) => &it.syntax,
			AssignmentExpressionLeft::ObjectPattern(it) => &it.syntax,
			AssignmentExpressionLeft::ParenthesizedExpression(it) => &it.syntax,
			AssignmentExpressionLeft::SubscriptExpression(it) => &it.syntax,
		}
	}
}
impl From<Identifier> for AugmentedAssignmentExpressionLeft {
	fn from(node: Identifier) -> AugmentedAssignmentExpressionLeft {
		AugmentedAssignmentExpressionLeft::Identifier(node)
	}
}
impl From<MemberExpression> for AugmentedAssignmentExpressionLeft {
	fn from(node: MemberExpression) -> AugmentedAssignmentExpressionLeft {
		AugmentedAssignmentExpressionLeft::MemberExpression(node)
	}
}
impl From<NonNullExpression> for AugmentedAssignmentExpressionLeft {
	fn from(node: NonNullExpression) -> AugmentedAssignmentExpressionLeft {
		AugmentedAssignmentExpressionLeft::NonNullExpression(node)
	}
}
impl From<ParenthesizedExpression> for AugmentedAssignmentExpressionLeft {
	fn from(node: ParenthesizedExpression) -> AugmentedAssignmentExpressionLeft {
		AugmentedAssignmentExpressionLeft::ParenthesizedExpression(node)
	}
}
impl From<SubscriptExpression> for AugmentedAssignmentExpressionLeft {
	fn from(node: SubscriptExpression) -> AugmentedAssignmentExpressionLeft {
		AugmentedAssignmentExpressionLeft::SubscriptExpression(node)
	}
}
impl AstNode for AugmentedAssignmentExpressionLeft {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::IDENTIFIER
			| SyntaxKind::MEMBER_EXPRESSION
			| SyntaxKind::NON_NULL_EXPRESSION
			| SyntaxKind::PARENTHESIZED_EXPRESSION
			| SyntaxKind::SUBSCRIPT_EXPRESSION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::IDENTIFIER => {
				AugmentedAssignmentExpressionLeft::Identifier(Identifier { syntax })
			}
			SyntaxKind::MEMBER_EXPRESSION => {
				AugmentedAssignmentExpressionLeft::MemberExpression(MemberExpression { syntax })
			}
			SyntaxKind::NON_NULL_EXPRESSION => {
				AugmentedAssignmentExpressionLeft::NonNullExpression(NonNullExpression { syntax })
			}
			SyntaxKind::PARENTHESIZED_EXPRESSION => {
				AugmentedAssignmentExpressionLeft::ParenthesizedExpression(
					ParenthesizedExpression { syntax },
				)
			}
			SyntaxKind::SUBSCRIPT_EXPRESSION => {
				AugmentedAssignmentExpressionLeft::SubscriptExpression(SubscriptExpression {
					syntax,
				})
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			AugmentedAssignmentExpressionLeft::Identifier(it) => &it.syntax,
			AugmentedAssignmentExpressionLeft::MemberExpression(it) => &it.syntax,
			AugmentedAssignmentExpressionLeft::NonNullExpression(it) => &it.syntax,
			AugmentedAssignmentExpressionLeft::ParenthesizedExpression(it) => &it.syntax,
			AugmentedAssignmentExpressionLeft::SubscriptExpression(it) => &it.syntax,
		}
	}
}
impl From<AmpAmpToken> for BinaryExpressionOperator {
	fn from(node: AmpAmpToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::AmpAmpToken(node)
	}
}
impl From<AmpToken> for BinaryExpressionOperator {
	fn from(node: AmpToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::AmpToken(node)
	}
}
impl From<BangEqEqToken> for BinaryExpressionOperator {
	fn from(node: BangEqEqToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::BangEqEqToken(node)
	}
}
impl From<BangEqToken> for BinaryExpressionOperator {
	fn from(node: BangEqToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::BangEqToken(node)
	}
}
impl From<CaretToken> for BinaryExpressionOperator {
	fn from(node: CaretToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::CaretToken(node)
	}
}
impl From<DashToken> for BinaryExpressionOperator {
	fn from(node: DashToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::DashToken(node)
	}
}
impl From<EqEqEqToken> for BinaryExpressionOperator {
	fn from(node: EqEqEqToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::EqEqEqToken(node)
	}
}
impl From<EqEqToken> for BinaryExpressionOperator {
	fn from(node: EqEqToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::EqEqToken(node)
	}
}
impl From<GtEqToken> for BinaryExpressionOperator {
	fn from(node: GtEqToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::GtEqToken(node)
	}
}
impl From<GtGtGtToken> for BinaryExpressionOperator {
	fn from(node: GtGtGtToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::GtGtGtToken(node)
	}
}
impl From<GtGtToken> for BinaryExpressionOperator {
	fn from(node: GtGtToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::GtGtToken(node)
	}
}
impl From<GtToken> for BinaryExpressionOperator {
	fn from(node: GtToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::GtToken(node)
	}
}
impl From<InToken> for BinaryExpressionOperator {
	fn from(node: InToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::InToken(node)
	}
}
impl From<InstanceofToken> for BinaryExpressionOperator {
	fn from(node: InstanceofToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::InstanceofToken(node)
	}
}
impl From<LtEqToken> for BinaryExpressionOperator {
	fn from(node: LtEqToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::LtEqToken(node)
	}
}
impl From<LtLtToken> for BinaryExpressionOperator {
	fn from(node: LtLtToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::LtLtToken(node)
	}
}
impl From<LtToken> for BinaryExpressionOperator {
	fn from(node: LtToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::LtToken(node)
	}
}
impl From<PercentToken> for BinaryExpressionOperator {
	fn from(node: PercentToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::PercentToken(node)
	}
}
impl From<PipePipeToken> for BinaryExpressionOperator {
	fn from(node: PipePipeToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::PipePipeToken(node)
	}
}
impl From<PipeToken> for BinaryExpressionOperator {
	fn from(node: PipeToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::PipeToken(node)
	}
}
impl From<PlusToken> for BinaryExpressionOperator {
	fn from(node: PlusToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::PlusToken(node)
	}
}
impl From<QmarkQmarkToken> for BinaryExpressionOperator {
	fn from(node: QmarkQmarkToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::QmarkQmarkToken(node)
	}
}
impl From<SlashToken> for BinaryExpressionOperator {
	fn from(node: SlashToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::SlashToken(node)
	}
}
impl From<StarStarToken> for BinaryExpressionOperator {
	fn from(node: StarStarToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::StarStarToken(node)
	}
}
impl From<StarToken> for BinaryExpressionOperator {
	fn from(node: StarToken) -> BinaryExpressionOperator {
		BinaryExpressionOperator::StarToken(node)
	}
}
impl AstNode for BinaryExpressionOperator {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::AMP_AMP_TOKEN
			| SyntaxKind::AMP_TOKEN
			| SyntaxKind::BANG_EQ_EQ_TOKEN
			| SyntaxKind::BANG_EQ_TOKEN
			| SyntaxKind::CARET_TOKEN
			| SyntaxKind::DASH_TOKEN
			| SyntaxKind::EQ_EQ_EQ_TOKEN
			| SyntaxKind::EQ_EQ_TOKEN
			| SyntaxKind::GT_EQ_TOKEN
			| SyntaxKind::GT_GT_GT_TOKEN
			| SyntaxKind::GT_GT_TOKEN
			| SyntaxKind::GT_TOKEN
			| SyntaxKind::IN_TOKEN
			| SyntaxKind::INSTANCEOF_TOKEN
			| SyntaxKind::LT_EQ_TOKEN
			| SyntaxKind::LT_LT_TOKEN
			| SyntaxKind::LT_TOKEN
			| SyntaxKind::PERCENT_TOKEN
			| SyntaxKind::PIPE_PIPE_TOKEN
			| SyntaxKind::PIPE_TOKEN
			| SyntaxKind::PLUS_TOKEN
			| SyntaxKind::QMARK_QMARK_TOKEN
			| SyntaxKind::SLASH_TOKEN
			| SyntaxKind::STAR_STAR_TOKEN
			| SyntaxKind::STAR_TOKEN => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::AMP_AMP_TOKEN => {
				BinaryExpressionOperator::AmpAmpToken(AmpAmpToken { syntax })
			}
			SyntaxKind::AMP_TOKEN => BinaryExpressionOperator::AmpToken(AmpToken { syntax }),
			SyntaxKind::BANG_EQ_EQ_TOKEN => {
				BinaryExpressionOperator::BangEqEqToken(BangEqEqToken { syntax })
			}
			SyntaxKind::BANG_EQ_TOKEN => {
				BinaryExpressionOperator::BangEqToken(BangEqToken { syntax })
			}
			SyntaxKind::CARET_TOKEN => BinaryExpressionOperator::CaretToken(CaretToken { syntax }),
			SyntaxKind::DASH_TOKEN => BinaryExpressionOperator::DashToken(DashToken { syntax }),
			SyntaxKind::EQ_EQ_EQ_TOKEN => {
				BinaryExpressionOperator::EqEqEqToken(EqEqEqToken { syntax })
			}
			SyntaxKind::EQ_EQ_TOKEN => BinaryExpressionOperator::EqEqToken(EqEqToken { syntax }),
			SyntaxKind::GT_EQ_TOKEN => BinaryExpressionOperator::GtEqToken(GtEqToken { syntax }),
			SyntaxKind::GT_GT_GT_TOKEN => {
				BinaryExpressionOperator::GtGtGtToken(GtGtGtToken { syntax })
			}
			SyntaxKind::GT_GT_TOKEN => BinaryExpressionOperator::GtGtToken(GtGtToken { syntax }),
			SyntaxKind::GT_TOKEN => BinaryExpressionOperator::GtToken(GtToken { syntax }),
			SyntaxKind::IN_TOKEN => BinaryExpressionOperator::InToken(InToken { syntax }),
			SyntaxKind::INSTANCEOF_TOKEN => {
				BinaryExpressionOperator::InstanceofToken(InstanceofToken { syntax })
			}
			SyntaxKind::LT_EQ_TOKEN => BinaryExpressionOperator::LtEqToken(LtEqToken { syntax }),
			SyntaxKind::LT_LT_TOKEN => BinaryExpressionOperator::LtLtToken(LtLtToken { syntax }),
			SyntaxKind::LT_TOKEN => BinaryExpressionOperator::LtToken(LtToken { syntax }),
			SyntaxKind::PERCENT_TOKEN => {
				BinaryExpressionOperator::PercentToken(PercentToken { syntax })
			}
			SyntaxKind::PIPE_PIPE_TOKEN => {
				BinaryExpressionOperator::PipePipeToken(PipePipeToken { syntax })
			}
			SyntaxKind::PIPE_TOKEN => BinaryExpressionOperator::PipeToken(PipeToken { syntax }),
			SyntaxKind::PLUS_TOKEN => BinaryExpressionOperator::PlusToken(PlusToken { syntax }),
			SyntaxKind::QMARK_QMARK_TOKEN => {
				BinaryExpressionOperator::QmarkQmarkToken(QmarkQmarkToken { syntax })
			}
			SyntaxKind::SLASH_TOKEN => BinaryExpressionOperator::SlashToken(SlashToken { syntax }),
			SyntaxKind::STAR_STAR_TOKEN => {
				BinaryExpressionOperator::StarStarToken(StarStarToken { syntax })
			}
			SyntaxKind::STAR_TOKEN => BinaryExpressionOperator::StarToken(StarToken { syntax }),
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			BinaryExpressionOperator::AmpAmpToken(it) => &it.syntax,
			BinaryExpressionOperator::AmpToken(it) => &it.syntax,
			BinaryExpressionOperator::BangEqEqToken(it) => &it.syntax,
			BinaryExpressionOperator::BangEqToken(it) => &it.syntax,
			BinaryExpressionOperator::CaretToken(it) => &it.syntax,
			BinaryExpressionOperator::DashToken(it) => &it.syntax,
			BinaryExpressionOperator::EqEqEqToken(it) => &it.syntax,
			BinaryExpressionOperator::EqEqToken(it) => &it.syntax,
			BinaryExpressionOperator::GtEqToken(it) => &it.syntax,
			BinaryExpressionOperator::GtGtGtToken(it) => &it.syntax,
			BinaryExpressionOperator::GtGtToken(it) => &it.syntax,
			BinaryExpressionOperator::GtToken(it) => &it.syntax,
			BinaryExpressionOperator::InToken(it) => &it.syntax,
			BinaryExpressionOperator::InstanceofToken(it) => &it.syntax,
			BinaryExpressionOperator::LtEqToken(it) => &it.syntax,
			BinaryExpressionOperator::LtLtToken(it) => &it.syntax,
			BinaryExpressionOperator::LtToken(it) => &it.syntax,
			BinaryExpressionOperator::PercentToken(it) => &it.syntax,
			BinaryExpressionOperator::PipePipeToken(it) => &it.syntax,
			BinaryExpressionOperator::PipeToken(it) => &it.syntax,
			BinaryExpressionOperator::PlusToken(it) => &it.syntax,
			BinaryExpressionOperator::QmarkQmarkToken(it) => &it.syntax,
			BinaryExpressionOperator::SlashToken(it) => &it.syntax,
			BinaryExpressionOperator::StarStarToken(it) => &it.syntax,
			BinaryExpressionOperator::StarToken(it) => &it.syntax,
		}
	}
}
impl From<Arguments> for CallExpressionArguments {
	fn from(node: Arguments) -> CallExpressionArguments {
		CallExpressionArguments::Arguments(node)
	}
}
impl From<TemplateString> for CallExpressionArguments {
	fn from(node: TemplateString) -> CallExpressionArguments {
		CallExpressionArguments::TemplateString(node)
	}
}
impl AstNode for CallExpressionArguments {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ARGUMENTS | SyntaxKind::TEMPLATE_STRING => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ARGUMENTS => CallExpressionArguments::Arguments(Arguments { syntax }),
			SyntaxKind::TEMPLATE_STRING => {
				CallExpressionArguments::TemplateString(TemplateString { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			CallExpressionArguments::Arguments(it) => &it.syntax,
			CallExpressionArguments::TemplateString(it) => &it.syntax,
		}
	}
}
impl From<Asserts> for CallSignatureReturnType {
	fn from(node: Asserts) -> CallSignatureReturnType {
		CallSignatureReturnType::Asserts(node)
	}
}
impl From<TypeAnnotation> for CallSignatureReturnType {
	fn from(node: TypeAnnotation) -> CallSignatureReturnType {
		CallSignatureReturnType::TypeAnnotation(node)
	}
}
impl From<TypePredicateAnnotation> for CallSignatureReturnType {
	fn from(node: TypePredicateAnnotation) -> CallSignatureReturnType {
		CallSignatureReturnType::TypePredicateAnnotation(node)
	}
}
impl AstNode for CallSignatureReturnType {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ASSERTS
			| SyntaxKind::TYPE_ANNOTATION
			| SyntaxKind::TYPE_PREDICATE_ANNOTATION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ASSERTS => CallSignatureReturnType::Asserts(Asserts { syntax }),
			SyntaxKind::TYPE_ANNOTATION => {
				CallSignatureReturnType::TypeAnnotation(TypeAnnotation { syntax })
			}
			SyntaxKind::TYPE_PREDICATE_ANNOTATION => {
				CallSignatureReturnType::TypePredicateAnnotation(TypePredicateAnnotation { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			CallSignatureReturnType::Asserts(it) => &it.syntax,
			CallSignatureReturnType::TypeAnnotation(it) => &it.syntax,
			CallSignatureReturnType::TypePredicateAnnotation(it) => &it.syntax,
		}
	}
}
impl From<ArrayPattern> for CatchClauseParameter {
	fn from(node: ArrayPattern) -> CatchClauseParameter {
		CatchClauseParameter::ArrayPattern(node)
	}
}
impl From<Identifier> for CatchClauseParameter {
	fn from(node: Identifier) -> CatchClauseParameter {
		CatchClauseParameter::Identifier(node)
	}
}
impl From<ObjectPattern> for CatchClauseParameter {
	fn from(node: ObjectPattern) -> CatchClauseParameter {
		CatchClauseParameter::ObjectPattern(node)
	}
}
impl AstNode for CatchClauseParameter {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ARRAY_PATTERN | SyntaxKind::IDENTIFIER | SyntaxKind::OBJECT_PATTERN => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ARRAY_PATTERN => {
				CatchClauseParameter::ArrayPattern(ArrayPattern { syntax })
			}
			SyntaxKind::IDENTIFIER => CatchClauseParameter::Identifier(Identifier { syntax }),
			SyntaxKind::OBJECT_PATTERN => {
				CatchClauseParameter::ObjectPattern(ObjectPattern { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			CatchClauseParameter::ArrayPattern(it) => &it.syntax,
			CatchClauseParameter::Identifier(it) => &it.syntax,
			CatchClauseParameter::ObjectPattern(it) => &it.syntax,
		}
	}
}
impl From<AbstractMethodSignature> for ClassBodyInnerChildren {
	fn from(node: AbstractMethodSignature) -> ClassBodyInnerChildren {
		ClassBodyInnerChildren::AbstractMethodSignature(node)
	}
}
impl From<Decorator> for ClassBodyInnerChildren {
	fn from(node: Decorator) -> ClassBodyInnerChildren {
		ClassBodyInnerChildren::Decorator(node)
	}
}
impl From<IndexSignature> for ClassBodyInnerChildren {
	fn from(node: IndexSignature) -> ClassBodyInnerChildren {
		ClassBodyInnerChildren::IndexSignature(node)
	}
}
impl From<MethodDefinition> for ClassBodyInnerChildren {
	fn from(node: MethodDefinition) -> ClassBodyInnerChildren {
		ClassBodyInnerChildren::MethodDefinition(node)
	}
}
impl From<MethodSignature> for ClassBodyInnerChildren {
	fn from(node: MethodSignature) -> ClassBodyInnerChildren {
		ClassBodyInnerChildren::MethodSignature(node)
	}
}
impl From<PublicFieldDefinition> for ClassBodyInnerChildren {
	fn from(node: PublicFieldDefinition) -> ClassBodyInnerChildren {
		ClassBodyInnerChildren::PublicFieldDefinition(node)
	}
}
impl AstNode for ClassBodyInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ABSTRACT_METHOD_SIGNATURE
			| SyntaxKind::DECORATOR
			| SyntaxKind::INDEX_SIGNATURE
			| SyntaxKind::METHOD_DEFINITION
			| SyntaxKind::METHOD_SIGNATURE
			| SyntaxKind::PUBLIC_FIELD_DEFINITION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ABSTRACT_METHOD_SIGNATURE => {
				ClassBodyInnerChildren::AbstractMethodSignature(AbstractMethodSignature { syntax })
			}
			SyntaxKind::DECORATOR => ClassBodyInnerChildren::Decorator(Decorator { syntax }),
			SyntaxKind::INDEX_SIGNATURE => {
				ClassBodyInnerChildren::IndexSignature(IndexSignature { syntax })
			}
			SyntaxKind::METHOD_DEFINITION => {
				ClassBodyInnerChildren::MethodDefinition(MethodDefinition { syntax })
			}
			SyntaxKind::METHOD_SIGNATURE => {
				ClassBodyInnerChildren::MethodSignature(MethodSignature { syntax })
			}
			SyntaxKind::PUBLIC_FIELD_DEFINITION => {
				ClassBodyInnerChildren::PublicFieldDefinition(PublicFieldDefinition { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ClassBodyInnerChildren::AbstractMethodSignature(it) => &it.syntax,
			ClassBodyInnerChildren::Decorator(it) => &it.syntax,
			ClassBodyInnerChildren::IndexSignature(it) => &it.syntax,
			ClassBodyInnerChildren::MethodDefinition(it) => &it.syntax,
			ClassBodyInnerChildren::MethodSignature(it) => &it.syntax,
			ClassBodyInnerChildren::PublicFieldDefinition(it) => &it.syntax,
		}
	}
}
impl From<ExtendsClause> for ClassHeritageInnerChildren {
	fn from(node: ExtendsClause) -> ClassHeritageInnerChildren {
		ClassHeritageInnerChildren::ExtendsClause(node)
	}
}
impl From<ImplementsClause> for ClassHeritageInnerChildren {
	fn from(node: ImplementsClause) -> ClassHeritageInnerChildren {
		ClassHeritageInnerChildren::ImplementsClause(node)
	}
}
impl AstNode for ClassHeritageInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::EXTENDS_CLAUSE | SyntaxKind::IMPLEMENTS_CLAUSE => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::EXTENDS_CLAUSE => {
				ClassHeritageInnerChildren::ExtendsClause(ExtendsClause { syntax })
			}
			SyntaxKind::IMPLEMENTS_CLAUSE => {
				ClassHeritageInnerChildren::ImplementsClause(ImplementsClause { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ClassHeritageInnerChildren::ExtendsClause(it) => &it.syntax,
			ClassHeritageInnerChildren::ImplementsClause(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for ConditionalTypeAlternative {
	fn from(node: ConstructorType) -> ConditionalTypeAlternative {
		ConditionalTypeAlternative::ConstructorType(node)
	}
}
impl From<FunctionType> for ConditionalTypeAlternative {
	fn from(node: FunctionType) -> ConditionalTypeAlternative {
		ConditionalTypeAlternative::FunctionType(node)
	}
}
impl From<InferType> for ConditionalTypeAlternative {
	fn from(node: InferType) -> ConditionalTypeAlternative {
		ConditionalTypeAlternative::InferType(node)
	}
}
impl From<IntersectionType> for ConditionalTypeAlternative {
	fn from(node: IntersectionType) -> ConditionalTypeAlternative {
		ConditionalTypeAlternative::IntersectionType(node)
	}
}
impl From<PrimaryType> for ConditionalTypeAlternative {
	fn from(node: PrimaryType) -> ConditionalTypeAlternative {
		ConditionalTypeAlternative::PrimaryType(node)
	}
}
impl From<ReadonlyType> for ConditionalTypeAlternative {
	fn from(node: ReadonlyType) -> ConditionalTypeAlternative {
		ConditionalTypeAlternative::ReadonlyType(node)
	}
}
impl From<UnionType> for ConditionalTypeAlternative {
	fn from(node: UnionType) -> ConditionalTypeAlternative {
		ConditionalTypeAlternative::UnionType(node)
	}
}
impl AstNode for ConditionalTypeAlternative {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				ConditionalTypeAlternative::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				ConditionalTypeAlternative::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => ConditionalTypeAlternative::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				ConditionalTypeAlternative::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				ConditionalTypeAlternative::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => ConditionalTypeAlternative::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				ConditionalTypeAlternative::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ConditionalTypeAlternative::ConstructorType(it) => &it.syntax,
			ConditionalTypeAlternative::FunctionType(it) => &it.syntax,
			ConditionalTypeAlternative::InferType(it) => &it.syntax,
			ConditionalTypeAlternative::IntersectionType(it) => &it.syntax,
			ConditionalTypeAlternative::ReadonlyType(it) => &it.syntax,
			ConditionalTypeAlternative::UnionType(it) => &it.syntax,
			ConditionalTypeAlternative::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<ConstructorType> for ConditionalTypeConsequence {
	fn from(node: ConstructorType) -> ConditionalTypeConsequence {
		ConditionalTypeConsequence::ConstructorType(node)
	}
}
impl From<FunctionType> for ConditionalTypeConsequence {
	fn from(node: FunctionType) -> ConditionalTypeConsequence {
		ConditionalTypeConsequence::FunctionType(node)
	}
}
impl From<InferType> for ConditionalTypeConsequence {
	fn from(node: InferType) -> ConditionalTypeConsequence {
		ConditionalTypeConsequence::InferType(node)
	}
}
impl From<IntersectionType> for ConditionalTypeConsequence {
	fn from(node: IntersectionType) -> ConditionalTypeConsequence {
		ConditionalTypeConsequence::IntersectionType(node)
	}
}
impl From<PrimaryType> for ConditionalTypeConsequence {
	fn from(node: PrimaryType) -> ConditionalTypeConsequence {
		ConditionalTypeConsequence::PrimaryType(node)
	}
}
impl From<ReadonlyType> for ConditionalTypeConsequence {
	fn from(node: ReadonlyType) -> ConditionalTypeConsequence {
		ConditionalTypeConsequence::ReadonlyType(node)
	}
}
impl From<UnionType> for ConditionalTypeConsequence {
	fn from(node: UnionType) -> ConditionalTypeConsequence {
		ConditionalTypeConsequence::UnionType(node)
	}
}
impl AstNode for ConditionalTypeConsequence {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				ConditionalTypeConsequence::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				ConditionalTypeConsequence::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => ConditionalTypeConsequence::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				ConditionalTypeConsequence::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				ConditionalTypeConsequence::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => ConditionalTypeConsequence::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				ConditionalTypeConsequence::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ConditionalTypeConsequence::ConstructorType(it) => &it.syntax,
			ConditionalTypeConsequence::FunctionType(it) => &it.syntax,
			ConditionalTypeConsequence::InferType(it) => &it.syntax,
			ConditionalTypeConsequence::IntersectionType(it) => &it.syntax,
			ConditionalTypeConsequence::ReadonlyType(it) => &it.syntax,
			ConditionalTypeConsequence::UnionType(it) => &it.syntax,
			ConditionalTypeConsequence::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<ConstructorType> for ConditionalTypeLeft {
	fn from(node: ConstructorType) -> ConditionalTypeLeft {
		ConditionalTypeLeft::ConstructorType(node)
	}
}
impl From<FunctionType> for ConditionalTypeLeft {
	fn from(node: FunctionType) -> ConditionalTypeLeft {
		ConditionalTypeLeft::FunctionType(node)
	}
}
impl From<InferType> for ConditionalTypeLeft {
	fn from(node: InferType) -> ConditionalTypeLeft {
		ConditionalTypeLeft::InferType(node)
	}
}
impl From<IntersectionType> for ConditionalTypeLeft {
	fn from(node: IntersectionType) -> ConditionalTypeLeft {
		ConditionalTypeLeft::IntersectionType(node)
	}
}
impl From<PrimaryType> for ConditionalTypeLeft {
	fn from(node: PrimaryType) -> ConditionalTypeLeft {
		ConditionalTypeLeft::PrimaryType(node)
	}
}
impl From<ReadonlyType> for ConditionalTypeLeft {
	fn from(node: ReadonlyType) -> ConditionalTypeLeft {
		ConditionalTypeLeft::ReadonlyType(node)
	}
}
impl From<UnionType> for ConditionalTypeLeft {
	fn from(node: UnionType) -> ConditionalTypeLeft {
		ConditionalTypeLeft::UnionType(node)
	}
}
impl AstNode for ConditionalTypeLeft {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				ConditionalTypeLeft::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => ConditionalTypeLeft::FunctionType(FunctionType { syntax }),
			SyntaxKind::INFER_TYPE => ConditionalTypeLeft::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				ConditionalTypeLeft::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => ConditionalTypeLeft::ReadonlyType(ReadonlyType { syntax }),
			SyntaxKind::UNION_TYPE => ConditionalTypeLeft::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				ConditionalTypeLeft::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ConditionalTypeLeft::ConstructorType(it) => &it.syntax,
			ConditionalTypeLeft::FunctionType(it) => &it.syntax,
			ConditionalTypeLeft::InferType(it) => &it.syntax,
			ConditionalTypeLeft::IntersectionType(it) => &it.syntax,
			ConditionalTypeLeft::ReadonlyType(it) => &it.syntax,
			ConditionalTypeLeft::UnionType(it) => &it.syntax,
			ConditionalTypeLeft::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<ConstructorType> for ConditionalTypeRight {
	fn from(node: ConstructorType) -> ConditionalTypeRight {
		ConditionalTypeRight::ConstructorType(node)
	}
}
impl From<FunctionType> for ConditionalTypeRight {
	fn from(node: FunctionType) -> ConditionalTypeRight {
		ConditionalTypeRight::FunctionType(node)
	}
}
impl From<InferType> for ConditionalTypeRight {
	fn from(node: InferType) -> ConditionalTypeRight {
		ConditionalTypeRight::InferType(node)
	}
}
impl From<IntersectionType> for ConditionalTypeRight {
	fn from(node: IntersectionType) -> ConditionalTypeRight {
		ConditionalTypeRight::IntersectionType(node)
	}
}
impl From<PrimaryType> for ConditionalTypeRight {
	fn from(node: PrimaryType) -> ConditionalTypeRight {
		ConditionalTypeRight::PrimaryType(node)
	}
}
impl From<ReadonlyType> for ConditionalTypeRight {
	fn from(node: ReadonlyType) -> ConditionalTypeRight {
		ConditionalTypeRight::ReadonlyType(node)
	}
}
impl From<UnionType> for ConditionalTypeRight {
	fn from(node: UnionType) -> ConditionalTypeRight {
		ConditionalTypeRight::UnionType(node)
	}
}
impl AstNode for ConditionalTypeRight {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				ConditionalTypeRight::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				ConditionalTypeRight::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => ConditionalTypeRight::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				ConditionalTypeRight::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				ConditionalTypeRight::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => ConditionalTypeRight::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				ConditionalTypeRight::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ConditionalTypeRight::ConstructorType(it) => &it.syntax,
			ConditionalTypeRight::FunctionType(it) => &it.syntax,
			ConditionalTypeRight::InferType(it) => &it.syntax,
			ConditionalTypeRight::IntersectionType(it) => &it.syntax,
			ConditionalTypeRight::ReadonlyType(it) => &it.syntax,
			ConditionalTypeRight::UnionType(it) => &it.syntax,
			ConditionalTypeRight::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<ConstructorType> for ConstraintInnerChildren {
	fn from(node: ConstructorType) -> ConstraintInnerChildren {
		ConstraintInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for ConstraintInnerChildren {
	fn from(node: FunctionType) -> ConstraintInnerChildren {
		ConstraintInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for ConstraintInnerChildren {
	fn from(node: InferType) -> ConstraintInnerChildren {
		ConstraintInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for ConstraintInnerChildren {
	fn from(node: IntersectionType) -> ConstraintInnerChildren {
		ConstraintInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for ConstraintInnerChildren {
	fn from(node: PrimaryType) -> ConstraintInnerChildren {
		ConstraintInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for ConstraintInnerChildren {
	fn from(node: ReadonlyType) -> ConstraintInnerChildren {
		ConstraintInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for ConstraintInnerChildren {
	fn from(node: UnionType) -> ConstraintInnerChildren {
		ConstraintInnerChildren::UnionType(node)
	}
}
impl AstNode for ConstraintInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				ConstraintInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				ConstraintInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => ConstraintInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				ConstraintInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				ConstraintInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => ConstraintInnerChildren::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				ConstraintInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ConstraintInnerChildren::ConstructorType(it) => &it.syntax,
			ConstraintInnerChildren::FunctionType(it) => &it.syntax,
			ConstraintInnerChildren::InferType(it) => &it.syntax,
			ConstraintInnerChildren::IntersectionType(it) => &it.syntax,
			ConstraintInnerChildren::ReadonlyType(it) => &it.syntax,
			ConstraintInnerChildren::UnionType(it) => &it.syntax,
			ConstraintInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<FormalParameters> for ConstructSignatureInnerChildren {
	fn from(node: FormalParameters) -> ConstructSignatureInnerChildren {
		ConstructSignatureInnerChildren::FormalParameters(node)
	}
}
impl From<TypeAnnotation> for ConstructSignatureInnerChildren {
	fn from(node: TypeAnnotation) -> ConstructSignatureInnerChildren {
		ConstructSignatureInnerChildren::TypeAnnotation(node)
	}
}
impl From<TypeParameters> for ConstructSignatureInnerChildren {
	fn from(node: TypeParameters) -> ConstructSignatureInnerChildren {
		ConstructSignatureInnerChildren::TypeParameters(node)
	}
}
impl AstNode for ConstructSignatureInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::FORMAL_PARAMETERS
			| SyntaxKind::TYPE_ANNOTATION
			| SyntaxKind::TYPE_PARAMETERS => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::FORMAL_PARAMETERS => {
				ConstructSignatureInnerChildren::FormalParameters(FormalParameters { syntax })
			}
			SyntaxKind::TYPE_ANNOTATION => {
				ConstructSignatureInnerChildren::TypeAnnotation(TypeAnnotation { syntax })
			}
			SyntaxKind::TYPE_PARAMETERS => {
				ConstructSignatureInnerChildren::TypeParameters(TypeParameters { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ConstructSignatureInnerChildren::FormalParameters(it) => &it.syntax,
			ConstructSignatureInnerChildren::TypeAnnotation(it) => &it.syntax,
			ConstructSignatureInnerChildren::TypeParameters(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for ConstructorTypeInnerChildren {
	fn from(node: ConstructorType) -> ConstructorTypeInnerChildren {
		ConstructorTypeInnerChildren::ConstructorType(node)
	}
}
impl From<FormalParameters> for ConstructorTypeInnerChildren {
	fn from(node: FormalParameters) -> ConstructorTypeInnerChildren {
		ConstructorTypeInnerChildren::FormalParameters(node)
	}
}
impl From<FunctionType> for ConstructorTypeInnerChildren {
	fn from(node: FunctionType) -> ConstructorTypeInnerChildren {
		ConstructorTypeInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for ConstructorTypeInnerChildren {
	fn from(node: InferType) -> ConstructorTypeInnerChildren {
		ConstructorTypeInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for ConstructorTypeInnerChildren {
	fn from(node: IntersectionType) -> ConstructorTypeInnerChildren {
		ConstructorTypeInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for ConstructorTypeInnerChildren {
	fn from(node: PrimaryType) -> ConstructorTypeInnerChildren {
		ConstructorTypeInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for ConstructorTypeInnerChildren {
	fn from(node: ReadonlyType) -> ConstructorTypeInnerChildren {
		ConstructorTypeInnerChildren::ReadonlyType(node)
	}
}
impl From<TypeParameters> for ConstructorTypeInnerChildren {
	fn from(node: TypeParameters) -> ConstructorTypeInnerChildren {
		ConstructorTypeInnerChildren::TypeParameters(node)
	}
}
impl From<UnionType> for ConstructorTypeInnerChildren {
	fn from(node: UnionType) -> ConstructorTypeInnerChildren {
		ConstructorTypeInnerChildren::UnionType(node)
	}
}
impl AstNode for ConstructorTypeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FORMAL_PARAMETERS
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::TYPE_PARAMETERS
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				ConstructorTypeInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FORMAL_PARAMETERS => {
				ConstructorTypeInnerChildren::FormalParameters(FormalParameters { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				ConstructorTypeInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => ConstructorTypeInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				ConstructorTypeInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				ConstructorTypeInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::TYPE_PARAMETERS => {
				ConstructorTypeInnerChildren::TypeParameters(TypeParameters { syntax })
			}
			SyntaxKind::UNION_TYPE => ConstructorTypeInnerChildren::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				ConstructorTypeInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ConstructorTypeInnerChildren::ConstructorType(it) => &it.syntax,
			ConstructorTypeInnerChildren::FormalParameters(it) => &it.syntax,
			ConstructorTypeInnerChildren::FunctionType(it) => &it.syntax,
			ConstructorTypeInnerChildren::InferType(it) => &it.syntax,
			ConstructorTypeInnerChildren::IntersectionType(it) => &it.syntax,
			ConstructorTypeInnerChildren::ReadonlyType(it) => &it.syntax,
			ConstructorTypeInnerChildren::TypeParameters(it) => &it.syntax,
			ConstructorTypeInnerChildren::UnionType(it) => &it.syntax,
			ConstructorTypeInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<AbstractClassDeclaration> for Declaration {
	fn from(node: AbstractClassDeclaration) -> Declaration {
		Declaration::AbstractClassDeclaration(node)
	}
}
impl From<AmbientDeclaration> for Declaration {
	fn from(node: AmbientDeclaration) -> Declaration {
		Declaration::AmbientDeclaration(node)
	}
}
impl From<ClassDeclaration> for Declaration {
	fn from(node: ClassDeclaration) -> Declaration {
		Declaration::ClassDeclaration(node)
	}
}
impl From<EnumDeclaration> for Declaration {
	fn from(node: EnumDeclaration) -> Declaration {
		Declaration::EnumDeclaration(node)
	}
}
impl From<FunctionDeclaration> for Declaration {
	fn from(node: FunctionDeclaration) -> Declaration {
		Declaration::FunctionDeclaration(node)
	}
}
impl From<FunctionSignature> for Declaration {
	fn from(node: FunctionSignature) -> Declaration {
		Declaration::FunctionSignature(node)
	}
}
impl From<GeneratorFunctionDeclaration> for Declaration {
	fn from(node: GeneratorFunctionDeclaration) -> Declaration {
		Declaration::GeneratorFunctionDeclaration(node)
	}
}
impl From<ImportAlias> for Declaration {
	fn from(node: ImportAlias) -> Declaration {
		Declaration::ImportAlias(node)
	}
}
impl From<InterfaceDeclaration> for Declaration {
	fn from(node: InterfaceDeclaration) -> Declaration {
		Declaration::InterfaceDeclaration(node)
	}
}
impl From<InternalModule> for Declaration {
	fn from(node: InternalModule) -> Declaration {
		Declaration::InternalModule(node)
	}
}
impl From<LexicalDeclaration> for Declaration {
	fn from(node: LexicalDeclaration) -> Declaration {
		Declaration::LexicalDeclaration(node)
	}
}
impl From<Module> for Declaration {
	fn from(node: Module) -> Declaration {
		Declaration::Module(node)
	}
}
impl From<TypeAliasDeclaration> for Declaration {
	fn from(node: TypeAliasDeclaration) -> Declaration {
		Declaration::TypeAliasDeclaration(node)
	}
}
impl From<VariableDeclaration> for Declaration {
	fn from(node: VariableDeclaration) -> Declaration {
		Declaration::VariableDeclaration(node)
	}
}
impl AstNode for Declaration {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ABSTRACT_CLASS_DECLARATION
			| SyntaxKind::AMBIENT_DECLARATION
			| SyntaxKind::CLASS_DECLARATION
			| SyntaxKind::ENUM_DECLARATION
			| SyntaxKind::FUNCTION_DECLARATION
			| SyntaxKind::FUNCTION_SIGNATURE
			| SyntaxKind::GENERATOR_FUNCTION_DECLARATION
			| SyntaxKind::IMPORT_ALIAS
			| SyntaxKind::INTERFACE_DECLARATION
			| SyntaxKind::INTERNAL_MODULE
			| SyntaxKind::LEXICAL_DECLARATION
			| SyntaxKind::MODULE
			| SyntaxKind::TYPE_ALIAS_DECLARATION
			| SyntaxKind::VARIABLE_DECLARATION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ABSTRACT_CLASS_DECLARATION => {
				Declaration::AbstractClassDeclaration(AbstractClassDeclaration { syntax })
			}
			SyntaxKind::AMBIENT_DECLARATION => {
				Declaration::AmbientDeclaration(AmbientDeclaration { syntax })
			}
			SyntaxKind::CLASS_DECLARATION => {
				Declaration::ClassDeclaration(ClassDeclaration { syntax })
			}
			SyntaxKind::ENUM_DECLARATION => {
				Declaration::EnumDeclaration(EnumDeclaration { syntax })
			}
			SyntaxKind::FUNCTION_DECLARATION => {
				Declaration::FunctionDeclaration(FunctionDeclaration { syntax })
			}
			SyntaxKind::FUNCTION_SIGNATURE => {
				Declaration::FunctionSignature(FunctionSignature { syntax })
			}
			SyntaxKind::GENERATOR_FUNCTION_DECLARATION => {
				Declaration::GeneratorFunctionDeclaration(GeneratorFunctionDeclaration { syntax })
			}
			SyntaxKind::IMPORT_ALIAS => Declaration::ImportAlias(ImportAlias { syntax }),
			SyntaxKind::INTERFACE_DECLARATION => {
				Declaration::InterfaceDeclaration(InterfaceDeclaration { syntax })
			}
			SyntaxKind::INTERNAL_MODULE => Declaration::InternalModule(InternalModule { syntax }),
			SyntaxKind::LEXICAL_DECLARATION => {
				Declaration::LexicalDeclaration(LexicalDeclaration { syntax })
			}
			SyntaxKind::MODULE => Declaration::Module(Module { syntax }),
			SyntaxKind::TYPE_ALIAS_DECLARATION => {
				Declaration::TypeAliasDeclaration(TypeAliasDeclaration { syntax })
			}
			SyntaxKind::VARIABLE_DECLARATION => {
				Declaration::VariableDeclaration(VariableDeclaration { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			Declaration::AbstractClassDeclaration(it) => &it.syntax,
			Declaration::AmbientDeclaration(it) => &it.syntax,
			Declaration::ClassDeclaration(it) => &it.syntax,
			Declaration::EnumDeclaration(it) => &it.syntax,
			Declaration::FunctionDeclaration(it) => &it.syntax,
			Declaration::FunctionSignature(it) => &it.syntax,
			Declaration::GeneratorFunctionDeclaration(it) => &it.syntax,
			Declaration::ImportAlias(it) => &it.syntax,
			Declaration::InterfaceDeclaration(it) => &it.syntax,
			Declaration::InternalModule(it) => &it.syntax,
			Declaration::LexicalDeclaration(it) => &it.syntax,
			Declaration::Module(it) => &it.syntax,
			Declaration::TypeAliasDeclaration(it) => &it.syntax,
			Declaration::VariableDeclaration(it) => &it.syntax,
		}
	}
}
impl From<CallExpression> for DecoratorInnerChildren {
	fn from(node: CallExpression) -> DecoratorInnerChildren {
		DecoratorInnerChildren::CallExpression(node)
	}
}
impl From<Identifier> for DecoratorInnerChildren {
	fn from(node: Identifier) -> DecoratorInnerChildren {
		DecoratorInnerChildren::Identifier(node)
	}
}
impl From<MemberExpression> for DecoratorInnerChildren {
	fn from(node: MemberExpression) -> DecoratorInnerChildren {
		DecoratorInnerChildren::MemberExpression(node)
	}
}
impl AstNode for DecoratorInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CALL_EXPRESSION
			| SyntaxKind::IDENTIFIER
			| SyntaxKind::MEMBER_EXPRESSION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CALL_EXPRESSION => {
				DecoratorInnerChildren::CallExpression(CallExpression { syntax })
			}
			SyntaxKind::IDENTIFIER => DecoratorInnerChildren::Identifier(Identifier { syntax }),
			SyntaxKind::MEMBER_EXPRESSION => {
				DecoratorInnerChildren::MemberExpression(MemberExpression { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			DecoratorInnerChildren::CallExpression(it) => &it.syntax,
			DecoratorInnerChildren::Identifier(it) => &it.syntax,
			DecoratorInnerChildren::MemberExpression(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for DefaultTypeInnerChildren {
	fn from(node: ConstructorType) -> DefaultTypeInnerChildren {
		DefaultTypeInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for DefaultTypeInnerChildren {
	fn from(node: FunctionType) -> DefaultTypeInnerChildren {
		DefaultTypeInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for DefaultTypeInnerChildren {
	fn from(node: InferType) -> DefaultTypeInnerChildren {
		DefaultTypeInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for DefaultTypeInnerChildren {
	fn from(node: IntersectionType) -> DefaultTypeInnerChildren {
		DefaultTypeInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for DefaultTypeInnerChildren {
	fn from(node: PrimaryType) -> DefaultTypeInnerChildren {
		DefaultTypeInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for DefaultTypeInnerChildren {
	fn from(node: ReadonlyType) -> DefaultTypeInnerChildren {
		DefaultTypeInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for DefaultTypeInnerChildren {
	fn from(node: UnionType) -> DefaultTypeInnerChildren {
		DefaultTypeInnerChildren::UnionType(node)
	}
}
impl AstNode for DefaultTypeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				DefaultTypeInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				DefaultTypeInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => DefaultTypeInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				DefaultTypeInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				DefaultTypeInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => DefaultTypeInnerChildren::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				DefaultTypeInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			DefaultTypeInnerChildren::ConstructorType(it) => &it.syntax,
			DefaultTypeInnerChildren::FunctionType(it) => &it.syntax,
			DefaultTypeInnerChildren::InferType(it) => &it.syntax,
			DefaultTypeInnerChildren::IntersectionType(it) => &it.syntax,
			DefaultTypeInnerChildren::ReadonlyType(it) => &it.syntax,
			DefaultTypeInnerChildren::UnionType(it) => &it.syntax,
			DefaultTypeInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<ComputedPropertyName> for EnumAssignmentInnerChildren {
	fn from(node: ComputedPropertyName) -> EnumAssignmentInnerChildren {
		EnumAssignmentInnerChildren::ComputedPropertyName(node)
	}
}
impl From<Number> for EnumAssignmentInnerChildren {
	fn from(node: Number) -> EnumAssignmentInnerChildren {
		EnumAssignmentInnerChildren::Number(node)
	}
}
impl From<PropertyIdentifier> for EnumAssignmentInnerChildren {
	fn from(node: PropertyIdentifier) -> EnumAssignmentInnerChildren {
		EnumAssignmentInnerChildren::PropertyIdentifier(node)
	}
}
impl From<StringLiteral> for EnumAssignmentInnerChildren {
	fn from(node: StringLiteral) -> EnumAssignmentInnerChildren {
		EnumAssignmentInnerChildren::StringLiteral(node)
	}
}
impl AstNode for EnumAssignmentInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::COMPUTED_PROPERTY_NAME
			| SyntaxKind::NUMBER
			| SyntaxKind::PROPERTY_IDENTIFIER
			| SyntaxKind::STRING_LITERAL => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::COMPUTED_PROPERTY_NAME => {
				EnumAssignmentInnerChildren::ComputedPropertyName(ComputedPropertyName { syntax })
			}
			SyntaxKind::NUMBER => EnumAssignmentInnerChildren::Number(Number { syntax }),
			SyntaxKind::PROPERTY_IDENTIFIER => {
				EnumAssignmentInnerChildren::PropertyIdentifier(PropertyIdentifier { syntax })
			}
			SyntaxKind::STRING_LITERAL => {
				EnumAssignmentInnerChildren::StringLiteral(StringLiteral { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			EnumAssignmentInnerChildren::ComputedPropertyName(it) => &it.syntax,
			EnumAssignmentInnerChildren::Number(it) => &it.syntax,
			EnumAssignmentInnerChildren::PropertyIdentifier(it) => &it.syntax,
			EnumAssignmentInnerChildren::StringLiteral(it) => &it.syntax,
		}
	}
}
impl From<ComputedPropertyName> for EnumBodyInnerChildren {
	fn from(node: ComputedPropertyName) -> EnumBodyInnerChildren {
		EnumBodyInnerChildren::ComputedPropertyName(node)
	}
}
impl From<EnumAssignment> for EnumBodyInnerChildren {
	fn from(node: EnumAssignment) -> EnumBodyInnerChildren {
		EnumBodyInnerChildren::EnumAssignment(node)
	}
}
impl From<Number> for EnumBodyInnerChildren {
	fn from(node: Number) -> EnumBodyInnerChildren {
		EnumBodyInnerChildren::Number(node)
	}
}
impl From<PropertyIdentifier> for EnumBodyInnerChildren {
	fn from(node: PropertyIdentifier) -> EnumBodyInnerChildren {
		EnumBodyInnerChildren::PropertyIdentifier(node)
	}
}
impl From<StringLiteral> for EnumBodyInnerChildren {
	fn from(node: StringLiteral) -> EnumBodyInnerChildren {
		EnumBodyInnerChildren::StringLiteral(node)
	}
}
impl AstNode for EnumBodyInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::COMPUTED_PROPERTY_NAME
			| SyntaxKind::ENUM_ASSIGNMENT
			| SyntaxKind::NUMBER
			| SyntaxKind::PROPERTY_IDENTIFIER
			| SyntaxKind::STRING_LITERAL => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::COMPUTED_PROPERTY_NAME => {
				EnumBodyInnerChildren::ComputedPropertyName(ComputedPropertyName { syntax })
			}
			SyntaxKind::ENUM_ASSIGNMENT => {
				EnumBodyInnerChildren::EnumAssignment(EnumAssignment { syntax })
			}
			SyntaxKind::NUMBER => EnumBodyInnerChildren::Number(Number { syntax }),
			SyntaxKind::PROPERTY_IDENTIFIER => {
				EnumBodyInnerChildren::PropertyIdentifier(PropertyIdentifier { syntax })
			}
			SyntaxKind::STRING_LITERAL => {
				EnumBodyInnerChildren::StringLiteral(StringLiteral { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			EnumBodyInnerChildren::ComputedPropertyName(it) => &it.syntax,
			EnumBodyInnerChildren::EnumAssignment(it) => &it.syntax,
			EnumBodyInnerChildren::Number(it) => &it.syntax,
			EnumBodyInnerChildren::PropertyIdentifier(it) => &it.syntax,
			EnumBodyInnerChildren::StringLiteral(it) => &it.syntax,
		}
	}
}
impl From<ExportClause> for ExportStatementInnerChildren {
	fn from(node: ExportClause) -> ExportStatementInnerChildren {
		ExportStatementInnerChildren::ExportClause(node)
	}
}
impl From<FunctionSignature> for ExportStatementInnerChildren {
	fn from(node: FunctionSignature) -> ExportStatementInnerChildren {
		ExportStatementInnerChildren::FunctionSignature(node)
	}
}
impl From<Identifier> for ExportStatementInnerChildren {
	fn from(node: Identifier) -> ExportStatementInnerChildren {
		ExportStatementInnerChildren::Identifier(node)
	}
}
impl AstNode for ExportStatementInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::EXPORT_CLAUSE | SyntaxKind::FUNCTION_SIGNATURE | SyntaxKind::IDENTIFIER => {
				true
			}
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::EXPORT_CLAUSE => {
				ExportStatementInnerChildren::ExportClause(ExportClause { syntax })
			}
			SyntaxKind::FUNCTION_SIGNATURE => {
				ExportStatementInnerChildren::FunctionSignature(FunctionSignature { syntax })
			}
			SyntaxKind::IDENTIFIER => {
				ExportStatementInnerChildren::Identifier(Identifier { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ExportStatementInnerChildren::ExportClause(it) => &it.syntax,
			ExportStatementInnerChildren::FunctionSignature(it) => &it.syntax,
			ExportStatementInnerChildren::Identifier(it) => &it.syntax,
		}
	}
}
impl From<AsExpression> for Expression {
	fn from(node: AsExpression) -> Expression {
		Expression::AsExpression(node)
	}
}
impl From<AssignmentExpression> for Expression {
	fn from(node: AssignmentExpression) -> Expression {
		Expression::AssignmentExpression(node)
	}
}
impl From<AugmentedAssignmentExpression> for Expression {
	fn from(node: AugmentedAssignmentExpression) -> Expression {
		Expression::AugmentedAssignmentExpression(node)
	}
}
impl From<AwaitExpression> for Expression {
	fn from(node: AwaitExpression) -> Expression {
		Expression::AwaitExpression(node)
	}
}
impl From<BinaryExpression> for Expression {
	fn from(node: BinaryExpression) -> Expression {
		Expression::BinaryExpression(node)
	}
}
impl From<InternalModule> for Expression {
	fn from(node: InternalModule) -> Expression {
		Expression::InternalModule(node)
	}
}
impl From<JsxElement> for Expression {
	fn from(node: JsxElement) -> Expression {
		Expression::JsxElement(node)
	}
}
impl From<JsxFragment> for Expression {
	fn from(node: JsxFragment) -> Expression {
		Expression::JsxFragment(node)
	}
}
impl From<JsxSelfClosingElement> for Expression {
	fn from(node: JsxSelfClosingElement) -> Expression {
		Expression::JsxSelfClosingElement(node)
	}
}
impl From<NewExpression> for Expression {
	fn from(node: NewExpression) -> Expression {
		Expression::NewExpression(node)
	}
}
impl From<PrimaryExpression> for Expression {
	fn from(node: PrimaryExpression) -> Expression {
		Expression::PrimaryExpression(node)
	}
}
impl From<TernaryExpression> for Expression {
	fn from(node: TernaryExpression) -> Expression {
		Expression::TernaryExpression(node)
	}
}
impl From<TypeAssertion> for Expression {
	fn from(node: TypeAssertion) -> Expression {
		Expression::TypeAssertion(node)
	}
}
impl From<UnaryExpression> for Expression {
	fn from(node: UnaryExpression) -> Expression {
		Expression::UnaryExpression(node)
	}
}
impl From<UpdateExpression> for Expression {
	fn from(node: UpdateExpression) -> Expression {
		Expression::UpdateExpression(node)
	}
}
impl From<YieldExpression> for Expression {
	fn from(node: YieldExpression) -> Expression {
		Expression::YieldExpression(node)
	}
}
impl AstNode for Expression {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::AS_EXPRESSION
			| SyntaxKind::ASSIGNMENT_EXPRESSION
			| SyntaxKind::AUGMENTED_ASSIGNMENT_EXPRESSION
			| SyntaxKind::AWAIT_EXPRESSION
			| SyntaxKind::BINARY_EXPRESSION
			| SyntaxKind::INTERNAL_MODULE
			| SyntaxKind::JSX_ELEMENT
			| SyntaxKind::JSX_FRAGMENT
			| SyntaxKind::JSX_SELF_CLOSING_ELEMENT
			| SyntaxKind::NEW_EXPRESSION
			| SyntaxKind::TERNARY_EXPRESSION
			| SyntaxKind::TYPE_ASSERTION
			| SyntaxKind::UNARY_EXPRESSION
			| SyntaxKind::UPDATE_EXPRESSION
			| SyntaxKind::YIELD_EXPRESSION => true,
			_ => PrimaryExpression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::AS_EXPRESSION => Expression::AsExpression(AsExpression { syntax }),
			SyntaxKind::ASSIGNMENT_EXPRESSION => {
				Expression::AssignmentExpression(AssignmentExpression { syntax })
			}
			SyntaxKind::AUGMENTED_ASSIGNMENT_EXPRESSION => {
				Expression::AugmentedAssignmentExpression(AugmentedAssignmentExpression { syntax })
			}
			SyntaxKind::AWAIT_EXPRESSION => Expression::AwaitExpression(AwaitExpression { syntax }),
			SyntaxKind::BINARY_EXPRESSION => {
				Expression::BinaryExpression(BinaryExpression { syntax })
			}
			SyntaxKind::INTERNAL_MODULE => Expression::InternalModule(InternalModule { syntax }),
			SyntaxKind::JSX_ELEMENT => Expression::JsxElement(JsxElement { syntax }),
			SyntaxKind::JSX_FRAGMENT => Expression::JsxFragment(JsxFragment { syntax }),
			SyntaxKind::JSX_SELF_CLOSING_ELEMENT => {
				Expression::JsxSelfClosingElement(JsxSelfClosingElement { syntax })
			}
			SyntaxKind::NEW_EXPRESSION => Expression::NewExpression(NewExpression { syntax }),
			SyntaxKind::TERNARY_EXPRESSION => {
				Expression::TernaryExpression(TernaryExpression { syntax })
			}
			SyntaxKind::TYPE_ASSERTION => Expression::TypeAssertion(TypeAssertion { syntax }),
			SyntaxKind::UNARY_EXPRESSION => Expression::UnaryExpression(UnaryExpression { syntax }),
			SyntaxKind::UPDATE_EXPRESSION => {
				Expression::UpdateExpression(UpdateExpression { syntax })
			}
			SyntaxKind::YIELD_EXPRESSION => Expression::YieldExpression(YieldExpression { syntax }),
			kind if PrimaryExpression::can_cast(kind) => {
				Expression::PrimaryExpression(PrimaryExpression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			Expression::AsExpression(it) => &it.syntax,
			Expression::AssignmentExpression(it) => &it.syntax,
			Expression::AugmentedAssignmentExpression(it) => &it.syntax,
			Expression::AwaitExpression(it) => &it.syntax,
			Expression::BinaryExpression(it) => &it.syntax,
			Expression::InternalModule(it) => &it.syntax,
			Expression::JsxElement(it) => &it.syntax,
			Expression::JsxFragment(it) => &it.syntax,
			Expression::JsxSelfClosingElement(it) => &it.syntax,
			Expression::NewExpression(it) => &it.syntax,
			Expression::TernaryExpression(it) => &it.syntax,
			Expression::TypeAssertion(it) => &it.syntax,
			Expression::UnaryExpression(it) => &it.syntax,
			Expression::UpdateExpression(it) => &it.syntax,
			Expression::YieldExpression(it) => &it.syntax,
			Expression::PrimaryExpression(it) => &it.syntax(),
		}
	}
}
impl From<Expression> for ExpressionStatementInnerChildren {
	fn from(node: Expression) -> ExpressionStatementInnerChildren {
		ExpressionStatementInnerChildren::Expression(node)
	}
}
impl From<SequenceExpression> for ExpressionStatementInnerChildren {
	fn from(node: SequenceExpression) -> ExpressionStatementInnerChildren {
		ExpressionStatementInnerChildren::SequenceExpression(node)
	}
}
impl AstNode for ExpressionStatementInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::SEQUENCE_EXPRESSION => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::SEQUENCE_EXPRESSION => {
				ExpressionStatementInnerChildren::SequenceExpression(SequenceExpression { syntax })
			}
			kind if Expression::can_cast(kind) => {
				ExpressionStatementInnerChildren::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ExpressionStatementInnerChildren::SequenceExpression(it) => &it.syntax,
			ExpressionStatementInnerChildren::Expression(it) => &it.syntax(),
		}
	}
}
impl From<Expression> for ExtendsClauseInnerChildren {
	fn from(node: Expression) -> ExtendsClauseInnerChildren {
		ExtendsClauseInnerChildren::Expression(node)
	}
}
impl From<GenericType> for ExtendsClauseInnerChildren {
	fn from(node: GenericType) -> ExtendsClauseInnerChildren {
		ExtendsClauseInnerChildren::GenericType(node)
	}
}
impl From<NestedTypeIdentifier> for ExtendsClauseInnerChildren {
	fn from(node: NestedTypeIdentifier) -> ExtendsClauseInnerChildren {
		ExtendsClauseInnerChildren::NestedTypeIdentifier(node)
	}
}
impl From<TypeIdentifier> for ExtendsClauseInnerChildren {
	fn from(node: TypeIdentifier) -> ExtendsClauseInnerChildren {
		ExtendsClauseInnerChildren::TypeIdentifier(node)
	}
}
impl AstNode for ExtendsClauseInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::GENERIC_TYPE
			| SyntaxKind::NESTED_TYPE_IDENTIFIER
			| SyntaxKind::TYPE_IDENTIFIER => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::GENERIC_TYPE => {
				ExtendsClauseInnerChildren::GenericType(GenericType { syntax })
			}
			SyntaxKind::NESTED_TYPE_IDENTIFIER => {
				ExtendsClauseInnerChildren::NestedTypeIdentifier(NestedTypeIdentifier { syntax })
			}
			SyntaxKind::TYPE_IDENTIFIER => {
				ExtendsClauseInnerChildren::TypeIdentifier(TypeIdentifier { syntax })
			}
			kind if Expression::can_cast(kind) => {
				ExtendsClauseInnerChildren::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ExtendsClauseInnerChildren::GenericType(it) => &it.syntax,
			ExtendsClauseInnerChildren::NestedTypeIdentifier(it) => &it.syntax,
			ExtendsClauseInnerChildren::TypeIdentifier(it) => &it.syntax,
			ExtendsClauseInnerChildren::Expression(it) => &it.syntax(),
		}
	}
}
impl From<ArrayPattern> for ForInStatementLeft {
	fn from(node: ArrayPattern) -> ForInStatementLeft {
		ForInStatementLeft::ArrayPattern(node)
	}
}
impl From<Identifier> for ForInStatementLeft {
	fn from(node: Identifier) -> ForInStatementLeft {
		ForInStatementLeft::Identifier(node)
	}
}
impl From<MemberExpression> for ForInStatementLeft {
	fn from(node: MemberExpression) -> ForInStatementLeft {
		ForInStatementLeft::MemberExpression(node)
	}
}
impl From<NonNullExpression> for ForInStatementLeft {
	fn from(node: NonNullExpression) -> ForInStatementLeft {
		ForInStatementLeft::NonNullExpression(node)
	}
}
impl From<ObjectPattern> for ForInStatementLeft {
	fn from(node: ObjectPattern) -> ForInStatementLeft {
		ForInStatementLeft::ObjectPattern(node)
	}
}
impl From<ParenthesizedExpression> for ForInStatementLeft {
	fn from(node: ParenthesizedExpression) -> ForInStatementLeft {
		ForInStatementLeft::ParenthesizedExpression(node)
	}
}
impl From<SubscriptExpression> for ForInStatementLeft {
	fn from(node: SubscriptExpression) -> ForInStatementLeft {
		ForInStatementLeft::SubscriptExpression(node)
	}
}
impl AstNode for ForInStatementLeft {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ARRAY_PATTERN
			| SyntaxKind::IDENTIFIER
			| SyntaxKind::MEMBER_EXPRESSION
			| SyntaxKind::NON_NULL_EXPRESSION
			| SyntaxKind::OBJECT_PATTERN
			| SyntaxKind::PARENTHESIZED_EXPRESSION
			| SyntaxKind::SUBSCRIPT_EXPRESSION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ARRAY_PATTERN => ForInStatementLeft::ArrayPattern(ArrayPattern { syntax }),
			SyntaxKind::IDENTIFIER => ForInStatementLeft::Identifier(Identifier { syntax }),
			SyntaxKind::MEMBER_EXPRESSION => {
				ForInStatementLeft::MemberExpression(MemberExpression { syntax })
			}
			SyntaxKind::NON_NULL_EXPRESSION => {
				ForInStatementLeft::NonNullExpression(NonNullExpression { syntax })
			}
			SyntaxKind::OBJECT_PATTERN => {
				ForInStatementLeft::ObjectPattern(ObjectPattern { syntax })
			}
			SyntaxKind::PARENTHESIZED_EXPRESSION => {
				ForInStatementLeft::ParenthesizedExpression(ParenthesizedExpression { syntax })
			}
			SyntaxKind::SUBSCRIPT_EXPRESSION => {
				ForInStatementLeft::SubscriptExpression(SubscriptExpression { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ForInStatementLeft::ArrayPattern(it) => &it.syntax,
			ForInStatementLeft::Identifier(it) => &it.syntax,
			ForInStatementLeft::MemberExpression(it) => &it.syntax,
			ForInStatementLeft::NonNullExpression(it) => &it.syntax,
			ForInStatementLeft::ObjectPattern(it) => &it.syntax,
			ForInStatementLeft::ParenthesizedExpression(it) => &it.syntax,
			ForInStatementLeft::SubscriptExpression(it) => &it.syntax,
		}
	}
}
impl From<Expression> for ForInStatementRight {
	fn from(node: Expression) -> ForInStatementRight {
		ForInStatementRight::Expression(node)
	}
}
impl From<SequenceExpression> for ForInStatementRight {
	fn from(node: SequenceExpression) -> ForInStatementRight {
		ForInStatementRight::SequenceExpression(node)
	}
}
impl AstNode for ForInStatementRight {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::SEQUENCE_EXPRESSION => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::SEQUENCE_EXPRESSION => {
				ForInStatementRight::SequenceExpression(SequenceExpression { syntax })
			}
			kind if Expression::can_cast(kind) => {
				ForInStatementRight::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ForInStatementRight::SequenceExpression(it) => &it.syntax,
			ForInStatementRight::Expression(it) => &it.syntax(),
		}
	}
}
impl From<EmptyStatement> for ForStatementCondition {
	fn from(node: EmptyStatement) -> ForStatementCondition {
		ForStatementCondition::EmptyStatement(node)
	}
}
impl From<ExpressionStatement> for ForStatementCondition {
	fn from(node: ExpressionStatement) -> ForStatementCondition {
		ForStatementCondition::ExpressionStatement(node)
	}
}
impl AstNode for ForStatementCondition {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::EMPTY_STATEMENT | SyntaxKind::EXPRESSION_STATEMENT => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::EMPTY_STATEMENT => {
				ForStatementCondition::EmptyStatement(EmptyStatement { syntax })
			}
			SyntaxKind::EXPRESSION_STATEMENT => {
				ForStatementCondition::ExpressionStatement(ExpressionStatement { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ForStatementCondition::EmptyStatement(it) => &it.syntax,
			ForStatementCondition::ExpressionStatement(it) => &it.syntax,
		}
	}
}
impl From<Expression> for ForStatementIncrement {
	fn from(node: Expression) -> ForStatementIncrement {
		ForStatementIncrement::Expression(node)
	}
}
impl From<SequenceExpression> for ForStatementIncrement {
	fn from(node: SequenceExpression) -> ForStatementIncrement {
		ForStatementIncrement::SequenceExpression(node)
	}
}
impl AstNode for ForStatementIncrement {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::SEQUENCE_EXPRESSION => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::SEQUENCE_EXPRESSION => {
				ForStatementIncrement::SequenceExpression(SequenceExpression { syntax })
			}
			kind if Expression::can_cast(kind) => {
				ForStatementIncrement::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ForStatementIncrement::SequenceExpression(it) => &it.syntax,
			ForStatementIncrement::Expression(it) => &it.syntax(),
		}
	}
}
impl From<EmptyStatement> for ForStatementInitializer {
	fn from(node: EmptyStatement) -> ForStatementInitializer {
		ForStatementInitializer::EmptyStatement(node)
	}
}
impl From<ExpressionStatement> for ForStatementInitializer {
	fn from(node: ExpressionStatement) -> ForStatementInitializer {
		ForStatementInitializer::ExpressionStatement(node)
	}
}
impl From<LexicalDeclaration> for ForStatementInitializer {
	fn from(node: LexicalDeclaration) -> ForStatementInitializer {
		ForStatementInitializer::LexicalDeclaration(node)
	}
}
impl From<VariableDeclaration> for ForStatementInitializer {
	fn from(node: VariableDeclaration) -> ForStatementInitializer {
		ForStatementInitializer::VariableDeclaration(node)
	}
}
impl AstNode for ForStatementInitializer {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::EMPTY_STATEMENT
			| SyntaxKind::EXPRESSION_STATEMENT
			| SyntaxKind::LEXICAL_DECLARATION
			| SyntaxKind::VARIABLE_DECLARATION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::EMPTY_STATEMENT => {
				ForStatementInitializer::EmptyStatement(EmptyStatement { syntax })
			}
			SyntaxKind::EXPRESSION_STATEMENT => {
				ForStatementInitializer::ExpressionStatement(ExpressionStatement { syntax })
			}
			SyntaxKind::LEXICAL_DECLARATION => {
				ForStatementInitializer::LexicalDeclaration(LexicalDeclaration { syntax })
			}
			SyntaxKind::VARIABLE_DECLARATION => {
				ForStatementInitializer::VariableDeclaration(VariableDeclaration { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ForStatementInitializer::EmptyStatement(it) => &it.syntax,
			ForStatementInitializer::ExpressionStatement(it) => &it.syntax,
			ForStatementInitializer::LexicalDeclaration(it) => &it.syntax,
			ForStatementInitializer::VariableDeclaration(it) => &it.syntax,
		}
	}
}
impl From<OptionalParameter> for FormalParametersInnerChildren {
	fn from(node: OptionalParameter) -> FormalParametersInnerChildren {
		FormalParametersInnerChildren::OptionalParameter(node)
	}
}
impl From<RequiredParameter> for FormalParametersInnerChildren {
	fn from(node: RequiredParameter) -> FormalParametersInnerChildren {
		FormalParametersInnerChildren::RequiredParameter(node)
	}
}
impl AstNode for FormalParametersInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::OPTIONAL_PARAMETER | SyntaxKind::REQUIRED_PARAMETER => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::OPTIONAL_PARAMETER => {
				FormalParametersInnerChildren::OptionalParameter(OptionalParameter { syntax })
			}
			SyntaxKind::REQUIRED_PARAMETER => {
				FormalParametersInnerChildren::RequiredParameter(RequiredParameter { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			FormalParametersInnerChildren::OptionalParameter(it) => &it.syntax,
			FormalParametersInnerChildren::RequiredParameter(it) => &it.syntax,
		}
	}
}
impl From<Asserts> for FunctionDeclarationReturnType {
	fn from(node: Asserts) -> FunctionDeclarationReturnType {
		FunctionDeclarationReturnType::Asserts(node)
	}
}
impl From<TypeAnnotation> for FunctionDeclarationReturnType {
	fn from(node: TypeAnnotation) -> FunctionDeclarationReturnType {
		FunctionDeclarationReturnType::TypeAnnotation(node)
	}
}
impl From<TypePredicateAnnotation> for FunctionDeclarationReturnType {
	fn from(node: TypePredicateAnnotation) -> FunctionDeclarationReturnType {
		FunctionDeclarationReturnType::TypePredicateAnnotation(node)
	}
}
impl AstNode for FunctionDeclarationReturnType {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ASSERTS
			| SyntaxKind::TYPE_ANNOTATION
			| SyntaxKind::TYPE_PREDICATE_ANNOTATION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ASSERTS => FunctionDeclarationReturnType::Asserts(Asserts { syntax }),
			SyntaxKind::TYPE_ANNOTATION => {
				FunctionDeclarationReturnType::TypeAnnotation(TypeAnnotation { syntax })
			}
			SyntaxKind::TYPE_PREDICATE_ANNOTATION => {
				FunctionDeclarationReturnType::TypePredicateAnnotation(TypePredicateAnnotation {
					syntax,
				})
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			FunctionDeclarationReturnType::Asserts(it) => &it.syntax,
			FunctionDeclarationReturnType::TypeAnnotation(it) => &it.syntax,
			FunctionDeclarationReturnType::TypePredicateAnnotation(it) => &it.syntax,
		}
	}
}
impl From<Asserts> for FunctionReturnType {
	fn from(node: Asserts) -> FunctionReturnType {
		FunctionReturnType::Asserts(node)
	}
}
impl From<TypeAnnotation> for FunctionReturnType {
	fn from(node: TypeAnnotation) -> FunctionReturnType {
		FunctionReturnType::TypeAnnotation(node)
	}
}
impl From<TypePredicateAnnotation> for FunctionReturnType {
	fn from(node: TypePredicateAnnotation) -> FunctionReturnType {
		FunctionReturnType::TypePredicateAnnotation(node)
	}
}
impl AstNode for FunctionReturnType {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ASSERTS
			| SyntaxKind::TYPE_ANNOTATION
			| SyntaxKind::TYPE_PREDICATE_ANNOTATION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ASSERTS => FunctionReturnType::Asserts(Asserts { syntax }),
			SyntaxKind::TYPE_ANNOTATION => {
				FunctionReturnType::TypeAnnotation(TypeAnnotation { syntax })
			}
			SyntaxKind::TYPE_PREDICATE_ANNOTATION => {
				FunctionReturnType::TypePredicateAnnotation(TypePredicateAnnotation { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			FunctionReturnType::Asserts(it) => &it.syntax,
			FunctionReturnType::TypeAnnotation(it) => &it.syntax,
			FunctionReturnType::TypePredicateAnnotation(it) => &it.syntax,
		}
	}
}
impl From<Asserts> for FunctionSignatureReturnType {
	fn from(node: Asserts) -> FunctionSignatureReturnType {
		FunctionSignatureReturnType::Asserts(node)
	}
}
impl From<TypeAnnotation> for FunctionSignatureReturnType {
	fn from(node: TypeAnnotation) -> FunctionSignatureReturnType {
		FunctionSignatureReturnType::TypeAnnotation(node)
	}
}
impl From<TypePredicateAnnotation> for FunctionSignatureReturnType {
	fn from(node: TypePredicateAnnotation) -> FunctionSignatureReturnType {
		FunctionSignatureReturnType::TypePredicateAnnotation(node)
	}
}
impl AstNode for FunctionSignatureReturnType {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ASSERTS
			| SyntaxKind::TYPE_ANNOTATION
			| SyntaxKind::TYPE_PREDICATE_ANNOTATION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ASSERTS => FunctionSignatureReturnType::Asserts(Asserts { syntax }),
			SyntaxKind::TYPE_ANNOTATION => {
				FunctionSignatureReturnType::TypeAnnotation(TypeAnnotation { syntax })
			}
			SyntaxKind::TYPE_PREDICATE_ANNOTATION => {
				FunctionSignatureReturnType::TypePredicateAnnotation(TypePredicateAnnotation {
					syntax,
				})
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			FunctionSignatureReturnType::Asserts(it) => &it.syntax,
			FunctionSignatureReturnType::TypeAnnotation(it) => &it.syntax,
			FunctionSignatureReturnType::TypePredicateAnnotation(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for FunctionTypeInnerChildren {
	fn from(node: ConstructorType) -> FunctionTypeInnerChildren {
		FunctionTypeInnerChildren::ConstructorType(node)
	}
}
impl From<FormalParameters> for FunctionTypeInnerChildren {
	fn from(node: FormalParameters) -> FunctionTypeInnerChildren {
		FunctionTypeInnerChildren::FormalParameters(node)
	}
}
impl From<FunctionType> for FunctionTypeInnerChildren {
	fn from(node: FunctionType) -> FunctionTypeInnerChildren {
		FunctionTypeInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for FunctionTypeInnerChildren {
	fn from(node: InferType) -> FunctionTypeInnerChildren {
		FunctionTypeInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for FunctionTypeInnerChildren {
	fn from(node: IntersectionType) -> FunctionTypeInnerChildren {
		FunctionTypeInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for FunctionTypeInnerChildren {
	fn from(node: PrimaryType) -> FunctionTypeInnerChildren {
		FunctionTypeInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for FunctionTypeInnerChildren {
	fn from(node: ReadonlyType) -> FunctionTypeInnerChildren {
		FunctionTypeInnerChildren::ReadonlyType(node)
	}
}
impl From<TypeParameters> for FunctionTypeInnerChildren {
	fn from(node: TypeParameters) -> FunctionTypeInnerChildren {
		FunctionTypeInnerChildren::TypeParameters(node)
	}
}
impl From<TypePredicate> for FunctionTypeInnerChildren {
	fn from(node: TypePredicate) -> FunctionTypeInnerChildren {
		FunctionTypeInnerChildren::TypePredicate(node)
	}
}
impl From<UnionType> for FunctionTypeInnerChildren {
	fn from(node: UnionType) -> FunctionTypeInnerChildren {
		FunctionTypeInnerChildren::UnionType(node)
	}
}
impl AstNode for FunctionTypeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FORMAL_PARAMETERS
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::TYPE_PARAMETERS
			| SyntaxKind::TYPE_PREDICATE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				FunctionTypeInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FORMAL_PARAMETERS => {
				FunctionTypeInnerChildren::FormalParameters(FormalParameters { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				FunctionTypeInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => FunctionTypeInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				FunctionTypeInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				FunctionTypeInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::TYPE_PARAMETERS => {
				FunctionTypeInnerChildren::TypeParameters(TypeParameters { syntax })
			}
			SyntaxKind::TYPE_PREDICATE => {
				FunctionTypeInnerChildren::TypePredicate(TypePredicate { syntax })
			}
			SyntaxKind::UNION_TYPE => FunctionTypeInnerChildren::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				FunctionTypeInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			FunctionTypeInnerChildren::ConstructorType(it) => &it.syntax,
			FunctionTypeInnerChildren::FormalParameters(it) => &it.syntax,
			FunctionTypeInnerChildren::FunctionType(it) => &it.syntax,
			FunctionTypeInnerChildren::InferType(it) => &it.syntax,
			FunctionTypeInnerChildren::IntersectionType(it) => &it.syntax,
			FunctionTypeInnerChildren::ReadonlyType(it) => &it.syntax,
			FunctionTypeInnerChildren::TypeParameters(it) => &it.syntax,
			FunctionTypeInnerChildren::TypePredicate(it) => &it.syntax,
			FunctionTypeInnerChildren::UnionType(it) => &it.syntax,
			FunctionTypeInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<Asserts> for GeneratorFunctionDeclarationReturnType {
	fn from(node: Asserts) -> GeneratorFunctionDeclarationReturnType {
		GeneratorFunctionDeclarationReturnType::Asserts(node)
	}
}
impl From<TypeAnnotation> for GeneratorFunctionDeclarationReturnType {
	fn from(node: TypeAnnotation) -> GeneratorFunctionDeclarationReturnType {
		GeneratorFunctionDeclarationReturnType::TypeAnnotation(node)
	}
}
impl From<TypePredicateAnnotation> for GeneratorFunctionDeclarationReturnType {
	fn from(node: TypePredicateAnnotation) -> GeneratorFunctionDeclarationReturnType {
		GeneratorFunctionDeclarationReturnType::TypePredicateAnnotation(node)
	}
}
impl AstNode for GeneratorFunctionDeclarationReturnType {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ASSERTS
			| SyntaxKind::TYPE_ANNOTATION
			| SyntaxKind::TYPE_PREDICATE_ANNOTATION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ASSERTS => {
				GeneratorFunctionDeclarationReturnType::Asserts(Asserts { syntax })
			}
			SyntaxKind::TYPE_ANNOTATION => {
				GeneratorFunctionDeclarationReturnType::TypeAnnotation(TypeAnnotation { syntax })
			}
			SyntaxKind::TYPE_PREDICATE_ANNOTATION => {
				GeneratorFunctionDeclarationReturnType::TypePredicateAnnotation(
					TypePredicateAnnotation { syntax },
				)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			GeneratorFunctionDeclarationReturnType::Asserts(it) => &it.syntax,
			GeneratorFunctionDeclarationReturnType::TypeAnnotation(it) => &it.syntax,
			GeneratorFunctionDeclarationReturnType::TypePredicateAnnotation(it) => &it.syntax,
		}
	}
}
impl From<Asserts> for GeneratorFunctionReturnType {
	fn from(node: Asserts) -> GeneratorFunctionReturnType {
		GeneratorFunctionReturnType::Asserts(node)
	}
}
impl From<TypeAnnotation> for GeneratorFunctionReturnType {
	fn from(node: TypeAnnotation) -> GeneratorFunctionReturnType {
		GeneratorFunctionReturnType::TypeAnnotation(node)
	}
}
impl From<TypePredicateAnnotation> for GeneratorFunctionReturnType {
	fn from(node: TypePredicateAnnotation) -> GeneratorFunctionReturnType {
		GeneratorFunctionReturnType::TypePredicateAnnotation(node)
	}
}
impl AstNode for GeneratorFunctionReturnType {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ASSERTS
			| SyntaxKind::TYPE_ANNOTATION
			| SyntaxKind::TYPE_PREDICATE_ANNOTATION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ASSERTS => GeneratorFunctionReturnType::Asserts(Asserts { syntax }),
			SyntaxKind::TYPE_ANNOTATION => {
				GeneratorFunctionReturnType::TypeAnnotation(TypeAnnotation { syntax })
			}
			SyntaxKind::TYPE_PREDICATE_ANNOTATION => {
				GeneratorFunctionReturnType::TypePredicateAnnotation(TypePredicateAnnotation {
					syntax,
				})
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			GeneratorFunctionReturnType::Asserts(it) => &it.syntax,
			GeneratorFunctionReturnType::TypeAnnotation(it) => &it.syntax,
			GeneratorFunctionReturnType::TypePredicateAnnotation(it) => &it.syntax,
		}
	}
}
impl From<NestedTypeIdentifier> for GenericTypeInnerChildren {
	fn from(node: NestedTypeIdentifier) -> GenericTypeInnerChildren {
		GenericTypeInnerChildren::NestedTypeIdentifier(node)
	}
}
impl From<TypeArguments> for GenericTypeInnerChildren {
	fn from(node: TypeArguments) -> GenericTypeInnerChildren {
		GenericTypeInnerChildren::TypeArguments(node)
	}
}
impl From<TypeIdentifier> for GenericTypeInnerChildren {
	fn from(node: TypeIdentifier) -> GenericTypeInnerChildren {
		GenericTypeInnerChildren::TypeIdentifier(node)
	}
}
impl AstNode for GenericTypeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::NESTED_TYPE_IDENTIFIER
			| SyntaxKind::TYPE_ARGUMENTS
			| SyntaxKind::TYPE_IDENTIFIER => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::NESTED_TYPE_IDENTIFIER => {
				GenericTypeInnerChildren::NestedTypeIdentifier(NestedTypeIdentifier { syntax })
			}
			SyntaxKind::TYPE_ARGUMENTS => {
				GenericTypeInnerChildren::TypeArguments(TypeArguments { syntax })
			}
			SyntaxKind::TYPE_IDENTIFIER => {
				GenericTypeInnerChildren::TypeIdentifier(TypeIdentifier { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			GenericTypeInnerChildren::NestedTypeIdentifier(it) => &it.syntax,
			GenericTypeInnerChildren::TypeArguments(it) => &it.syntax,
			GenericTypeInnerChildren::TypeIdentifier(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for ImplementsClauseInnerChildren {
	fn from(node: ConstructorType) -> ImplementsClauseInnerChildren {
		ImplementsClauseInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for ImplementsClauseInnerChildren {
	fn from(node: FunctionType) -> ImplementsClauseInnerChildren {
		ImplementsClauseInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for ImplementsClauseInnerChildren {
	fn from(node: InferType) -> ImplementsClauseInnerChildren {
		ImplementsClauseInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for ImplementsClauseInnerChildren {
	fn from(node: IntersectionType) -> ImplementsClauseInnerChildren {
		ImplementsClauseInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for ImplementsClauseInnerChildren {
	fn from(node: PrimaryType) -> ImplementsClauseInnerChildren {
		ImplementsClauseInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for ImplementsClauseInnerChildren {
	fn from(node: ReadonlyType) -> ImplementsClauseInnerChildren {
		ImplementsClauseInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for ImplementsClauseInnerChildren {
	fn from(node: UnionType) -> ImplementsClauseInnerChildren {
		ImplementsClauseInnerChildren::UnionType(node)
	}
}
impl AstNode for ImplementsClauseInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				ImplementsClauseInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				ImplementsClauseInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => {
				ImplementsClauseInnerChildren::InferType(InferType { syntax })
			}
			SyntaxKind::INTERSECTION_TYPE => {
				ImplementsClauseInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				ImplementsClauseInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => {
				ImplementsClauseInnerChildren::UnionType(UnionType { syntax })
			}
			kind if PrimaryType::can_cast(kind) => {
				ImplementsClauseInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ImplementsClauseInnerChildren::ConstructorType(it) => &it.syntax,
			ImplementsClauseInnerChildren::FunctionType(it) => &it.syntax,
			ImplementsClauseInnerChildren::InferType(it) => &it.syntax,
			ImplementsClauseInnerChildren::IntersectionType(it) => &it.syntax,
			ImplementsClauseInnerChildren::ReadonlyType(it) => &it.syntax,
			ImplementsClauseInnerChildren::UnionType(it) => &it.syntax,
			ImplementsClauseInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<Identifier> for ImportAliasInnerChildren {
	fn from(node: Identifier) -> ImportAliasInnerChildren {
		ImportAliasInnerChildren::Identifier(node)
	}
}
impl From<NestedIdentifier> for ImportAliasInnerChildren {
	fn from(node: NestedIdentifier) -> ImportAliasInnerChildren {
		ImportAliasInnerChildren::NestedIdentifier(node)
	}
}
impl AstNode for ImportAliasInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::IDENTIFIER | SyntaxKind::NESTED_IDENTIFIER => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::IDENTIFIER => ImportAliasInnerChildren::Identifier(Identifier { syntax }),
			SyntaxKind::NESTED_IDENTIFIER => {
				ImportAliasInnerChildren::NestedIdentifier(NestedIdentifier { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ImportAliasInnerChildren::Identifier(it) => &it.syntax,
			ImportAliasInnerChildren::NestedIdentifier(it) => &it.syntax,
		}
	}
}
impl From<Identifier> for ImportClauseInnerChildren {
	fn from(node: Identifier) -> ImportClauseInnerChildren {
		ImportClauseInnerChildren::Identifier(node)
	}
}
impl From<NamedImports> for ImportClauseInnerChildren {
	fn from(node: NamedImports) -> ImportClauseInnerChildren {
		ImportClauseInnerChildren::NamedImports(node)
	}
}
impl From<NamespaceImport> for ImportClauseInnerChildren {
	fn from(node: NamespaceImport) -> ImportClauseInnerChildren {
		ImportClauseInnerChildren::NamespaceImport(node)
	}
}
impl AstNode for ImportClauseInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::IDENTIFIER | SyntaxKind::NAMED_IMPORTS | SyntaxKind::NAMESPACE_IMPORT => {
				true
			}
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::IDENTIFIER => ImportClauseInnerChildren::Identifier(Identifier { syntax }),
			SyntaxKind::NAMED_IMPORTS => {
				ImportClauseInnerChildren::NamedImports(NamedImports { syntax })
			}
			SyntaxKind::NAMESPACE_IMPORT => {
				ImportClauseInnerChildren::NamespaceImport(NamespaceImport { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ImportClauseInnerChildren::Identifier(it) => &it.syntax,
			ImportClauseInnerChildren::NamedImports(it) => &it.syntax,
			ImportClauseInnerChildren::NamespaceImport(it) => &it.syntax,
		}
	}
}
impl From<Identifier> for ImportRequireClauseInnerChildren {
	fn from(node: Identifier) -> ImportRequireClauseInnerChildren {
		ImportRequireClauseInnerChildren::Identifier(node)
	}
}
impl From<StringLiteral> for ImportRequireClauseInnerChildren {
	fn from(node: StringLiteral) -> ImportRequireClauseInnerChildren {
		ImportRequireClauseInnerChildren::StringLiteral(node)
	}
}
impl AstNode for ImportRequireClauseInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::IDENTIFIER | SyntaxKind::STRING_LITERAL => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::IDENTIFIER => {
				ImportRequireClauseInnerChildren::Identifier(Identifier { syntax })
			}
			SyntaxKind::STRING_LITERAL => {
				ImportRequireClauseInnerChildren::StringLiteral(StringLiteral { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ImportRequireClauseInnerChildren::Identifier(it) => &it.syntax,
			ImportRequireClauseInnerChildren::StringLiteral(it) => &it.syntax,
		}
	}
}
impl From<ImportClause> for ImportStatementInnerChildren {
	fn from(node: ImportClause) -> ImportStatementInnerChildren {
		ImportStatementInnerChildren::ImportClause(node)
	}
}
impl From<ImportRequireClause> for ImportStatementInnerChildren {
	fn from(node: ImportRequireClause) -> ImportStatementInnerChildren {
		ImportStatementInnerChildren::ImportRequireClause(node)
	}
}
impl From<StringLiteral> for ImportStatementInnerChildren {
	fn from(node: StringLiteral) -> ImportStatementInnerChildren {
		ImportStatementInnerChildren::StringLiteral(node)
	}
}
impl AstNode for ImportStatementInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::IMPORT_CLAUSE
			| SyntaxKind::IMPORT_REQUIRE_CLAUSE
			| SyntaxKind::STRING_LITERAL => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::IMPORT_CLAUSE => {
				ImportStatementInnerChildren::ImportClause(ImportClause { syntax })
			}
			SyntaxKind::IMPORT_REQUIRE_CLAUSE => {
				ImportStatementInnerChildren::ImportRequireClause(ImportRequireClause { syntax })
			}
			SyntaxKind::STRING_LITERAL => {
				ImportStatementInnerChildren::StringLiteral(StringLiteral { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ImportStatementInnerChildren::ImportClause(it) => &it.syntax,
			ImportStatementInnerChildren::ImportRequireClause(it) => &it.syntax,
			ImportStatementInnerChildren::StringLiteral(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for IndexSignatureInnerChildren {
	fn from(node: ConstructorType) -> IndexSignatureInnerChildren {
		IndexSignatureInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for IndexSignatureInnerChildren {
	fn from(node: FunctionType) -> IndexSignatureInnerChildren {
		IndexSignatureInnerChildren::FunctionType(node)
	}
}
impl From<Identifier> for IndexSignatureInnerChildren {
	fn from(node: Identifier) -> IndexSignatureInnerChildren {
		IndexSignatureInnerChildren::Identifier(node)
	}
}
impl From<InferType> for IndexSignatureInnerChildren {
	fn from(node: InferType) -> IndexSignatureInnerChildren {
		IndexSignatureInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for IndexSignatureInnerChildren {
	fn from(node: IntersectionType) -> IndexSignatureInnerChildren {
		IndexSignatureInnerChildren::IntersectionType(node)
	}
}
impl From<MappedTypeClause> for IndexSignatureInnerChildren {
	fn from(node: MappedTypeClause) -> IndexSignatureInnerChildren {
		IndexSignatureInnerChildren::MappedTypeClause(node)
	}
}
impl From<OmittingTypeAnnotation> for IndexSignatureInnerChildren {
	fn from(node: OmittingTypeAnnotation) -> IndexSignatureInnerChildren {
		IndexSignatureInnerChildren::OmittingTypeAnnotation(node)
	}
}
impl From<OptingTypeAnnotation> for IndexSignatureInnerChildren {
	fn from(node: OptingTypeAnnotation) -> IndexSignatureInnerChildren {
		IndexSignatureInnerChildren::OptingTypeAnnotation(node)
	}
}
impl From<PrimaryType> for IndexSignatureInnerChildren {
	fn from(node: PrimaryType) -> IndexSignatureInnerChildren {
		IndexSignatureInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for IndexSignatureInnerChildren {
	fn from(node: ReadonlyType) -> IndexSignatureInnerChildren {
		IndexSignatureInnerChildren::ReadonlyType(node)
	}
}
impl From<TypeAnnotation> for IndexSignatureInnerChildren {
	fn from(node: TypeAnnotation) -> IndexSignatureInnerChildren {
		IndexSignatureInnerChildren::TypeAnnotation(node)
	}
}
impl From<UnionType> for IndexSignatureInnerChildren {
	fn from(node: UnionType) -> IndexSignatureInnerChildren {
		IndexSignatureInnerChildren::UnionType(node)
	}
}
impl AstNode for IndexSignatureInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::IDENTIFIER
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::MAPPED_TYPE_CLAUSE
			| SyntaxKind::OMITTING_TYPE_ANNOTATION
			| SyntaxKind::OPTING_TYPE_ANNOTATION
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::TYPE_ANNOTATION
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				IndexSignatureInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				IndexSignatureInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::IDENTIFIER => {
				IndexSignatureInnerChildren::Identifier(Identifier { syntax })
			}
			SyntaxKind::INFER_TYPE => IndexSignatureInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				IndexSignatureInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::MAPPED_TYPE_CLAUSE => {
				IndexSignatureInnerChildren::MappedTypeClause(MappedTypeClause { syntax })
			}
			SyntaxKind::OMITTING_TYPE_ANNOTATION => {
				IndexSignatureInnerChildren::OmittingTypeAnnotation(OmittingTypeAnnotation {
					syntax,
				})
			}
			SyntaxKind::OPTING_TYPE_ANNOTATION => {
				IndexSignatureInnerChildren::OptingTypeAnnotation(OptingTypeAnnotation { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				IndexSignatureInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::TYPE_ANNOTATION => {
				IndexSignatureInnerChildren::TypeAnnotation(TypeAnnotation { syntax })
			}
			SyntaxKind::UNION_TYPE => IndexSignatureInnerChildren::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				IndexSignatureInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			IndexSignatureInnerChildren::ConstructorType(it) => &it.syntax,
			IndexSignatureInnerChildren::FunctionType(it) => &it.syntax,
			IndexSignatureInnerChildren::Identifier(it) => &it.syntax,
			IndexSignatureInnerChildren::InferType(it) => &it.syntax,
			IndexSignatureInnerChildren::IntersectionType(it) => &it.syntax,
			IndexSignatureInnerChildren::MappedTypeClause(it) => &it.syntax,
			IndexSignatureInnerChildren::OmittingTypeAnnotation(it) => &it.syntax,
			IndexSignatureInnerChildren::OptingTypeAnnotation(it) => &it.syntax,
			IndexSignatureInnerChildren::ReadonlyType(it) => &it.syntax,
			IndexSignatureInnerChildren::TypeAnnotation(it) => &it.syntax,
			IndexSignatureInnerChildren::UnionType(it) => &it.syntax,
			IndexSignatureInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<GenericType> for IndexTypeQueryInnerChildren {
	fn from(node: GenericType) -> IndexTypeQueryInnerChildren {
		IndexTypeQueryInnerChildren::GenericType(node)
	}
}
impl From<NestedTypeIdentifier> for IndexTypeQueryInnerChildren {
	fn from(node: NestedTypeIdentifier) -> IndexTypeQueryInnerChildren {
		IndexTypeQueryInnerChildren::NestedTypeIdentifier(node)
	}
}
impl From<TypeIdentifier> for IndexTypeQueryInnerChildren {
	fn from(node: TypeIdentifier) -> IndexTypeQueryInnerChildren {
		IndexTypeQueryInnerChildren::TypeIdentifier(node)
	}
}
impl From<TypeQuery> for IndexTypeQueryInnerChildren {
	fn from(node: TypeQuery) -> IndexTypeQueryInnerChildren {
		IndexTypeQueryInnerChildren::TypeQuery(node)
	}
}
impl AstNode for IndexTypeQueryInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::GENERIC_TYPE
			| SyntaxKind::NESTED_TYPE_IDENTIFIER
			| SyntaxKind::TYPE_IDENTIFIER
			| SyntaxKind::TYPE_QUERY => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::GENERIC_TYPE => {
				IndexTypeQueryInnerChildren::GenericType(GenericType { syntax })
			}
			SyntaxKind::NESTED_TYPE_IDENTIFIER => {
				IndexTypeQueryInnerChildren::NestedTypeIdentifier(NestedTypeIdentifier { syntax })
			}
			SyntaxKind::TYPE_IDENTIFIER => {
				IndexTypeQueryInnerChildren::TypeIdentifier(TypeIdentifier { syntax })
			}
			SyntaxKind::TYPE_QUERY => IndexTypeQueryInnerChildren::TypeQuery(TypeQuery { syntax }),
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			IndexTypeQueryInnerChildren::GenericType(it) => &it.syntax,
			IndexTypeQueryInnerChildren::NestedTypeIdentifier(it) => &it.syntax,
			IndexTypeQueryInnerChildren::TypeIdentifier(it) => &it.syntax,
			IndexTypeQueryInnerChildren::TypeQuery(it) => &it.syntax,
		}
	}
}
impl From<Identifier> for InternalModuleName {
	fn from(node: Identifier) -> InternalModuleName {
		InternalModuleName::Identifier(node)
	}
}
impl From<NestedIdentifier> for InternalModuleName {
	fn from(node: NestedIdentifier) -> InternalModuleName {
		InternalModuleName::NestedIdentifier(node)
	}
}
impl From<StringLiteral> for InternalModuleName {
	fn from(node: StringLiteral) -> InternalModuleName {
		InternalModuleName::StringLiteral(node)
	}
}
impl AstNode for InternalModuleName {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::IDENTIFIER | SyntaxKind::NESTED_IDENTIFIER | SyntaxKind::STRING_LITERAL => {
				true
			}
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::IDENTIFIER => InternalModuleName::Identifier(Identifier { syntax }),
			SyntaxKind::NESTED_IDENTIFIER => {
				InternalModuleName::NestedIdentifier(NestedIdentifier { syntax })
			}
			SyntaxKind::STRING_LITERAL => {
				InternalModuleName::StringLiteral(StringLiteral { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			InternalModuleName::Identifier(it) => &it.syntax,
			InternalModuleName::NestedIdentifier(it) => &it.syntax,
			InternalModuleName::StringLiteral(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for IntersectionTypeInnerChildren {
	fn from(node: ConstructorType) -> IntersectionTypeInnerChildren {
		IntersectionTypeInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for IntersectionTypeInnerChildren {
	fn from(node: FunctionType) -> IntersectionTypeInnerChildren {
		IntersectionTypeInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for IntersectionTypeInnerChildren {
	fn from(node: InferType) -> IntersectionTypeInnerChildren {
		IntersectionTypeInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for IntersectionTypeInnerChildren {
	fn from(node: IntersectionType) -> IntersectionTypeInnerChildren {
		IntersectionTypeInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for IntersectionTypeInnerChildren {
	fn from(node: PrimaryType) -> IntersectionTypeInnerChildren {
		IntersectionTypeInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for IntersectionTypeInnerChildren {
	fn from(node: ReadonlyType) -> IntersectionTypeInnerChildren {
		IntersectionTypeInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for IntersectionTypeInnerChildren {
	fn from(node: UnionType) -> IntersectionTypeInnerChildren {
		IntersectionTypeInnerChildren::UnionType(node)
	}
}
impl AstNode for IntersectionTypeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				IntersectionTypeInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				IntersectionTypeInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => {
				IntersectionTypeInnerChildren::InferType(InferType { syntax })
			}
			SyntaxKind::INTERSECTION_TYPE => {
				IntersectionTypeInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				IntersectionTypeInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => {
				IntersectionTypeInnerChildren::UnionType(UnionType { syntax })
			}
			kind if PrimaryType::can_cast(kind) => {
				IntersectionTypeInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			IntersectionTypeInnerChildren::ConstructorType(it) => &it.syntax,
			IntersectionTypeInnerChildren::FunctionType(it) => &it.syntax,
			IntersectionTypeInnerChildren::InferType(it) => &it.syntax,
			IntersectionTypeInnerChildren::IntersectionType(it) => &it.syntax,
			IntersectionTypeInnerChildren::ReadonlyType(it) => &it.syntax,
			IntersectionTypeInnerChildren::UnionType(it) => &it.syntax,
			IntersectionTypeInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<JsxElement> for JsxAttributeInnerChildren {
	fn from(node: JsxElement) -> JsxAttributeInnerChildren {
		JsxAttributeInnerChildren::JsxElement(node)
	}
}
impl From<JsxExpression> for JsxAttributeInnerChildren {
	fn from(node: JsxExpression) -> JsxAttributeInnerChildren {
		JsxAttributeInnerChildren::JsxExpression(node)
	}
}
impl From<JsxFragment> for JsxAttributeInnerChildren {
	fn from(node: JsxFragment) -> JsxAttributeInnerChildren {
		JsxAttributeInnerChildren::JsxFragment(node)
	}
}
impl From<JsxNamespaceName> for JsxAttributeInnerChildren {
	fn from(node: JsxNamespaceName) -> JsxAttributeInnerChildren {
		JsxAttributeInnerChildren::JsxNamespaceName(node)
	}
}
impl From<JsxSelfClosingElement> for JsxAttributeInnerChildren {
	fn from(node: JsxSelfClosingElement) -> JsxAttributeInnerChildren {
		JsxAttributeInnerChildren::JsxSelfClosingElement(node)
	}
}
impl From<PropertyIdentifier> for JsxAttributeInnerChildren {
	fn from(node: PropertyIdentifier) -> JsxAttributeInnerChildren {
		JsxAttributeInnerChildren::PropertyIdentifier(node)
	}
}
impl From<StringLiteral> for JsxAttributeInnerChildren {
	fn from(node: StringLiteral) -> JsxAttributeInnerChildren {
		JsxAttributeInnerChildren::StringLiteral(node)
	}
}
impl AstNode for JsxAttributeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::JSX_ELEMENT
			| SyntaxKind::JSX_EXPRESSION
			| SyntaxKind::JSX_FRAGMENT
			| SyntaxKind::JSX_NAMESPACE_NAME
			| SyntaxKind::JSX_SELF_CLOSING_ELEMENT
			| SyntaxKind::PROPERTY_IDENTIFIER
			| SyntaxKind::STRING_LITERAL => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::JSX_ELEMENT => JsxAttributeInnerChildren::JsxElement(JsxElement { syntax }),
			SyntaxKind::JSX_EXPRESSION => {
				JsxAttributeInnerChildren::JsxExpression(JsxExpression { syntax })
			}
			SyntaxKind::JSX_FRAGMENT => {
				JsxAttributeInnerChildren::JsxFragment(JsxFragment { syntax })
			}
			SyntaxKind::JSX_NAMESPACE_NAME => {
				JsxAttributeInnerChildren::JsxNamespaceName(JsxNamespaceName { syntax })
			}
			SyntaxKind::JSX_SELF_CLOSING_ELEMENT => {
				JsxAttributeInnerChildren::JsxSelfClosingElement(JsxSelfClosingElement { syntax })
			}
			SyntaxKind::PROPERTY_IDENTIFIER => {
				JsxAttributeInnerChildren::PropertyIdentifier(PropertyIdentifier { syntax })
			}
			SyntaxKind::STRING_LITERAL => {
				JsxAttributeInnerChildren::StringLiteral(StringLiteral { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			JsxAttributeInnerChildren::JsxElement(it) => &it.syntax,
			JsxAttributeInnerChildren::JsxExpression(it) => &it.syntax,
			JsxAttributeInnerChildren::JsxFragment(it) => &it.syntax,
			JsxAttributeInnerChildren::JsxNamespaceName(it) => &it.syntax,
			JsxAttributeInnerChildren::JsxSelfClosingElement(it) => &it.syntax,
			JsxAttributeInnerChildren::PropertyIdentifier(it) => &it.syntax,
			JsxAttributeInnerChildren::StringLiteral(it) => &it.syntax,
		}
	}
}
impl From<Identifier> for JsxClosingElementName {
	fn from(node: Identifier) -> JsxClosingElementName {
		JsxClosingElementName::Identifier(node)
	}
}
impl From<JsxNamespaceName> for JsxClosingElementName {
	fn from(node: JsxNamespaceName) -> JsxClosingElementName {
		JsxClosingElementName::JsxNamespaceName(node)
	}
}
impl From<NestedIdentifier> for JsxClosingElementName {
	fn from(node: NestedIdentifier) -> JsxClosingElementName {
		JsxClosingElementName::NestedIdentifier(node)
	}
}
impl AstNode for JsxClosingElementName {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::IDENTIFIER
			| SyntaxKind::JSX_NAMESPACE_NAME
			| SyntaxKind::NESTED_IDENTIFIER => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::IDENTIFIER => JsxClosingElementName::Identifier(Identifier { syntax }),
			SyntaxKind::JSX_NAMESPACE_NAME => {
				JsxClosingElementName::JsxNamespaceName(JsxNamespaceName { syntax })
			}
			SyntaxKind::NESTED_IDENTIFIER => {
				JsxClosingElementName::NestedIdentifier(NestedIdentifier { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			JsxClosingElementName::Identifier(it) => &it.syntax,
			JsxClosingElementName::JsxNamespaceName(it) => &it.syntax,
			JsxClosingElementName::NestedIdentifier(it) => &it.syntax,
		}
	}
}
impl From<JsxElement> for JsxElementInnerChildren {
	fn from(node: JsxElement) -> JsxElementInnerChildren {
		JsxElementInnerChildren::JsxElement(node)
	}
}
impl From<JsxExpression> for JsxElementInnerChildren {
	fn from(node: JsxExpression) -> JsxElementInnerChildren {
		JsxElementInnerChildren::JsxExpression(node)
	}
}
impl From<JsxFragment> for JsxElementInnerChildren {
	fn from(node: JsxFragment) -> JsxElementInnerChildren {
		JsxElementInnerChildren::JsxFragment(node)
	}
}
impl From<JsxSelfClosingElement> for JsxElementInnerChildren {
	fn from(node: JsxSelfClosingElement) -> JsxElementInnerChildren {
		JsxElementInnerChildren::JsxSelfClosingElement(node)
	}
}
impl From<JsxText> for JsxElementInnerChildren {
	fn from(node: JsxText) -> JsxElementInnerChildren {
		JsxElementInnerChildren::JsxText(node)
	}
}
impl AstNode for JsxElementInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::JSX_ELEMENT
			| SyntaxKind::JSX_EXPRESSION
			| SyntaxKind::JSX_FRAGMENT
			| SyntaxKind::JSX_SELF_CLOSING_ELEMENT
			| SyntaxKind::JSX_TEXT => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::JSX_ELEMENT => JsxElementInnerChildren::JsxElement(JsxElement { syntax }),
			SyntaxKind::JSX_EXPRESSION => {
				JsxElementInnerChildren::JsxExpression(JsxExpression { syntax })
			}
			SyntaxKind::JSX_FRAGMENT => {
				JsxElementInnerChildren::JsxFragment(JsxFragment { syntax })
			}
			SyntaxKind::JSX_SELF_CLOSING_ELEMENT => {
				JsxElementInnerChildren::JsxSelfClosingElement(JsxSelfClosingElement { syntax })
			}
			SyntaxKind::JSX_TEXT => JsxElementInnerChildren::JsxText(JsxText { syntax }),
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			JsxElementInnerChildren::JsxElement(it) => &it.syntax,
			JsxElementInnerChildren::JsxExpression(it) => &it.syntax,
			JsxElementInnerChildren::JsxFragment(it) => &it.syntax,
			JsxElementInnerChildren::JsxSelfClosingElement(it) => &it.syntax,
			JsxElementInnerChildren::JsxText(it) => &it.syntax,
		}
	}
}
impl From<Expression> for JsxExpressionInnerChildren {
	fn from(node: Expression) -> JsxExpressionInnerChildren {
		JsxExpressionInnerChildren::Expression(node)
	}
}
impl From<SequenceExpression> for JsxExpressionInnerChildren {
	fn from(node: SequenceExpression) -> JsxExpressionInnerChildren {
		JsxExpressionInnerChildren::SequenceExpression(node)
	}
}
impl From<SpreadElement> for JsxExpressionInnerChildren {
	fn from(node: SpreadElement) -> JsxExpressionInnerChildren {
		JsxExpressionInnerChildren::SpreadElement(node)
	}
}
impl AstNode for JsxExpressionInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::SEQUENCE_EXPRESSION | SyntaxKind::SPREAD_ELEMENT => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::SEQUENCE_EXPRESSION => {
				JsxExpressionInnerChildren::SequenceExpression(SequenceExpression { syntax })
			}
			SyntaxKind::SPREAD_ELEMENT => {
				JsxExpressionInnerChildren::SpreadElement(SpreadElement { syntax })
			}
			kind if Expression::can_cast(kind) => {
				JsxExpressionInnerChildren::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			JsxExpressionInnerChildren::SequenceExpression(it) => &it.syntax,
			JsxExpressionInnerChildren::SpreadElement(it) => &it.syntax,
			JsxExpressionInnerChildren::Expression(it) => &it.syntax(),
		}
	}
}
impl From<JsxElement> for JsxFragmentInnerChildren {
	fn from(node: JsxElement) -> JsxFragmentInnerChildren {
		JsxFragmentInnerChildren::JsxElement(node)
	}
}
impl From<JsxExpression> for JsxFragmentInnerChildren {
	fn from(node: JsxExpression) -> JsxFragmentInnerChildren {
		JsxFragmentInnerChildren::JsxExpression(node)
	}
}
impl From<JsxFragment> for JsxFragmentInnerChildren {
	fn from(node: JsxFragment) -> JsxFragmentInnerChildren {
		JsxFragmentInnerChildren::JsxFragment(node)
	}
}
impl From<JsxSelfClosingElement> for JsxFragmentInnerChildren {
	fn from(node: JsxSelfClosingElement) -> JsxFragmentInnerChildren {
		JsxFragmentInnerChildren::JsxSelfClosingElement(node)
	}
}
impl From<JsxText> for JsxFragmentInnerChildren {
	fn from(node: JsxText) -> JsxFragmentInnerChildren {
		JsxFragmentInnerChildren::JsxText(node)
	}
}
impl AstNode for JsxFragmentInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::JSX_ELEMENT
			| SyntaxKind::JSX_EXPRESSION
			| SyntaxKind::JSX_FRAGMENT
			| SyntaxKind::JSX_SELF_CLOSING_ELEMENT
			| SyntaxKind::JSX_TEXT => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::JSX_ELEMENT => JsxFragmentInnerChildren::JsxElement(JsxElement { syntax }),
			SyntaxKind::JSX_EXPRESSION => {
				JsxFragmentInnerChildren::JsxExpression(JsxExpression { syntax })
			}
			SyntaxKind::JSX_FRAGMENT => {
				JsxFragmentInnerChildren::JsxFragment(JsxFragment { syntax })
			}
			SyntaxKind::JSX_SELF_CLOSING_ELEMENT => {
				JsxFragmentInnerChildren::JsxSelfClosingElement(JsxSelfClosingElement { syntax })
			}
			SyntaxKind::JSX_TEXT => JsxFragmentInnerChildren::JsxText(JsxText { syntax }),
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			JsxFragmentInnerChildren::JsxElement(it) => &it.syntax,
			JsxFragmentInnerChildren::JsxExpression(it) => &it.syntax,
			JsxFragmentInnerChildren::JsxFragment(it) => &it.syntax,
			JsxFragmentInnerChildren::JsxSelfClosingElement(it) => &it.syntax,
			JsxFragmentInnerChildren::JsxText(it) => &it.syntax,
		}
	}
}
impl From<JsxAttribute> for JsxOpeningElementAttribute {
	fn from(node: JsxAttribute) -> JsxOpeningElementAttribute {
		JsxOpeningElementAttribute::JsxAttribute(node)
	}
}
impl From<JsxExpression> for JsxOpeningElementAttribute {
	fn from(node: JsxExpression) -> JsxOpeningElementAttribute {
		JsxOpeningElementAttribute::JsxExpression(node)
	}
}
impl AstNode for JsxOpeningElementAttribute {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::JSX_ATTRIBUTE | SyntaxKind::JSX_EXPRESSION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::JSX_ATTRIBUTE => {
				JsxOpeningElementAttribute::JsxAttribute(JsxAttribute { syntax })
			}
			SyntaxKind::JSX_EXPRESSION => {
				JsxOpeningElementAttribute::JsxExpression(JsxExpression { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			JsxOpeningElementAttribute::JsxAttribute(it) => &it.syntax,
			JsxOpeningElementAttribute::JsxExpression(it) => &it.syntax,
		}
	}
}
impl From<Identifier> for JsxOpeningElementName {
	fn from(node: Identifier) -> JsxOpeningElementName {
		JsxOpeningElementName::Identifier(node)
	}
}
impl From<JsxNamespaceName> for JsxOpeningElementName {
	fn from(node: JsxNamespaceName) -> JsxOpeningElementName {
		JsxOpeningElementName::JsxNamespaceName(node)
	}
}
impl From<NestedIdentifier> for JsxOpeningElementName {
	fn from(node: NestedIdentifier) -> JsxOpeningElementName {
		JsxOpeningElementName::NestedIdentifier(node)
	}
}
impl AstNode for JsxOpeningElementName {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::IDENTIFIER
			| SyntaxKind::JSX_NAMESPACE_NAME
			| SyntaxKind::NESTED_IDENTIFIER => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::IDENTIFIER => JsxOpeningElementName::Identifier(Identifier { syntax }),
			SyntaxKind::JSX_NAMESPACE_NAME => {
				JsxOpeningElementName::JsxNamespaceName(JsxNamespaceName { syntax })
			}
			SyntaxKind::NESTED_IDENTIFIER => {
				JsxOpeningElementName::NestedIdentifier(NestedIdentifier { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			JsxOpeningElementName::Identifier(it) => &it.syntax,
			JsxOpeningElementName::JsxNamespaceName(it) => &it.syntax,
			JsxOpeningElementName::NestedIdentifier(it) => &it.syntax,
		}
	}
}
impl From<JsxAttribute> for JsxSelfClosingElementAttribute {
	fn from(node: JsxAttribute) -> JsxSelfClosingElementAttribute {
		JsxSelfClosingElementAttribute::JsxAttribute(node)
	}
}
impl From<JsxExpression> for JsxSelfClosingElementAttribute {
	fn from(node: JsxExpression) -> JsxSelfClosingElementAttribute {
		JsxSelfClosingElementAttribute::JsxExpression(node)
	}
}
impl AstNode for JsxSelfClosingElementAttribute {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::JSX_ATTRIBUTE | SyntaxKind::JSX_EXPRESSION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::JSX_ATTRIBUTE => {
				JsxSelfClosingElementAttribute::JsxAttribute(JsxAttribute { syntax })
			}
			SyntaxKind::JSX_EXPRESSION => {
				JsxSelfClosingElementAttribute::JsxExpression(JsxExpression { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			JsxSelfClosingElementAttribute::JsxAttribute(it) => &it.syntax,
			JsxSelfClosingElementAttribute::JsxExpression(it) => &it.syntax,
		}
	}
}
impl From<Identifier> for JsxSelfClosingElementName {
	fn from(node: Identifier) -> JsxSelfClosingElementName {
		JsxSelfClosingElementName::Identifier(node)
	}
}
impl From<JsxNamespaceName> for JsxSelfClosingElementName {
	fn from(node: JsxNamespaceName) -> JsxSelfClosingElementName {
		JsxSelfClosingElementName::JsxNamespaceName(node)
	}
}
impl From<NestedIdentifier> for JsxSelfClosingElementName {
	fn from(node: NestedIdentifier) -> JsxSelfClosingElementName {
		JsxSelfClosingElementName::NestedIdentifier(node)
	}
}
impl AstNode for JsxSelfClosingElementName {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::IDENTIFIER
			| SyntaxKind::JSX_NAMESPACE_NAME
			| SyntaxKind::NESTED_IDENTIFIER => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::IDENTIFIER => JsxSelfClosingElementName::Identifier(Identifier { syntax }),
			SyntaxKind::JSX_NAMESPACE_NAME => {
				JsxSelfClosingElementName::JsxNamespaceName(JsxNamespaceName { syntax })
			}
			SyntaxKind::NESTED_IDENTIFIER => {
				JsxSelfClosingElementName::NestedIdentifier(NestedIdentifier { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			JsxSelfClosingElementName::Identifier(it) => &it.syntax,
			JsxSelfClosingElementName::JsxNamespaceName(it) => &it.syntax,
			JsxSelfClosingElementName::NestedIdentifier(it) => &it.syntax,
		}
	}
}
impl From<False> for LiteralTypeInnerChildren {
	fn from(node: False) -> LiteralTypeInnerChildren {
		LiteralTypeInnerChildren::False(node)
	}
}
impl From<Number> for LiteralTypeInnerChildren {
	fn from(node: Number) -> LiteralTypeInnerChildren {
		LiteralTypeInnerChildren::Number(node)
	}
}
impl From<StringLiteral> for LiteralTypeInnerChildren {
	fn from(node: StringLiteral) -> LiteralTypeInnerChildren {
		LiteralTypeInnerChildren::StringLiteral(node)
	}
}
impl From<True> for LiteralTypeInnerChildren {
	fn from(node: True) -> LiteralTypeInnerChildren {
		LiteralTypeInnerChildren::True(node)
	}
}
impl From<UnaryExpression> for LiteralTypeInnerChildren {
	fn from(node: UnaryExpression) -> LiteralTypeInnerChildren {
		LiteralTypeInnerChildren::UnaryExpression(node)
	}
}
impl AstNode for LiteralTypeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::FALSE
			| SyntaxKind::NUMBER
			| SyntaxKind::STRING_LITERAL
			| SyntaxKind::TRUE
			| SyntaxKind::UNARY_EXPRESSION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::FALSE => LiteralTypeInnerChildren::False(False { syntax }),
			SyntaxKind::NUMBER => LiteralTypeInnerChildren::Number(Number { syntax }),
			SyntaxKind::STRING_LITERAL => {
				LiteralTypeInnerChildren::StringLiteral(StringLiteral { syntax })
			}
			SyntaxKind::TRUE => LiteralTypeInnerChildren::True(True { syntax }),
			SyntaxKind::UNARY_EXPRESSION => {
				LiteralTypeInnerChildren::UnaryExpression(UnaryExpression { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			LiteralTypeInnerChildren::False(it) => &it.syntax,
			LiteralTypeInnerChildren::Number(it) => &it.syntax,
			LiteralTypeInnerChildren::StringLiteral(it) => &it.syntax,
			LiteralTypeInnerChildren::True(it) => &it.syntax,
			LiteralTypeInnerChildren::UnaryExpression(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for LookupTypeInnerChildren {
	fn from(node: ConstructorType) -> LookupTypeInnerChildren {
		LookupTypeInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for LookupTypeInnerChildren {
	fn from(node: FunctionType) -> LookupTypeInnerChildren {
		LookupTypeInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for LookupTypeInnerChildren {
	fn from(node: InferType) -> LookupTypeInnerChildren {
		LookupTypeInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for LookupTypeInnerChildren {
	fn from(node: IntersectionType) -> LookupTypeInnerChildren {
		LookupTypeInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for LookupTypeInnerChildren {
	fn from(node: PrimaryType) -> LookupTypeInnerChildren {
		LookupTypeInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for LookupTypeInnerChildren {
	fn from(node: ReadonlyType) -> LookupTypeInnerChildren {
		LookupTypeInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for LookupTypeInnerChildren {
	fn from(node: UnionType) -> LookupTypeInnerChildren {
		LookupTypeInnerChildren::UnionType(node)
	}
}
impl AstNode for LookupTypeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				LookupTypeInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				LookupTypeInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => LookupTypeInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				LookupTypeInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				LookupTypeInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => LookupTypeInnerChildren::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				LookupTypeInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			LookupTypeInnerChildren::ConstructorType(it) => &it.syntax,
			LookupTypeInnerChildren::FunctionType(it) => &it.syntax,
			LookupTypeInnerChildren::InferType(it) => &it.syntax,
			LookupTypeInnerChildren::IntersectionType(it) => &it.syntax,
			LookupTypeInnerChildren::ReadonlyType(it) => &it.syntax,
			LookupTypeInnerChildren::UnionType(it) => &it.syntax,
			LookupTypeInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<ConstructorType> for MappedTypeClauseInnerChildren {
	fn from(node: ConstructorType) -> MappedTypeClauseInnerChildren {
		MappedTypeClauseInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for MappedTypeClauseInnerChildren {
	fn from(node: FunctionType) -> MappedTypeClauseInnerChildren {
		MappedTypeClauseInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for MappedTypeClauseInnerChildren {
	fn from(node: InferType) -> MappedTypeClauseInnerChildren {
		MappedTypeClauseInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for MappedTypeClauseInnerChildren {
	fn from(node: IntersectionType) -> MappedTypeClauseInnerChildren {
		MappedTypeClauseInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for MappedTypeClauseInnerChildren {
	fn from(node: PrimaryType) -> MappedTypeClauseInnerChildren {
		MappedTypeClauseInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for MappedTypeClauseInnerChildren {
	fn from(node: ReadonlyType) -> MappedTypeClauseInnerChildren {
		MappedTypeClauseInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for MappedTypeClauseInnerChildren {
	fn from(node: UnionType) -> MappedTypeClauseInnerChildren {
		MappedTypeClauseInnerChildren::UnionType(node)
	}
}
impl AstNode for MappedTypeClauseInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				MappedTypeClauseInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				MappedTypeClauseInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => {
				MappedTypeClauseInnerChildren::InferType(InferType { syntax })
			}
			SyntaxKind::INTERSECTION_TYPE => {
				MappedTypeClauseInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				MappedTypeClauseInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => {
				MappedTypeClauseInnerChildren::UnionType(UnionType { syntax })
			}
			kind if PrimaryType::can_cast(kind) => {
				MappedTypeClauseInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			MappedTypeClauseInnerChildren::ConstructorType(it) => &it.syntax,
			MappedTypeClauseInnerChildren::FunctionType(it) => &it.syntax,
			MappedTypeClauseInnerChildren::InferType(it) => &it.syntax,
			MappedTypeClauseInnerChildren::IntersectionType(it) => &it.syntax,
			MappedTypeClauseInnerChildren::ReadonlyType(it) => &it.syntax,
			MappedTypeClauseInnerChildren::UnionType(it) => &it.syntax,
			MappedTypeClauseInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<ComputedPropertyName> for MethodDefinitionName {
	fn from(node: ComputedPropertyName) -> MethodDefinitionName {
		MethodDefinitionName::ComputedPropertyName(node)
	}
}
impl From<Number> for MethodDefinitionName {
	fn from(node: Number) -> MethodDefinitionName {
		MethodDefinitionName::Number(node)
	}
}
impl From<PropertyIdentifier> for MethodDefinitionName {
	fn from(node: PropertyIdentifier) -> MethodDefinitionName {
		MethodDefinitionName::PropertyIdentifier(node)
	}
}
impl From<StringLiteral> for MethodDefinitionName {
	fn from(node: StringLiteral) -> MethodDefinitionName {
		MethodDefinitionName::StringLiteral(node)
	}
}
impl AstNode for MethodDefinitionName {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::COMPUTED_PROPERTY_NAME
			| SyntaxKind::NUMBER
			| SyntaxKind::PROPERTY_IDENTIFIER
			| SyntaxKind::STRING_LITERAL => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::COMPUTED_PROPERTY_NAME => {
				MethodDefinitionName::ComputedPropertyName(ComputedPropertyName { syntax })
			}
			SyntaxKind::NUMBER => MethodDefinitionName::Number(Number { syntax }),
			SyntaxKind::PROPERTY_IDENTIFIER => {
				MethodDefinitionName::PropertyIdentifier(PropertyIdentifier { syntax })
			}
			SyntaxKind::STRING_LITERAL => {
				MethodDefinitionName::StringLiteral(StringLiteral { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			MethodDefinitionName::ComputedPropertyName(it) => &it.syntax,
			MethodDefinitionName::Number(it) => &it.syntax,
			MethodDefinitionName::PropertyIdentifier(it) => &it.syntax,
			MethodDefinitionName::StringLiteral(it) => &it.syntax,
		}
	}
}
impl From<Asserts> for MethodDefinitionReturnType {
	fn from(node: Asserts) -> MethodDefinitionReturnType {
		MethodDefinitionReturnType::Asserts(node)
	}
}
impl From<TypeAnnotation> for MethodDefinitionReturnType {
	fn from(node: TypeAnnotation) -> MethodDefinitionReturnType {
		MethodDefinitionReturnType::TypeAnnotation(node)
	}
}
impl From<TypePredicateAnnotation> for MethodDefinitionReturnType {
	fn from(node: TypePredicateAnnotation) -> MethodDefinitionReturnType {
		MethodDefinitionReturnType::TypePredicateAnnotation(node)
	}
}
impl AstNode for MethodDefinitionReturnType {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ASSERTS
			| SyntaxKind::TYPE_ANNOTATION
			| SyntaxKind::TYPE_PREDICATE_ANNOTATION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ASSERTS => MethodDefinitionReturnType::Asserts(Asserts { syntax }),
			SyntaxKind::TYPE_ANNOTATION => {
				MethodDefinitionReturnType::TypeAnnotation(TypeAnnotation { syntax })
			}
			SyntaxKind::TYPE_PREDICATE_ANNOTATION => {
				MethodDefinitionReturnType::TypePredicateAnnotation(TypePredicateAnnotation {
					syntax,
				})
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			MethodDefinitionReturnType::Asserts(it) => &it.syntax,
			MethodDefinitionReturnType::TypeAnnotation(it) => &it.syntax,
			MethodDefinitionReturnType::TypePredicateAnnotation(it) => &it.syntax,
		}
	}
}
impl From<ComputedPropertyName> for MethodSignatureName {
	fn from(node: ComputedPropertyName) -> MethodSignatureName {
		MethodSignatureName::ComputedPropertyName(node)
	}
}
impl From<Number> for MethodSignatureName {
	fn from(node: Number) -> MethodSignatureName {
		MethodSignatureName::Number(node)
	}
}
impl From<PropertyIdentifier> for MethodSignatureName {
	fn from(node: PropertyIdentifier) -> MethodSignatureName {
		MethodSignatureName::PropertyIdentifier(node)
	}
}
impl From<StringLiteral> for MethodSignatureName {
	fn from(node: StringLiteral) -> MethodSignatureName {
		MethodSignatureName::StringLiteral(node)
	}
}
impl AstNode for MethodSignatureName {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::COMPUTED_PROPERTY_NAME
			| SyntaxKind::NUMBER
			| SyntaxKind::PROPERTY_IDENTIFIER
			| SyntaxKind::STRING_LITERAL => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::COMPUTED_PROPERTY_NAME => {
				MethodSignatureName::ComputedPropertyName(ComputedPropertyName { syntax })
			}
			SyntaxKind::NUMBER => MethodSignatureName::Number(Number { syntax }),
			SyntaxKind::PROPERTY_IDENTIFIER => {
				MethodSignatureName::PropertyIdentifier(PropertyIdentifier { syntax })
			}
			SyntaxKind::STRING_LITERAL => {
				MethodSignatureName::StringLiteral(StringLiteral { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			MethodSignatureName::ComputedPropertyName(it) => &it.syntax,
			MethodSignatureName::Number(it) => &it.syntax,
			MethodSignatureName::PropertyIdentifier(it) => &it.syntax,
			MethodSignatureName::StringLiteral(it) => &it.syntax,
		}
	}
}
impl From<Asserts> for MethodSignatureReturnType {
	fn from(node: Asserts) -> MethodSignatureReturnType {
		MethodSignatureReturnType::Asserts(node)
	}
}
impl From<TypeAnnotation> for MethodSignatureReturnType {
	fn from(node: TypeAnnotation) -> MethodSignatureReturnType {
		MethodSignatureReturnType::TypeAnnotation(node)
	}
}
impl From<TypePredicateAnnotation> for MethodSignatureReturnType {
	fn from(node: TypePredicateAnnotation) -> MethodSignatureReturnType {
		MethodSignatureReturnType::TypePredicateAnnotation(node)
	}
}
impl AstNode for MethodSignatureReturnType {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ASSERTS
			| SyntaxKind::TYPE_ANNOTATION
			| SyntaxKind::TYPE_PREDICATE_ANNOTATION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ASSERTS => MethodSignatureReturnType::Asserts(Asserts { syntax }),
			SyntaxKind::TYPE_ANNOTATION => {
				MethodSignatureReturnType::TypeAnnotation(TypeAnnotation { syntax })
			}
			SyntaxKind::TYPE_PREDICATE_ANNOTATION => {
				MethodSignatureReturnType::TypePredicateAnnotation(TypePredicateAnnotation {
					syntax,
				})
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			MethodSignatureReturnType::Asserts(it) => &it.syntax,
			MethodSignatureReturnType::TypeAnnotation(it) => &it.syntax,
			MethodSignatureReturnType::TypePredicateAnnotation(it) => &it.syntax,
		}
	}
}
impl From<Identifier> for ModuleName {
	fn from(node: Identifier) -> ModuleName {
		ModuleName::Identifier(node)
	}
}
impl From<NestedIdentifier> for ModuleName {
	fn from(node: NestedIdentifier) -> ModuleName {
		ModuleName::NestedIdentifier(node)
	}
}
impl From<StringLiteral> for ModuleName {
	fn from(node: StringLiteral) -> ModuleName {
		ModuleName::StringLiteral(node)
	}
}
impl AstNode for ModuleName {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::IDENTIFIER | SyntaxKind::NESTED_IDENTIFIER | SyntaxKind::STRING_LITERAL => {
				true
			}
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::IDENTIFIER => ModuleName::Identifier(Identifier { syntax }),
			SyntaxKind::NESTED_IDENTIFIER => {
				ModuleName::NestedIdentifier(NestedIdentifier { syntax })
			}
			SyntaxKind::STRING_LITERAL => ModuleName::StringLiteral(StringLiteral { syntax }),
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ModuleName::Identifier(it) => &it.syntax,
			ModuleName::NestedIdentifier(it) => &it.syntax,
			ModuleName::StringLiteral(it) => &it.syntax,
		}
	}
}
impl From<Identifier> for NestedIdentifierInnerChildren {
	fn from(node: Identifier) -> NestedIdentifierInnerChildren {
		NestedIdentifierInnerChildren::Identifier(node)
	}
}
impl From<NestedIdentifier> for NestedIdentifierInnerChildren {
	fn from(node: NestedIdentifier) -> NestedIdentifierInnerChildren {
		NestedIdentifierInnerChildren::NestedIdentifier(node)
	}
}
impl AstNode for NestedIdentifierInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::IDENTIFIER | SyntaxKind::NESTED_IDENTIFIER => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::IDENTIFIER => {
				NestedIdentifierInnerChildren::Identifier(Identifier { syntax })
			}
			SyntaxKind::NESTED_IDENTIFIER => {
				NestedIdentifierInnerChildren::NestedIdentifier(NestedIdentifier { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			NestedIdentifierInnerChildren::Identifier(it) => &it.syntax,
			NestedIdentifierInnerChildren::NestedIdentifier(it) => &it.syntax,
		}
	}
}
impl From<Identifier> for NestedTypeIdentifierModule {
	fn from(node: Identifier) -> NestedTypeIdentifierModule {
		NestedTypeIdentifierModule::Identifier(node)
	}
}
impl From<NestedIdentifier> for NestedTypeIdentifierModule {
	fn from(node: NestedIdentifier) -> NestedTypeIdentifierModule {
		NestedTypeIdentifierModule::NestedIdentifier(node)
	}
}
impl AstNode for NestedTypeIdentifierModule {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::IDENTIFIER | SyntaxKind::NESTED_IDENTIFIER => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::IDENTIFIER => NestedTypeIdentifierModule::Identifier(Identifier { syntax }),
			SyntaxKind::NESTED_IDENTIFIER => {
				NestedTypeIdentifierModule::NestedIdentifier(NestedIdentifier { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			NestedTypeIdentifierModule::Identifier(it) => &it.syntax,
			NestedTypeIdentifierModule::NestedIdentifier(it) => &it.syntax,
		}
	}
}
impl From<ArrayPattern> for ObjectAssignmentPatternLeft {
	fn from(node: ArrayPattern) -> ObjectAssignmentPatternLeft {
		ObjectAssignmentPatternLeft::ArrayPattern(node)
	}
}
impl From<ObjectPattern> for ObjectAssignmentPatternLeft {
	fn from(node: ObjectPattern) -> ObjectAssignmentPatternLeft {
		ObjectAssignmentPatternLeft::ObjectPattern(node)
	}
}
impl From<ShorthandPropertyIdentifierPattern> for ObjectAssignmentPatternLeft {
	fn from(node: ShorthandPropertyIdentifierPattern) -> ObjectAssignmentPatternLeft {
		ObjectAssignmentPatternLeft::ShorthandPropertyIdentifierPattern(node)
	}
}
impl AstNode for ObjectAssignmentPatternLeft {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ARRAY_PATTERN
			| SyntaxKind::OBJECT_PATTERN
			| SyntaxKind::SHORTHAND_PROPERTY_IDENTIFIER_PATTERN => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ARRAY_PATTERN => {
				ObjectAssignmentPatternLeft::ArrayPattern(ArrayPattern { syntax })
			}
			SyntaxKind::OBJECT_PATTERN => {
				ObjectAssignmentPatternLeft::ObjectPattern(ObjectPattern { syntax })
			}
			SyntaxKind::SHORTHAND_PROPERTY_IDENTIFIER_PATTERN => {
				ObjectAssignmentPatternLeft::ShorthandPropertyIdentifierPattern(
					ShorthandPropertyIdentifierPattern { syntax },
				)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ObjectAssignmentPatternLeft::ArrayPattern(it) => &it.syntax,
			ObjectAssignmentPatternLeft::ObjectPattern(it) => &it.syntax,
			ObjectAssignmentPatternLeft::ShorthandPropertyIdentifierPattern(it) => &it.syntax,
		}
	}
}
impl From<MethodDefinition> for ObjectInnerChildren {
	fn from(node: MethodDefinition) -> ObjectInnerChildren {
		ObjectInnerChildren::MethodDefinition(node)
	}
}
impl From<Pair> for ObjectInnerChildren {
	fn from(node: Pair) -> ObjectInnerChildren {
		ObjectInnerChildren::Pair(node)
	}
}
impl From<ShorthandPropertyIdentifier> for ObjectInnerChildren {
	fn from(node: ShorthandPropertyIdentifier) -> ObjectInnerChildren {
		ObjectInnerChildren::ShorthandPropertyIdentifier(node)
	}
}
impl From<SpreadElement> for ObjectInnerChildren {
	fn from(node: SpreadElement) -> ObjectInnerChildren {
		ObjectInnerChildren::SpreadElement(node)
	}
}
impl AstNode for ObjectInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::METHOD_DEFINITION
			| SyntaxKind::PAIR
			| SyntaxKind::SHORTHAND_PROPERTY_IDENTIFIER
			| SyntaxKind::SPREAD_ELEMENT => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::METHOD_DEFINITION => {
				ObjectInnerChildren::MethodDefinition(MethodDefinition { syntax })
			}
			SyntaxKind::PAIR => ObjectInnerChildren::Pair(Pair { syntax }),
			SyntaxKind::SHORTHAND_PROPERTY_IDENTIFIER => {
				ObjectInnerChildren::ShorthandPropertyIdentifier(ShorthandPropertyIdentifier {
					syntax,
				})
			}
			SyntaxKind::SPREAD_ELEMENT => {
				ObjectInnerChildren::SpreadElement(SpreadElement { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ObjectInnerChildren::MethodDefinition(it) => &it.syntax,
			ObjectInnerChildren::Pair(it) => &it.syntax,
			ObjectInnerChildren::ShorthandPropertyIdentifier(it) => &it.syntax,
			ObjectInnerChildren::SpreadElement(it) => &it.syntax,
		}
	}
}
impl From<ObjectAssignmentPattern> for ObjectPatternInnerChildren {
	fn from(node: ObjectAssignmentPattern) -> ObjectPatternInnerChildren {
		ObjectPatternInnerChildren::ObjectAssignmentPattern(node)
	}
}
impl From<PairPattern> for ObjectPatternInnerChildren {
	fn from(node: PairPattern) -> ObjectPatternInnerChildren {
		ObjectPatternInnerChildren::PairPattern(node)
	}
}
impl From<RestPattern> for ObjectPatternInnerChildren {
	fn from(node: RestPattern) -> ObjectPatternInnerChildren {
		ObjectPatternInnerChildren::RestPattern(node)
	}
}
impl From<ShorthandPropertyIdentifierPattern> for ObjectPatternInnerChildren {
	fn from(node: ShorthandPropertyIdentifierPattern) -> ObjectPatternInnerChildren {
		ObjectPatternInnerChildren::ShorthandPropertyIdentifierPattern(node)
	}
}
impl AstNode for ObjectPatternInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::OBJECT_ASSIGNMENT_PATTERN
			| SyntaxKind::PAIR_PATTERN
			| SyntaxKind::REST_PATTERN
			| SyntaxKind::SHORTHAND_PROPERTY_IDENTIFIER_PATTERN => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::OBJECT_ASSIGNMENT_PATTERN => {
				ObjectPatternInnerChildren::ObjectAssignmentPattern(ObjectAssignmentPattern {
					syntax,
				})
			}
			SyntaxKind::PAIR_PATTERN => {
				ObjectPatternInnerChildren::PairPattern(PairPattern { syntax })
			}
			SyntaxKind::REST_PATTERN => {
				ObjectPatternInnerChildren::RestPattern(RestPattern { syntax })
			}
			SyntaxKind::SHORTHAND_PROPERTY_IDENTIFIER_PATTERN => {
				ObjectPatternInnerChildren::ShorthandPropertyIdentifierPattern(
					ShorthandPropertyIdentifierPattern { syntax },
				)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ObjectPatternInnerChildren::ObjectAssignmentPattern(it) => &it.syntax,
			ObjectPatternInnerChildren::PairPattern(it) => &it.syntax,
			ObjectPatternInnerChildren::RestPattern(it) => &it.syntax,
			ObjectPatternInnerChildren::ShorthandPropertyIdentifierPattern(it) => &it.syntax,
		}
	}
}
impl From<CallSignature> for ObjectTypeInnerChildren {
	fn from(node: CallSignature) -> ObjectTypeInnerChildren {
		ObjectTypeInnerChildren::CallSignature(node)
	}
}
impl From<ConstructSignature> for ObjectTypeInnerChildren {
	fn from(node: ConstructSignature) -> ObjectTypeInnerChildren {
		ObjectTypeInnerChildren::ConstructSignature(node)
	}
}
impl From<ExportStatement> for ObjectTypeInnerChildren {
	fn from(node: ExportStatement) -> ObjectTypeInnerChildren {
		ObjectTypeInnerChildren::ExportStatement(node)
	}
}
impl From<IndexSignature> for ObjectTypeInnerChildren {
	fn from(node: IndexSignature) -> ObjectTypeInnerChildren {
		ObjectTypeInnerChildren::IndexSignature(node)
	}
}
impl From<MethodSignature> for ObjectTypeInnerChildren {
	fn from(node: MethodSignature) -> ObjectTypeInnerChildren {
		ObjectTypeInnerChildren::MethodSignature(node)
	}
}
impl From<PropertySignature> for ObjectTypeInnerChildren {
	fn from(node: PropertySignature) -> ObjectTypeInnerChildren {
		ObjectTypeInnerChildren::PropertySignature(node)
	}
}
impl AstNode for ObjectTypeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CALL_SIGNATURE
			| SyntaxKind::CONSTRUCT_SIGNATURE
			| SyntaxKind::EXPORT_STATEMENT
			| SyntaxKind::INDEX_SIGNATURE
			| SyntaxKind::METHOD_SIGNATURE
			| SyntaxKind::PROPERTY_SIGNATURE => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CALL_SIGNATURE => {
				ObjectTypeInnerChildren::CallSignature(CallSignature { syntax })
			}
			SyntaxKind::CONSTRUCT_SIGNATURE => {
				ObjectTypeInnerChildren::ConstructSignature(ConstructSignature { syntax })
			}
			SyntaxKind::EXPORT_STATEMENT => {
				ObjectTypeInnerChildren::ExportStatement(ExportStatement { syntax })
			}
			SyntaxKind::INDEX_SIGNATURE => {
				ObjectTypeInnerChildren::IndexSignature(IndexSignature { syntax })
			}
			SyntaxKind::METHOD_SIGNATURE => {
				ObjectTypeInnerChildren::MethodSignature(MethodSignature { syntax })
			}
			SyntaxKind::PROPERTY_SIGNATURE => {
				ObjectTypeInnerChildren::PropertySignature(PropertySignature { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ObjectTypeInnerChildren::CallSignature(it) => &it.syntax,
			ObjectTypeInnerChildren::ConstructSignature(it) => &it.syntax,
			ObjectTypeInnerChildren::ExportStatement(it) => &it.syntax,
			ObjectTypeInnerChildren::IndexSignature(it) => &it.syntax,
			ObjectTypeInnerChildren::MethodSignature(it) => &it.syntax,
			ObjectTypeInnerChildren::PropertySignature(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for OmittingTypeAnnotationInnerChildren {
	fn from(node: ConstructorType) -> OmittingTypeAnnotationInnerChildren {
		OmittingTypeAnnotationInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for OmittingTypeAnnotationInnerChildren {
	fn from(node: FunctionType) -> OmittingTypeAnnotationInnerChildren {
		OmittingTypeAnnotationInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for OmittingTypeAnnotationInnerChildren {
	fn from(node: InferType) -> OmittingTypeAnnotationInnerChildren {
		OmittingTypeAnnotationInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for OmittingTypeAnnotationInnerChildren {
	fn from(node: IntersectionType) -> OmittingTypeAnnotationInnerChildren {
		OmittingTypeAnnotationInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for OmittingTypeAnnotationInnerChildren {
	fn from(node: PrimaryType) -> OmittingTypeAnnotationInnerChildren {
		OmittingTypeAnnotationInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for OmittingTypeAnnotationInnerChildren {
	fn from(node: ReadonlyType) -> OmittingTypeAnnotationInnerChildren {
		OmittingTypeAnnotationInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for OmittingTypeAnnotationInnerChildren {
	fn from(node: UnionType) -> OmittingTypeAnnotationInnerChildren {
		OmittingTypeAnnotationInnerChildren::UnionType(node)
	}
}
impl AstNode for OmittingTypeAnnotationInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				OmittingTypeAnnotationInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				OmittingTypeAnnotationInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => {
				OmittingTypeAnnotationInnerChildren::InferType(InferType { syntax })
			}
			SyntaxKind::INTERSECTION_TYPE => {
				OmittingTypeAnnotationInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				OmittingTypeAnnotationInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => {
				OmittingTypeAnnotationInnerChildren::UnionType(UnionType { syntax })
			}
			kind if PrimaryType::can_cast(kind) => {
				OmittingTypeAnnotationInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			OmittingTypeAnnotationInnerChildren::ConstructorType(it) => &it.syntax,
			OmittingTypeAnnotationInnerChildren::FunctionType(it) => &it.syntax,
			OmittingTypeAnnotationInnerChildren::InferType(it) => &it.syntax,
			OmittingTypeAnnotationInnerChildren::IntersectionType(it) => &it.syntax,
			OmittingTypeAnnotationInnerChildren::ReadonlyType(it) => &it.syntax,
			OmittingTypeAnnotationInnerChildren::UnionType(it) => &it.syntax,
			OmittingTypeAnnotationInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<ConstructorType> for OptingTypeAnnotationInnerChildren {
	fn from(node: ConstructorType) -> OptingTypeAnnotationInnerChildren {
		OptingTypeAnnotationInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for OptingTypeAnnotationInnerChildren {
	fn from(node: FunctionType) -> OptingTypeAnnotationInnerChildren {
		OptingTypeAnnotationInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for OptingTypeAnnotationInnerChildren {
	fn from(node: InferType) -> OptingTypeAnnotationInnerChildren {
		OptingTypeAnnotationInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for OptingTypeAnnotationInnerChildren {
	fn from(node: IntersectionType) -> OptingTypeAnnotationInnerChildren {
		OptingTypeAnnotationInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for OptingTypeAnnotationInnerChildren {
	fn from(node: PrimaryType) -> OptingTypeAnnotationInnerChildren {
		OptingTypeAnnotationInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for OptingTypeAnnotationInnerChildren {
	fn from(node: ReadonlyType) -> OptingTypeAnnotationInnerChildren {
		OptingTypeAnnotationInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for OptingTypeAnnotationInnerChildren {
	fn from(node: UnionType) -> OptingTypeAnnotationInnerChildren {
		OptingTypeAnnotationInnerChildren::UnionType(node)
	}
}
impl AstNode for OptingTypeAnnotationInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				OptingTypeAnnotationInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				OptingTypeAnnotationInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => {
				OptingTypeAnnotationInnerChildren::InferType(InferType { syntax })
			}
			SyntaxKind::INTERSECTION_TYPE => {
				OptingTypeAnnotationInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				OptingTypeAnnotationInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => {
				OptingTypeAnnotationInnerChildren::UnionType(UnionType { syntax })
			}
			kind if PrimaryType::can_cast(kind) => {
				OptingTypeAnnotationInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			OptingTypeAnnotationInnerChildren::ConstructorType(it) => &it.syntax,
			OptingTypeAnnotationInnerChildren::FunctionType(it) => &it.syntax,
			OptingTypeAnnotationInnerChildren::InferType(it) => &it.syntax,
			OptingTypeAnnotationInnerChildren::IntersectionType(it) => &it.syntax,
			OptingTypeAnnotationInnerChildren::ReadonlyType(it) => &it.syntax,
			OptingTypeAnnotationInnerChildren::UnionType(it) => &it.syntax,
			OptingTypeAnnotationInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<AccessibilityModifier> for OptionalParameterInnerChildren {
	fn from(node: AccessibilityModifier) -> OptionalParameterInnerChildren {
		OptionalParameterInnerChildren::AccessibilityModifier(node)
	}
}
impl From<Pattern> for OptionalParameterInnerChildren {
	fn from(node: Pattern) -> OptionalParameterInnerChildren {
		OptionalParameterInnerChildren::Pattern(node)
	}
}
impl From<This> for OptionalParameterInnerChildren {
	fn from(node: This) -> OptionalParameterInnerChildren {
		OptionalParameterInnerChildren::This(node)
	}
}
impl From<TypeAnnotation> for OptionalParameterInnerChildren {
	fn from(node: TypeAnnotation) -> OptionalParameterInnerChildren {
		OptionalParameterInnerChildren::TypeAnnotation(node)
	}
}
impl AstNode for OptionalParameterInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ACCESSIBILITY_MODIFIER | SyntaxKind::THIS | SyntaxKind::TYPE_ANNOTATION => {
				true
			}
			_ => Pattern::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ACCESSIBILITY_MODIFIER => {
				OptionalParameterInnerChildren::AccessibilityModifier(AccessibilityModifier {
					syntax,
				})
			}
			SyntaxKind::THIS => OptionalParameterInnerChildren::This(This { syntax }),
			SyntaxKind::TYPE_ANNOTATION => {
				OptionalParameterInnerChildren::TypeAnnotation(TypeAnnotation { syntax })
			}
			kind if Pattern::can_cast(kind) => {
				OptionalParameterInnerChildren::Pattern(Pattern::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			OptionalParameterInnerChildren::AccessibilityModifier(it) => &it.syntax,
			OptionalParameterInnerChildren::This(it) => &it.syntax,
			OptionalParameterInnerChildren::TypeAnnotation(it) => &it.syntax,
			OptionalParameterInnerChildren::Pattern(it) => &it.syntax(),
		}
	}
}
impl From<ConstructorType> for OptionalTypeInnerChildren {
	fn from(node: ConstructorType) -> OptionalTypeInnerChildren {
		OptionalTypeInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for OptionalTypeInnerChildren {
	fn from(node: FunctionType) -> OptionalTypeInnerChildren {
		OptionalTypeInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for OptionalTypeInnerChildren {
	fn from(node: InferType) -> OptionalTypeInnerChildren {
		OptionalTypeInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for OptionalTypeInnerChildren {
	fn from(node: IntersectionType) -> OptionalTypeInnerChildren {
		OptionalTypeInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for OptionalTypeInnerChildren {
	fn from(node: PrimaryType) -> OptionalTypeInnerChildren {
		OptionalTypeInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for OptionalTypeInnerChildren {
	fn from(node: ReadonlyType) -> OptionalTypeInnerChildren {
		OptionalTypeInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for OptionalTypeInnerChildren {
	fn from(node: UnionType) -> OptionalTypeInnerChildren {
		OptionalTypeInnerChildren::UnionType(node)
	}
}
impl AstNode for OptionalTypeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				OptionalTypeInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				OptionalTypeInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => OptionalTypeInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				OptionalTypeInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				OptionalTypeInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => OptionalTypeInnerChildren::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				OptionalTypeInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			OptionalTypeInnerChildren::ConstructorType(it) => &it.syntax,
			OptionalTypeInnerChildren::FunctionType(it) => &it.syntax,
			OptionalTypeInnerChildren::InferType(it) => &it.syntax,
			OptionalTypeInnerChildren::IntersectionType(it) => &it.syntax,
			OptionalTypeInnerChildren::ReadonlyType(it) => &it.syntax,
			OptionalTypeInnerChildren::UnionType(it) => &it.syntax,
			OptionalTypeInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<ComputedPropertyName> for PairKey {
	fn from(node: ComputedPropertyName) -> PairKey {
		PairKey::ComputedPropertyName(node)
	}
}
impl From<Number> for PairKey {
	fn from(node: Number) -> PairKey {
		PairKey::Number(node)
	}
}
impl From<PropertyIdentifier> for PairKey {
	fn from(node: PropertyIdentifier) -> PairKey {
		PairKey::PropertyIdentifier(node)
	}
}
impl From<StringLiteral> for PairKey {
	fn from(node: StringLiteral) -> PairKey {
		PairKey::StringLiteral(node)
	}
}
impl AstNode for PairKey {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::COMPUTED_PROPERTY_NAME
			| SyntaxKind::NUMBER
			| SyntaxKind::PROPERTY_IDENTIFIER
			| SyntaxKind::STRING_LITERAL => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::COMPUTED_PROPERTY_NAME => {
				PairKey::ComputedPropertyName(ComputedPropertyName { syntax })
			}
			SyntaxKind::NUMBER => PairKey::Number(Number { syntax }),
			SyntaxKind::PROPERTY_IDENTIFIER => {
				PairKey::PropertyIdentifier(PropertyIdentifier { syntax })
			}
			SyntaxKind::STRING_LITERAL => PairKey::StringLiteral(StringLiteral { syntax }),
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			PairKey::ComputedPropertyName(it) => &it.syntax,
			PairKey::Number(it) => &it.syntax,
			PairKey::PropertyIdentifier(it) => &it.syntax,
			PairKey::StringLiteral(it) => &it.syntax,
		}
	}
}
impl From<ComputedPropertyName> for PairPatternKey {
	fn from(node: ComputedPropertyName) -> PairPatternKey {
		PairPatternKey::ComputedPropertyName(node)
	}
}
impl From<Number> for PairPatternKey {
	fn from(node: Number) -> PairPatternKey {
		PairPatternKey::Number(node)
	}
}
impl From<PropertyIdentifier> for PairPatternKey {
	fn from(node: PropertyIdentifier) -> PairPatternKey {
		PairPatternKey::PropertyIdentifier(node)
	}
}
impl From<StringLiteral> for PairPatternKey {
	fn from(node: StringLiteral) -> PairPatternKey {
		PairPatternKey::StringLiteral(node)
	}
}
impl AstNode for PairPatternKey {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::COMPUTED_PROPERTY_NAME
			| SyntaxKind::NUMBER
			| SyntaxKind::PROPERTY_IDENTIFIER
			| SyntaxKind::STRING_LITERAL => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::COMPUTED_PROPERTY_NAME => {
				PairPatternKey::ComputedPropertyName(ComputedPropertyName { syntax })
			}
			SyntaxKind::NUMBER => PairPatternKey::Number(Number { syntax }),
			SyntaxKind::PROPERTY_IDENTIFIER => {
				PairPatternKey::PropertyIdentifier(PropertyIdentifier { syntax })
			}
			SyntaxKind::STRING_LITERAL => PairPatternKey::StringLiteral(StringLiteral { syntax }),
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			PairPatternKey::ComputedPropertyName(it) => &it.syntax,
			PairPatternKey::Number(it) => &it.syntax,
			PairPatternKey::PropertyIdentifier(it) => &it.syntax,
			PairPatternKey::StringLiteral(it) => &it.syntax,
		}
	}
}
impl From<Expression> for ParenthesizedExpressionInnerChildren {
	fn from(node: Expression) -> ParenthesizedExpressionInnerChildren {
		ParenthesizedExpressionInnerChildren::Expression(node)
	}
}
impl From<SequenceExpression> for ParenthesizedExpressionInnerChildren {
	fn from(node: SequenceExpression) -> ParenthesizedExpressionInnerChildren {
		ParenthesizedExpressionInnerChildren::SequenceExpression(node)
	}
}
impl From<TypeAnnotation> for ParenthesizedExpressionInnerChildren {
	fn from(node: TypeAnnotation) -> ParenthesizedExpressionInnerChildren {
		ParenthesizedExpressionInnerChildren::TypeAnnotation(node)
	}
}
impl AstNode for ParenthesizedExpressionInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::SEQUENCE_EXPRESSION | SyntaxKind::TYPE_ANNOTATION => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::SEQUENCE_EXPRESSION => {
				ParenthesizedExpressionInnerChildren::SequenceExpression(SequenceExpression {
					syntax,
				})
			}
			SyntaxKind::TYPE_ANNOTATION => {
				ParenthesizedExpressionInnerChildren::TypeAnnotation(TypeAnnotation { syntax })
			}
			kind if Expression::can_cast(kind) => {
				ParenthesizedExpressionInnerChildren::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ParenthesizedExpressionInnerChildren::SequenceExpression(it) => &it.syntax,
			ParenthesizedExpressionInnerChildren::TypeAnnotation(it) => &it.syntax,
			ParenthesizedExpressionInnerChildren::Expression(it) => &it.syntax(),
		}
	}
}
impl From<ConstructorType> for ParenthesizedTypeInnerChildren {
	fn from(node: ConstructorType) -> ParenthesizedTypeInnerChildren {
		ParenthesizedTypeInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for ParenthesizedTypeInnerChildren {
	fn from(node: FunctionType) -> ParenthesizedTypeInnerChildren {
		ParenthesizedTypeInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for ParenthesizedTypeInnerChildren {
	fn from(node: InferType) -> ParenthesizedTypeInnerChildren {
		ParenthesizedTypeInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for ParenthesizedTypeInnerChildren {
	fn from(node: IntersectionType) -> ParenthesizedTypeInnerChildren {
		ParenthesizedTypeInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for ParenthesizedTypeInnerChildren {
	fn from(node: PrimaryType) -> ParenthesizedTypeInnerChildren {
		ParenthesizedTypeInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for ParenthesizedTypeInnerChildren {
	fn from(node: ReadonlyType) -> ParenthesizedTypeInnerChildren {
		ParenthesizedTypeInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for ParenthesizedTypeInnerChildren {
	fn from(node: UnionType) -> ParenthesizedTypeInnerChildren {
		ParenthesizedTypeInnerChildren::UnionType(node)
	}
}
impl AstNode for ParenthesizedTypeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				ParenthesizedTypeInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				ParenthesizedTypeInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => {
				ParenthesizedTypeInnerChildren::InferType(InferType { syntax })
			}
			SyntaxKind::INTERSECTION_TYPE => {
				ParenthesizedTypeInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				ParenthesizedTypeInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => {
				ParenthesizedTypeInnerChildren::UnionType(UnionType { syntax })
			}
			kind if PrimaryType::can_cast(kind) => {
				ParenthesizedTypeInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ParenthesizedTypeInnerChildren::ConstructorType(it) => &it.syntax,
			ParenthesizedTypeInnerChildren::FunctionType(it) => &it.syntax,
			ParenthesizedTypeInnerChildren::InferType(it) => &it.syntax,
			ParenthesizedTypeInnerChildren::IntersectionType(it) => &it.syntax,
			ParenthesizedTypeInnerChildren::ReadonlyType(it) => &it.syntax,
			ParenthesizedTypeInnerChildren::UnionType(it) => &it.syntax,
			ParenthesizedTypeInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<ArrayPattern> for Pattern {
	fn from(node: ArrayPattern) -> Pattern {
		Pattern::ArrayPattern(node)
	}
}
impl From<Identifier> for Pattern {
	fn from(node: Identifier) -> Pattern {
		Pattern::Identifier(node)
	}
}
impl From<ObjectPattern> for Pattern {
	fn from(node: ObjectPattern) -> Pattern {
		Pattern::ObjectPattern(node)
	}
}
impl From<RestPattern> for Pattern {
	fn from(node: RestPattern) -> Pattern {
		Pattern::RestPattern(node)
	}
}
impl AstNode for Pattern {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ARRAY_PATTERN
			| SyntaxKind::IDENTIFIER
			| SyntaxKind::OBJECT_PATTERN
			| SyntaxKind::REST_PATTERN => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ARRAY_PATTERN => Pattern::ArrayPattern(ArrayPattern { syntax }),
			SyntaxKind::IDENTIFIER => Pattern::Identifier(Identifier { syntax }),
			SyntaxKind::OBJECT_PATTERN => Pattern::ObjectPattern(ObjectPattern { syntax }),
			SyntaxKind::REST_PATTERN => Pattern::RestPattern(RestPattern { syntax }),
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			Pattern::ArrayPattern(it) => &it.syntax,
			Pattern::Identifier(it) => &it.syntax,
			Pattern::ObjectPattern(it) => &it.syntax,
			Pattern::RestPattern(it) => &it.syntax,
		}
	}
}
impl From<Array> for PrimaryExpression {
	fn from(node: Array) -> PrimaryExpression {
		PrimaryExpression::Array(node)
	}
}
impl From<ArrowFunction> for PrimaryExpression {
	fn from(node: ArrowFunction) -> PrimaryExpression {
		PrimaryExpression::ArrowFunction(node)
	}
}
impl From<CallExpression> for PrimaryExpression {
	fn from(node: CallExpression) -> PrimaryExpression {
		PrimaryExpression::CallExpression(node)
	}
}
impl From<Class> for PrimaryExpression {
	fn from(node: Class) -> PrimaryExpression {
		PrimaryExpression::Class(node)
	}
}
impl From<False> for PrimaryExpression {
	fn from(node: False) -> PrimaryExpression {
		PrimaryExpression::False(node)
	}
}
impl From<Function> for PrimaryExpression {
	fn from(node: Function) -> PrimaryExpression {
		PrimaryExpression::Function(node)
	}
}
impl From<GeneratorFunction> for PrimaryExpression {
	fn from(node: GeneratorFunction) -> PrimaryExpression {
		PrimaryExpression::GeneratorFunction(node)
	}
}
impl From<Identifier> for PrimaryExpression {
	fn from(node: Identifier) -> PrimaryExpression {
		PrimaryExpression::Identifier(node)
	}
}
impl From<Import> for PrimaryExpression {
	fn from(node: Import) -> PrimaryExpression {
		PrimaryExpression::Import(node)
	}
}
impl From<MemberExpression> for PrimaryExpression {
	fn from(node: MemberExpression) -> PrimaryExpression {
		PrimaryExpression::MemberExpression(node)
	}
}
impl From<MetaProperty> for PrimaryExpression {
	fn from(node: MetaProperty) -> PrimaryExpression {
		PrimaryExpression::MetaProperty(node)
	}
}
impl From<NonNullExpression> for PrimaryExpression {
	fn from(node: NonNullExpression) -> PrimaryExpression {
		PrimaryExpression::NonNullExpression(node)
	}
}
impl From<Null> for PrimaryExpression {
	fn from(node: Null) -> PrimaryExpression {
		PrimaryExpression::Null(node)
	}
}
impl From<Number> for PrimaryExpression {
	fn from(node: Number) -> PrimaryExpression {
		PrimaryExpression::Number(node)
	}
}
impl From<Object> for PrimaryExpression {
	fn from(node: Object) -> PrimaryExpression {
		PrimaryExpression::Object(node)
	}
}
impl From<ParenthesizedExpression> for PrimaryExpression {
	fn from(node: ParenthesizedExpression) -> PrimaryExpression {
		PrimaryExpression::ParenthesizedExpression(node)
	}
}
impl From<Regex> for PrimaryExpression {
	fn from(node: Regex) -> PrimaryExpression {
		PrimaryExpression::Regex(node)
	}
}
impl From<StringLiteral> for PrimaryExpression {
	fn from(node: StringLiteral) -> PrimaryExpression {
		PrimaryExpression::StringLiteral(node)
	}
}
impl From<SubscriptExpression> for PrimaryExpression {
	fn from(node: SubscriptExpression) -> PrimaryExpression {
		PrimaryExpression::SubscriptExpression(node)
	}
}
impl From<Super> for PrimaryExpression {
	fn from(node: Super) -> PrimaryExpression {
		PrimaryExpression::Super(node)
	}
}
impl From<TemplateString> for PrimaryExpression {
	fn from(node: TemplateString) -> PrimaryExpression {
		PrimaryExpression::TemplateString(node)
	}
}
impl From<This> for PrimaryExpression {
	fn from(node: This) -> PrimaryExpression {
		PrimaryExpression::This(node)
	}
}
impl From<True> for PrimaryExpression {
	fn from(node: True) -> PrimaryExpression {
		PrimaryExpression::True(node)
	}
}
impl From<Undefined> for PrimaryExpression {
	fn from(node: Undefined) -> PrimaryExpression {
		PrimaryExpression::Undefined(node)
	}
}
impl AstNode for PrimaryExpression {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ARRAY
			| SyntaxKind::ARROW_FUNCTION
			| SyntaxKind::CALL_EXPRESSION
			| SyntaxKind::CLASS
			| SyntaxKind::FALSE
			| SyntaxKind::FUNCTION
			| SyntaxKind::GENERATOR_FUNCTION
			| SyntaxKind::IDENTIFIER
			| SyntaxKind::IMPORT
			| SyntaxKind::MEMBER_EXPRESSION
			| SyntaxKind::META_PROPERTY
			| SyntaxKind::NON_NULL_EXPRESSION
			| SyntaxKind::NULL
			| SyntaxKind::NUMBER
			| SyntaxKind::OBJECT
			| SyntaxKind::PARENTHESIZED_EXPRESSION
			| SyntaxKind::REGEX
			| SyntaxKind::STRING_LITERAL
			| SyntaxKind::SUBSCRIPT_EXPRESSION
			| SyntaxKind::SUPER
			| SyntaxKind::TEMPLATE_STRING
			| SyntaxKind::THIS
			| SyntaxKind::TRUE
			| SyntaxKind::UNDEFINED => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ARRAY => PrimaryExpression::Array(Array { syntax }),
			SyntaxKind::ARROW_FUNCTION => {
				PrimaryExpression::ArrowFunction(ArrowFunction { syntax })
			}
			SyntaxKind::CALL_EXPRESSION => {
				PrimaryExpression::CallExpression(CallExpression { syntax })
			}
			SyntaxKind::CLASS => PrimaryExpression::Class(Class { syntax }),
			SyntaxKind::FALSE => PrimaryExpression::False(False { syntax }),
			SyntaxKind::FUNCTION => PrimaryExpression::Function(Function { syntax }),
			SyntaxKind::GENERATOR_FUNCTION => {
				PrimaryExpression::GeneratorFunction(GeneratorFunction { syntax })
			}
			SyntaxKind::IDENTIFIER => PrimaryExpression::Identifier(Identifier { syntax }),
			SyntaxKind::IMPORT => PrimaryExpression::Import(Import { syntax }),
			SyntaxKind::MEMBER_EXPRESSION => {
				PrimaryExpression::MemberExpression(MemberExpression { syntax })
			}
			SyntaxKind::META_PROPERTY => PrimaryExpression::MetaProperty(MetaProperty { syntax }),
			SyntaxKind::NON_NULL_EXPRESSION => {
				PrimaryExpression::NonNullExpression(NonNullExpression { syntax })
			}
			SyntaxKind::NULL => PrimaryExpression::Null(Null { syntax }),
			SyntaxKind::NUMBER => PrimaryExpression::Number(Number { syntax }),
			SyntaxKind::OBJECT => PrimaryExpression::Object(Object { syntax }),
			SyntaxKind::PARENTHESIZED_EXPRESSION => {
				PrimaryExpression::ParenthesizedExpression(ParenthesizedExpression { syntax })
			}
			SyntaxKind::REGEX => PrimaryExpression::Regex(Regex { syntax }),
			SyntaxKind::STRING_LITERAL => {
				PrimaryExpression::StringLiteral(StringLiteral { syntax })
			}
			SyntaxKind::SUBSCRIPT_EXPRESSION => {
				PrimaryExpression::SubscriptExpression(SubscriptExpression { syntax })
			}
			SyntaxKind::SUPER => PrimaryExpression::Super(Super { syntax }),
			SyntaxKind::TEMPLATE_STRING => {
				PrimaryExpression::TemplateString(TemplateString { syntax })
			}
			SyntaxKind::THIS => PrimaryExpression::This(This { syntax }),
			SyntaxKind::TRUE => PrimaryExpression::True(True { syntax }),
			SyntaxKind::UNDEFINED => PrimaryExpression::Undefined(Undefined { syntax }),
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			PrimaryExpression::Array(it) => &it.syntax,
			PrimaryExpression::ArrowFunction(it) => &it.syntax,
			PrimaryExpression::CallExpression(it) => &it.syntax,
			PrimaryExpression::Class(it) => &it.syntax,
			PrimaryExpression::False(it) => &it.syntax,
			PrimaryExpression::Function(it) => &it.syntax,
			PrimaryExpression::GeneratorFunction(it) => &it.syntax,
			PrimaryExpression::Identifier(it) => &it.syntax,
			PrimaryExpression::Import(it) => &it.syntax,
			PrimaryExpression::MemberExpression(it) => &it.syntax,
			PrimaryExpression::MetaProperty(it) => &it.syntax,
			PrimaryExpression::NonNullExpression(it) => &it.syntax,
			PrimaryExpression::Null(it) => &it.syntax,
			PrimaryExpression::Number(it) => &it.syntax,
			PrimaryExpression::Object(it) => &it.syntax,
			PrimaryExpression::ParenthesizedExpression(it) => &it.syntax,
			PrimaryExpression::Regex(it) => &it.syntax,
			PrimaryExpression::StringLiteral(it) => &it.syntax,
			PrimaryExpression::SubscriptExpression(it) => &it.syntax,
			PrimaryExpression::Super(it) => &it.syntax,
			PrimaryExpression::TemplateString(it) => &it.syntax,
			PrimaryExpression::This(it) => &it.syntax,
			PrimaryExpression::True(it) => &it.syntax,
			PrimaryExpression::Undefined(it) => &it.syntax,
		}
	}
}
impl From<ArrayType> for PrimaryType {
	fn from(node: ArrayType) -> PrimaryType {
		PrimaryType::ArrayType(node)
	}
}
impl From<ConditionalType> for PrimaryType {
	fn from(node: ConditionalType) -> PrimaryType {
		PrimaryType::ConditionalType(node)
	}
}
impl From<ExistentialType> for PrimaryType {
	fn from(node: ExistentialType) -> PrimaryType {
		PrimaryType::ExistentialType(node)
	}
}
impl From<FlowMaybeType> for PrimaryType {
	fn from(node: FlowMaybeType) -> PrimaryType {
		PrimaryType::FlowMaybeType(node)
	}
}
impl From<GenericType> for PrimaryType {
	fn from(node: GenericType) -> PrimaryType {
		PrimaryType::GenericType(node)
	}
}
impl From<IndexTypeQuery> for PrimaryType {
	fn from(node: IndexTypeQuery) -> PrimaryType {
		PrimaryType::IndexTypeQuery(node)
	}
}
impl From<LiteralType> for PrimaryType {
	fn from(node: LiteralType) -> PrimaryType {
		PrimaryType::LiteralType(node)
	}
}
impl From<LookupType> for PrimaryType {
	fn from(node: LookupType) -> PrimaryType {
		PrimaryType::LookupType(node)
	}
}
impl From<NestedTypeIdentifier> for PrimaryType {
	fn from(node: NestedTypeIdentifier) -> PrimaryType {
		PrimaryType::NestedTypeIdentifier(node)
	}
}
impl From<ObjectType> for PrimaryType {
	fn from(node: ObjectType) -> PrimaryType {
		PrimaryType::ObjectType(node)
	}
}
impl From<ParenthesizedType> for PrimaryType {
	fn from(node: ParenthesizedType) -> PrimaryType {
		PrimaryType::ParenthesizedType(node)
	}
}
impl From<PredefinedType> for PrimaryType {
	fn from(node: PredefinedType) -> PrimaryType {
		PrimaryType::PredefinedType(node)
	}
}
impl From<This> for PrimaryType {
	fn from(node: This) -> PrimaryType {
		PrimaryType::This(node)
	}
}
impl From<TupleType> for PrimaryType {
	fn from(node: TupleType) -> PrimaryType {
		PrimaryType::TupleType(node)
	}
}
impl From<TypeIdentifier> for PrimaryType {
	fn from(node: TypeIdentifier) -> PrimaryType {
		PrimaryType::TypeIdentifier(node)
	}
}
impl From<TypeQuery> for PrimaryType {
	fn from(node: TypeQuery) -> PrimaryType {
		PrimaryType::TypeQuery(node)
	}
}
impl AstNode for PrimaryType {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ARRAY_TYPE
			| SyntaxKind::CONDITIONAL_TYPE
			| SyntaxKind::EXISTENTIAL_TYPE
			| SyntaxKind::FLOW_MAYBE_TYPE
			| SyntaxKind::GENERIC_TYPE
			| SyntaxKind::INDEX_TYPE_QUERY
			| SyntaxKind::LITERAL_TYPE
			| SyntaxKind::LOOKUP_TYPE
			| SyntaxKind::NESTED_TYPE_IDENTIFIER
			| SyntaxKind::OBJECT_TYPE
			| SyntaxKind::PARENTHESIZED_TYPE
			| SyntaxKind::PREDEFINED_TYPE
			| SyntaxKind::THIS
			| SyntaxKind::TUPLE_TYPE
			| SyntaxKind::TYPE_IDENTIFIER
			| SyntaxKind::TYPE_QUERY => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ARRAY_TYPE => PrimaryType::ArrayType(ArrayType { syntax }),
			SyntaxKind::CONDITIONAL_TYPE => {
				PrimaryType::ConditionalType(ConditionalType { syntax })
			}
			SyntaxKind::EXISTENTIAL_TYPE => {
				PrimaryType::ExistentialType(ExistentialType { syntax })
			}
			SyntaxKind::FLOW_MAYBE_TYPE => PrimaryType::FlowMaybeType(FlowMaybeType { syntax }),
			SyntaxKind::GENERIC_TYPE => PrimaryType::GenericType(GenericType { syntax }),
			SyntaxKind::INDEX_TYPE_QUERY => PrimaryType::IndexTypeQuery(IndexTypeQuery { syntax }),
			SyntaxKind::LITERAL_TYPE => PrimaryType::LiteralType(LiteralType { syntax }),
			SyntaxKind::LOOKUP_TYPE => PrimaryType::LookupType(LookupType { syntax }),
			SyntaxKind::NESTED_TYPE_IDENTIFIER => {
				PrimaryType::NestedTypeIdentifier(NestedTypeIdentifier { syntax })
			}
			SyntaxKind::OBJECT_TYPE => PrimaryType::ObjectType(ObjectType { syntax }),
			SyntaxKind::PARENTHESIZED_TYPE => {
				PrimaryType::ParenthesizedType(ParenthesizedType { syntax })
			}
			SyntaxKind::PREDEFINED_TYPE => PrimaryType::PredefinedType(PredefinedType { syntax }),
			SyntaxKind::THIS => PrimaryType::This(This { syntax }),
			SyntaxKind::TUPLE_TYPE => PrimaryType::TupleType(TupleType { syntax }),
			SyntaxKind::TYPE_IDENTIFIER => PrimaryType::TypeIdentifier(TypeIdentifier { syntax }),
			SyntaxKind::TYPE_QUERY => PrimaryType::TypeQuery(TypeQuery { syntax }),
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			PrimaryType::ArrayType(it) => &it.syntax,
			PrimaryType::ConditionalType(it) => &it.syntax,
			PrimaryType::ExistentialType(it) => &it.syntax,
			PrimaryType::FlowMaybeType(it) => &it.syntax,
			PrimaryType::GenericType(it) => &it.syntax,
			PrimaryType::IndexTypeQuery(it) => &it.syntax,
			PrimaryType::LiteralType(it) => &it.syntax,
			PrimaryType::LookupType(it) => &it.syntax,
			PrimaryType::NestedTypeIdentifier(it) => &it.syntax,
			PrimaryType::ObjectType(it) => &it.syntax,
			PrimaryType::ParenthesizedType(it) => &it.syntax,
			PrimaryType::PredefinedType(it) => &it.syntax,
			PrimaryType::This(it) => &it.syntax,
			PrimaryType::TupleType(it) => &it.syntax,
			PrimaryType::TypeIdentifier(it) => &it.syntax,
			PrimaryType::TypeQuery(it) => &it.syntax,
		}
	}
}
impl From<HashBangLine> for ProgramInnerChildren {
	fn from(node: HashBangLine) -> ProgramInnerChildren {
		ProgramInnerChildren::HashBangLine(node)
	}
}
impl From<Statement> for ProgramInnerChildren {
	fn from(node: Statement) -> ProgramInnerChildren {
		ProgramInnerChildren::Statement(node)
	}
}
impl AstNode for ProgramInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::HASH_BANG_LINE => true,
			_ => Statement::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::HASH_BANG_LINE => {
				ProgramInnerChildren::HashBangLine(HashBangLine { syntax })
			}
			kind if Statement::can_cast(kind) => {
				ProgramInnerChildren::Statement(Statement::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ProgramInnerChildren::HashBangLine(it) => &it.syntax,
			ProgramInnerChildren::Statement(it) => &it.syntax(),
		}
	}
}
impl From<ComputedPropertyName> for PropertySignatureName {
	fn from(node: ComputedPropertyName) -> PropertySignatureName {
		PropertySignatureName::ComputedPropertyName(node)
	}
}
impl From<Number> for PropertySignatureName {
	fn from(node: Number) -> PropertySignatureName {
		PropertySignatureName::Number(node)
	}
}
impl From<PropertyIdentifier> for PropertySignatureName {
	fn from(node: PropertyIdentifier) -> PropertySignatureName {
		PropertySignatureName::PropertyIdentifier(node)
	}
}
impl From<StringLiteral> for PropertySignatureName {
	fn from(node: StringLiteral) -> PropertySignatureName {
		PropertySignatureName::StringLiteral(node)
	}
}
impl AstNode for PropertySignatureName {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::COMPUTED_PROPERTY_NAME
			| SyntaxKind::NUMBER
			| SyntaxKind::PROPERTY_IDENTIFIER
			| SyntaxKind::STRING_LITERAL => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::COMPUTED_PROPERTY_NAME => {
				PropertySignatureName::ComputedPropertyName(ComputedPropertyName { syntax })
			}
			SyntaxKind::NUMBER => PropertySignatureName::Number(Number { syntax }),
			SyntaxKind::PROPERTY_IDENTIFIER => {
				PropertySignatureName::PropertyIdentifier(PropertyIdentifier { syntax })
			}
			SyntaxKind::STRING_LITERAL => {
				PropertySignatureName::StringLiteral(StringLiteral { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			PropertySignatureName::ComputedPropertyName(it) => &it.syntax,
			PropertySignatureName::Number(it) => &it.syntax,
			PropertySignatureName::PropertyIdentifier(it) => &it.syntax,
			PropertySignatureName::StringLiteral(it) => &it.syntax,
		}
	}
}
impl From<ComputedPropertyName> for PublicFieldDefinitionName {
	fn from(node: ComputedPropertyName) -> PublicFieldDefinitionName {
		PublicFieldDefinitionName::ComputedPropertyName(node)
	}
}
impl From<Number> for PublicFieldDefinitionName {
	fn from(node: Number) -> PublicFieldDefinitionName {
		PublicFieldDefinitionName::Number(node)
	}
}
impl From<PropertyIdentifier> for PublicFieldDefinitionName {
	fn from(node: PropertyIdentifier) -> PublicFieldDefinitionName {
		PublicFieldDefinitionName::PropertyIdentifier(node)
	}
}
impl From<StringLiteral> for PublicFieldDefinitionName {
	fn from(node: StringLiteral) -> PublicFieldDefinitionName {
		PublicFieldDefinitionName::StringLiteral(node)
	}
}
impl AstNode for PublicFieldDefinitionName {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::COMPUTED_PROPERTY_NAME
			| SyntaxKind::NUMBER
			| SyntaxKind::PROPERTY_IDENTIFIER
			| SyntaxKind::STRING_LITERAL => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::COMPUTED_PROPERTY_NAME => {
				PublicFieldDefinitionName::ComputedPropertyName(ComputedPropertyName { syntax })
			}
			SyntaxKind::NUMBER => PublicFieldDefinitionName::Number(Number { syntax }),
			SyntaxKind::PROPERTY_IDENTIFIER => {
				PublicFieldDefinitionName::PropertyIdentifier(PropertyIdentifier { syntax })
			}
			SyntaxKind::STRING_LITERAL => {
				PublicFieldDefinitionName::StringLiteral(StringLiteral { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			PublicFieldDefinitionName::ComputedPropertyName(it) => &it.syntax,
			PublicFieldDefinitionName::Number(it) => &it.syntax,
			PublicFieldDefinitionName::PropertyIdentifier(it) => &it.syntax,
			PublicFieldDefinitionName::StringLiteral(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for ReadonlyTypeInnerChildren {
	fn from(node: ConstructorType) -> ReadonlyTypeInnerChildren {
		ReadonlyTypeInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for ReadonlyTypeInnerChildren {
	fn from(node: FunctionType) -> ReadonlyTypeInnerChildren {
		ReadonlyTypeInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for ReadonlyTypeInnerChildren {
	fn from(node: InferType) -> ReadonlyTypeInnerChildren {
		ReadonlyTypeInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for ReadonlyTypeInnerChildren {
	fn from(node: IntersectionType) -> ReadonlyTypeInnerChildren {
		ReadonlyTypeInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for ReadonlyTypeInnerChildren {
	fn from(node: PrimaryType) -> ReadonlyTypeInnerChildren {
		ReadonlyTypeInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for ReadonlyTypeInnerChildren {
	fn from(node: ReadonlyType) -> ReadonlyTypeInnerChildren {
		ReadonlyTypeInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for ReadonlyTypeInnerChildren {
	fn from(node: UnionType) -> ReadonlyTypeInnerChildren {
		ReadonlyTypeInnerChildren::UnionType(node)
	}
}
impl AstNode for ReadonlyTypeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				ReadonlyTypeInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				ReadonlyTypeInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => ReadonlyTypeInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				ReadonlyTypeInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				ReadonlyTypeInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => ReadonlyTypeInnerChildren::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				ReadonlyTypeInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ReadonlyTypeInnerChildren::ConstructorType(it) => &it.syntax,
			ReadonlyTypeInnerChildren::FunctionType(it) => &it.syntax,
			ReadonlyTypeInnerChildren::InferType(it) => &it.syntax,
			ReadonlyTypeInnerChildren::IntersectionType(it) => &it.syntax,
			ReadonlyTypeInnerChildren::ReadonlyType(it) => &it.syntax,
			ReadonlyTypeInnerChildren::UnionType(it) => &it.syntax,
			ReadonlyTypeInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<AccessibilityModifier> for RequiredParameterInnerChildren {
	fn from(node: AccessibilityModifier) -> RequiredParameterInnerChildren {
		RequiredParameterInnerChildren::AccessibilityModifier(node)
	}
}
impl From<Pattern> for RequiredParameterInnerChildren {
	fn from(node: Pattern) -> RequiredParameterInnerChildren {
		RequiredParameterInnerChildren::Pattern(node)
	}
}
impl From<This> for RequiredParameterInnerChildren {
	fn from(node: This) -> RequiredParameterInnerChildren {
		RequiredParameterInnerChildren::This(node)
	}
}
impl From<TypeAnnotation> for RequiredParameterInnerChildren {
	fn from(node: TypeAnnotation) -> RequiredParameterInnerChildren {
		RequiredParameterInnerChildren::TypeAnnotation(node)
	}
}
impl AstNode for RequiredParameterInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ACCESSIBILITY_MODIFIER | SyntaxKind::THIS | SyntaxKind::TYPE_ANNOTATION => {
				true
			}
			_ => Pattern::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ACCESSIBILITY_MODIFIER => {
				RequiredParameterInnerChildren::AccessibilityModifier(AccessibilityModifier {
					syntax,
				})
			}
			SyntaxKind::THIS => RequiredParameterInnerChildren::This(This { syntax }),
			SyntaxKind::TYPE_ANNOTATION => {
				RequiredParameterInnerChildren::TypeAnnotation(TypeAnnotation { syntax })
			}
			kind if Pattern::can_cast(kind) => {
				RequiredParameterInnerChildren::Pattern(Pattern::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			RequiredParameterInnerChildren::AccessibilityModifier(it) => &it.syntax,
			RequiredParameterInnerChildren::This(it) => &it.syntax,
			RequiredParameterInnerChildren::TypeAnnotation(it) => &it.syntax,
			RequiredParameterInnerChildren::Pattern(it) => &it.syntax(),
		}
	}
}
impl From<ArrayPattern> for RestPatternInnerChildren {
	fn from(node: ArrayPattern) -> RestPatternInnerChildren {
		RestPatternInnerChildren::ArrayPattern(node)
	}
}
impl From<Identifier> for RestPatternInnerChildren {
	fn from(node: Identifier) -> RestPatternInnerChildren {
		RestPatternInnerChildren::Identifier(node)
	}
}
impl From<ObjectPattern> for RestPatternInnerChildren {
	fn from(node: ObjectPattern) -> RestPatternInnerChildren {
		RestPatternInnerChildren::ObjectPattern(node)
	}
}
impl AstNode for RestPatternInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ARRAY_PATTERN | SyntaxKind::IDENTIFIER | SyntaxKind::OBJECT_PATTERN => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ARRAY_PATTERN => {
				RestPatternInnerChildren::ArrayPattern(ArrayPattern { syntax })
			}
			SyntaxKind::IDENTIFIER => RestPatternInnerChildren::Identifier(Identifier { syntax }),
			SyntaxKind::OBJECT_PATTERN => {
				RestPatternInnerChildren::ObjectPattern(ObjectPattern { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			RestPatternInnerChildren::ArrayPattern(it) => &it.syntax,
			RestPatternInnerChildren::Identifier(it) => &it.syntax,
			RestPatternInnerChildren::ObjectPattern(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for RestTypeInnerChildren {
	fn from(node: ConstructorType) -> RestTypeInnerChildren {
		RestTypeInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for RestTypeInnerChildren {
	fn from(node: FunctionType) -> RestTypeInnerChildren {
		RestTypeInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for RestTypeInnerChildren {
	fn from(node: InferType) -> RestTypeInnerChildren {
		RestTypeInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for RestTypeInnerChildren {
	fn from(node: IntersectionType) -> RestTypeInnerChildren {
		RestTypeInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for RestTypeInnerChildren {
	fn from(node: PrimaryType) -> RestTypeInnerChildren {
		RestTypeInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for RestTypeInnerChildren {
	fn from(node: ReadonlyType) -> RestTypeInnerChildren {
		RestTypeInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for RestTypeInnerChildren {
	fn from(node: UnionType) -> RestTypeInnerChildren {
		RestTypeInnerChildren::UnionType(node)
	}
}
impl AstNode for RestTypeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				RestTypeInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				RestTypeInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => RestTypeInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				RestTypeInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				RestTypeInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => RestTypeInnerChildren::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				RestTypeInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			RestTypeInnerChildren::ConstructorType(it) => &it.syntax,
			RestTypeInnerChildren::FunctionType(it) => &it.syntax,
			RestTypeInnerChildren::InferType(it) => &it.syntax,
			RestTypeInnerChildren::IntersectionType(it) => &it.syntax,
			RestTypeInnerChildren::ReadonlyType(it) => &it.syntax,
			RestTypeInnerChildren::UnionType(it) => &it.syntax,
			RestTypeInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<Expression> for ReturnStatementInnerChildren {
	fn from(node: Expression) -> ReturnStatementInnerChildren {
		ReturnStatementInnerChildren::Expression(node)
	}
}
impl From<SequenceExpression> for ReturnStatementInnerChildren {
	fn from(node: SequenceExpression) -> ReturnStatementInnerChildren {
		ReturnStatementInnerChildren::SequenceExpression(node)
	}
}
impl AstNode for ReturnStatementInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::SEQUENCE_EXPRESSION => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::SEQUENCE_EXPRESSION => {
				ReturnStatementInnerChildren::SequenceExpression(SequenceExpression { syntax })
			}
			kind if Expression::can_cast(kind) => {
				ReturnStatementInnerChildren::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ReturnStatementInnerChildren::SequenceExpression(it) => &it.syntax,
			ReturnStatementInnerChildren::Expression(it) => &it.syntax(),
		}
	}
}
impl From<Expression> for SequenceExpressionRight {
	fn from(node: Expression) -> SequenceExpressionRight {
		SequenceExpressionRight::Expression(node)
	}
}
impl From<SequenceExpression> for SequenceExpressionRight {
	fn from(node: SequenceExpression) -> SequenceExpressionRight {
		SequenceExpressionRight::SequenceExpression(node)
	}
}
impl AstNode for SequenceExpressionRight {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::SEQUENCE_EXPRESSION => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::SEQUENCE_EXPRESSION => {
				SequenceExpressionRight::SequenceExpression(SequenceExpression { syntax })
			}
			kind if Expression::can_cast(kind) => {
				SequenceExpressionRight::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			SequenceExpressionRight::SequenceExpression(it) => &it.syntax,
			SequenceExpressionRight::Expression(it) => &it.syntax(),
		}
	}
}
impl From<BreakStatement> for Statement {
	fn from(node: BreakStatement) -> Statement {
		Statement::BreakStatement(node)
	}
}
impl From<ContinueStatement> for Statement {
	fn from(node: ContinueStatement) -> Statement {
		Statement::ContinueStatement(node)
	}
}
impl From<DebuggerStatement> for Statement {
	fn from(node: DebuggerStatement) -> Statement {
		Statement::DebuggerStatement(node)
	}
}
impl From<Declaration> for Statement {
	fn from(node: Declaration) -> Statement {
		Statement::Declaration(node)
	}
}
impl From<DoStatement> for Statement {
	fn from(node: DoStatement) -> Statement {
		Statement::DoStatement(node)
	}
}
impl From<EmptyStatement> for Statement {
	fn from(node: EmptyStatement) -> Statement {
		Statement::EmptyStatement(node)
	}
}
impl From<ExportStatement> for Statement {
	fn from(node: ExportStatement) -> Statement {
		Statement::ExportStatement(node)
	}
}
impl From<ExpressionStatement> for Statement {
	fn from(node: ExpressionStatement) -> Statement {
		Statement::ExpressionStatement(node)
	}
}
impl From<ForInStatement> for Statement {
	fn from(node: ForInStatement) -> Statement {
		Statement::ForInStatement(node)
	}
}
impl From<ForStatement> for Statement {
	fn from(node: ForStatement) -> Statement {
		Statement::ForStatement(node)
	}
}
impl From<IfStatement> for Statement {
	fn from(node: IfStatement) -> Statement {
		Statement::IfStatement(node)
	}
}
impl From<ImportStatement> for Statement {
	fn from(node: ImportStatement) -> Statement {
		Statement::ImportStatement(node)
	}
}
impl From<LabeledStatement> for Statement {
	fn from(node: LabeledStatement) -> Statement {
		Statement::LabeledStatement(node)
	}
}
impl From<ReturnStatement> for Statement {
	fn from(node: ReturnStatement) -> Statement {
		Statement::ReturnStatement(node)
	}
}
impl From<StatementBlock> for Statement {
	fn from(node: StatementBlock) -> Statement {
		Statement::StatementBlock(node)
	}
}
impl From<SwitchStatement> for Statement {
	fn from(node: SwitchStatement) -> Statement {
		Statement::SwitchStatement(node)
	}
}
impl From<ThrowStatement> for Statement {
	fn from(node: ThrowStatement) -> Statement {
		Statement::ThrowStatement(node)
	}
}
impl From<TryStatement> for Statement {
	fn from(node: TryStatement) -> Statement {
		Statement::TryStatement(node)
	}
}
impl From<WhileStatement> for Statement {
	fn from(node: WhileStatement) -> Statement {
		Statement::WhileStatement(node)
	}
}
impl From<WithStatement> for Statement {
	fn from(node: WithStatement) -> Statement {
		Statement::WithStatement(node)
	}
}
impl AstNode for Statement {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::BREAK_STATEMENT
			| SyntaxKind::CONTINUE_STATEMENT
			| SyntaxKind::DEBUGGER_STATEMENT
			| SyntaxKind::DO_STATEMENT
			| SyntaxKind::EMPTY_STATEMENT
			| SyntaxKind::EXPORT_STATEMENT
			| SyntaxKind::EXPRESSION_STATEMENT
			| SyntaxKind::FOR_IN_STATEMENT
			| SyntaxKind::FOR_STATEMENT
			| SyntaxKind::IF_STATEMENT
			| SyntaxKind::IMPORT_STATEMENT
			| SyntaxKind::LABELED_STATEMENT
			| SyntaxKind::RETURN_STATEMENT
			| SyntaxKind::STATEMENT_BLOCK
			| SyntaxKind::SWITCH_STATEMENT
			| SyntaxKind::THROW_STATEMENT
			| SyntaxKind::TRY_STATEMENT
			| SyntaxKind::WHILE_STATEMENT
			| SyntaxKind::WITH_STATEMENT => true,
			_ => Declaration::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::BREAK_STATEMENT => Statement::BreakStatement(BreakStatement { syntax }),
			SyntaxKind::CONTINUE_STATEMENT => {
				Statement::ContinueStatement(ContinueStatement { syntax })
			}
			SyntaxKind::DEBUGGER_STATEMENT => {
				Statement::DebuggerStatement(DebuggerStatement { syntax })
			}
			SyntaxKind::DO_STATEMENT => Statement::DoStatement(DoStatement { syntax }),
			SyntaxKind::EMPTY_STATEMENT => Statement::EmptyStatement(EmptyStatement { syntax }),
			SyntaxKind::EXPORT_STATEMENT => Statement::ExportStatement(ExportStatement { syntax }),
			SyntaxKind::EXPRESSION_STATEMENT => {
				Statement::ExpressionStatement(ExpressionStatement { syntax })
			}
			SyntaxKind::FOR_IN_STATEMENT => Statement::ForInStatement(ForInStatement { syntax }),
			SyntaxKind::FOR_STATEMENT => Statement::ForStatement(ForStatement { syntax }),
			SyntaxKind::IF_STATEMENT => Statement::IfStatement(IfStatement { syntax }),
			SyntaxKind::IMPORT_STATEMENT => Statement::ImportStatement(ImportStatement { syntax }),
			SyntaxKind::LABELED_STATEMENT => {
				Statement::LabeledStatement(LabeledStatement { syntax })
			}
			SyntaxKind::RETURN_STATEMENT => Statement::ReturnStatement(ReturnStatement { syntax }),
			SyntaxKind::STATEMENT_BLOCK => Statement::StatementBlock(StatementBlock { syntax }),
			SyntaxKind::SWITCH_STATEMENT => Statement::SwitchStatement(SwitchStatement { syntax }),
			SyntaxKind::THROW_STATEMENT => Statement::ThrowStatement(ThrowStatement { syntax }),
			SyntaxKind::TRY_STATEMENT => Statement::TryStatement(TryStatement { syntax }),
			SyntaxKind::WHILE_STATEMENT => Statement::WhileStatement(WhileStatement { syntax }),
			SyntaxKind::WITH_STATEMENT => Statement::WithStatement(WithStatement { syntax }),
			kind if Declaration::can_cast(kind) => {
				Statement::Declaration(Declaration::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			Statement::BreakStatement(it) => &it.syntax,
			Statement::ContinueStatement(it) => &it.syntax,
			Statement::DebuggerStatement(it) => &it.syntax,
			Statement::DoStatement(it) => &it.syntax,
			Statement::EmptyStatement(it) => &it.syntax,
			Statement::ExportStatement(it) => &it.syntax,
			Statement::ExpressionStatement(it) => &it.syntax,
			Statement::ForInStatement(it) => &it.syntax,
			Statement::ForStatement(it) => &it.syntax,
			Statement::IfStatement(it) => &it.syntax,
			Statement::ImportStatement(it) => &it.syntax,
			Statement::LabeledStatement(it) => &it.syntax,
			Statement::ReturnStatement(it) => &it.syntax,
			Statement::StatementBlock(it) => &it.syntax,
			Statement::SwitchStatement(it) => &it.syntax,
			Statement::ThrowStatement(it) => &it.syntax,
			Statement::TryStatement(it) => &it.syntax,
			Statement::WhileStatement(it) => &it.syntax,
			Statement::WithStatement(it) => &it.syntax,
			Statement::Declaration(it) => &it.syntax(),
		}
	}
}
impl From<Expression> for SubscriptExpressionIndex {
	fn from(node: Expression) -> SubscriptExpressionIndex {
		SubscriptExpressionIndex::Expression(node)
	}
}
impl From<SequenceExpression> for SubscriptExpressionIndex {
	fn from(node: SequenceExpression) -> SubscriptExpressionIndex {
		SubscriptExpressionIndex::SequenceExpression(node)
	}
}
impl AstNode for SubscriptExpressionIndex {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::SEQUENCE_EXPRESSION => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::SEQUENCE_EXPRESSION => {
				SubscriptExpressionIndex::SequenceExpression(SequenceExpression { syntax })
			}
			kind if Expression::can_cast(kind) => {
				SubscriptExpressionIndex::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			SubscriptExpressionIndex::SequenceExpression(it) => &it.syntax,
			SubscriptExpressionIndex::Expression(it) => &it.syntax(),
		}
	}
}
impl From<SwitchCase> for SwitchBodyInnerChildren {
	fn from(node: SwitchCase) -> SwitchBodyInnerChildren {
		SwitchBodyInnerChildren::SwitchCase(node)
	}
}
impl From<SwitchDefault> for SwitchBodyInnerChildren {
	fn from(node: SwitchDefault) -> SwitchBodyInnerChildren {
		SwitchBodyInnerChildren::SwitchDefault(node)
	}
}
impl AstNode for SwitchBodyInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::SWITCH_CASE | SyntaxKind::SWITCH_DEFAULT => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::SWITCH_CASE => SwitchBodyInnerChildren::SwitchCase(SwitchCase { syntax }),
			SyntaxKind::SWITCH_DEFAULT => {
				SwitchBodyInnerChildren::SwitchDefault(SwitchDefault { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			SwitchBodyInnerChildren::SwitchCase(it) => &it.syntax,
			SwitchBodyInnerChildren::SwitchDefault(it) => &it.syntax,
		}
	}
}
impl From<Expression> for SwitchCaseValue {
	fn from(node: Expression) -> SwitchCaseValue {
		SwitchCaseValue::Expression(node)
	}
}
impl From<SequenceExpression> for SwitchCaseValue {
	fn from(node: SequenceExpression) -> SwitchCaseValue {
		SwitchCaseValue::SequenceExpression(node)
	}
}
impl AstNode for SwitchCaseValue {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::SEQUENCE_EXPRESSION => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::SEQUENCE_EXPRESSION => {
				SwitchCaseValue::SequenceExpression(SequenceExpression { syntax })
			}
			kind if Expression::can_cast(kind) => {
				SwitchCaseValue::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			SwitchCaseValue::SequenceExpression(it) => &it.syntax,
			SwitchCaseValue::Expression(it) => &it.syntax(),
		}
	}
}
impl From<EscapeSequence> for TemplateStringInnerChildren {
	fn from(node: EscapeSequence) -> TemplateStringInnerChildren {
		TemplateStringInnerChildren::EscapeSequence(node)
	}
}
impl From<TemplateSubstitution> for TemplateStringInnerChildren {
	fn from(node: TemplateSubstitution) -> TemplateStringInnerChildren {
		TemplateStringInnerChildren::TemplateSubstitution(node)
	}
}
impl AstNode for TemplateStringInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ESCAPE_SEQUENCE | SyntaxKind::TEMPLATE_SUBSTITUTION => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ESCAPE_SEQUENCE => {
				TemplateStringInnerChildren::EscapeSequence(EscapeSequence { syntax })
			}
			SyntaxKind::TEMPLATE_SUBSTITUTION => {
				TemplateStringInnerChildren::TemplateSubstitution(TemplateSubstitution { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			TemplateStringInnerChildren::EscapeSequence(it) => &it.syntax,
			TemplateStringInnerChildren::TemplateSubstitution(it) => &it.syntax,
		}
	}
}
impl From<Expression> for TemplateSubstitutionInnerChildren {
	fn from(node: Expression) -> TemplateSubstitutionInnerChildren {
		TemplateSubstitutionInnerChildren::Expression(node)
	}
}
impl From<SequenceExpression> for TemplateSubstitutionInnerChildren {
	fn from(node: SequenceExpression) -> TemplateSubstitutionInnerChildren {
		TemplateSubstitutionInnerChildren::SequenceExpression(node)
	}
}
impl AstNode for TemplateSubstitutionInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::SEQUENCE_EXPRESSION => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::SEQUENCE_EXPRESSION => {
				TemplateSubstitutionInnerChildren::SequenceExpression(SequenceExpression { syntax })
			}
			kind if Expression::can_cast(kind) => {
				TemplateSubstitutionInnerChildren::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			TemplateSubstitutionInnerChildren::SequenceExpression(it) => &it.syntax,
			TemplateSubstitutionInnerChildren::Expression(it) => &it.syntax(),
		}
	}
}
impl From<Expression> for ThrowStatementInnerChildren {
	fn from(node: Expression) -> ThrowStatementInnerChildren {
		ThrowStatementInnerChildren::Expression(node)
	}
}
impl From<SequenceExpression> for ThrowStatementInnerChildren {
	fn from(node: SequenceExpression) -> ThrowStatementInnerChildren {
		ThrowStatementInnerChildren::SequenceExpression(node)
	}
}
impl AstNode for ThrowStatementInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::SEQUENCE_EXPRESSION => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::SEQUENCE_EXPRESSION => {
				ThrowStatementInnerChildren::SequenceExpression(SequenceExpression { syntax })
			}
			kind if Expression::can_cast(kind) => {
				ThrowStatementInnerChildren::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			ThrowStatementInnerChildren::SequenceExpression(it) => &it.syntax,
			ThrowStatementInnerChildren::Expression(it) => &it.syntax(),
		}
	}
}
impl From<ConstructorType> for TupleTypeInnerChildren {
	fn from(node: ConstructorType) -> TupleTypeInnerChildren {
		TupleTypeInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for TupleTypeInnerChildren {
	fn from(node: FunctionType) -> TupleTypeInnerChildren {
		TupleTypeInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for TupleTypeInnerChildren {
	fn from(node: InferType) -> TupleTypeInnerChildren {
		TupleTypeInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for TupleTypeInnerChildren {
	fn from(node: IntersectionType) -> TupleTypeInnerChildren {
		TupleTypeInnerChildren::IntersectionType(node)
	}
}
impl From<OptionalParameter> for TupleTypeInnerChildren {
	fn from(node: OptionalParameter) -> TupleTypeInnerChildren {
		TupleTypeInnerChildren::OptionalParameter(node)
	}
}
impl From<OptionalType> for TupleTypeInnerChildren {
	fn from(node: OptionalType) -> TupleTypeInnerChildren {
		TupleTypeInnerChildren::OptionalType(node)
	}
}
impl From<PrimaryType> for TupleTypeInnerChildren {
	fn from(node: PrimaryType) -> TupleTypeInnerChildren {
		TupleTypeInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for TupleTypeInnerChildren {
	fn from(node: ReadonlyType) -> TupleTypeInnerChildren {
		TupleTypeInnerChildren::ReadonlyType(node)
	}
}
impl From<RequiredParameter> for TupleTypeInnerChildren {
	fn from(node: RequiredParameter) -> TupleTypeInnerChildren {
		TupleTypeInnerChildren::RequiredParameter(node)
	}
}
impl From<RestType> for TupleTypeInnerChildren {
	fn from(node: RestType) -> TupleTypeInnerChildren {
		TupleTypeInnerChildren::RestType(node)
	}
}
impl From<UnionType> for TupleTypeInnerChildren {
	fn from(node: UnionType) -> TupleTypeInnerChildren {
		TupleTypeInnerChildren::UnionType(node)
	}
}
impl AstNode for TupleTypeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::OPTIONAL_PARAMETER
			| SyntaxKind::OPTIONAL_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::REQUIRED_PARAMETER
			| SyntaxKind::REST_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				TupleTypeInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				TupleTypeInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => TupleTypeInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				TupleTypeInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::OPTIONAL_PARAMETER => {
				TupleTypeInnerChildren::OptionalParameter(OptionalParameter { syntax })
			}
			SyntaxKind::OPTIONAL_TYPE => {
				TupleTypeInnerChildren::OptionalType(OptionalType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				TupleTypeInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::REQUIRED_PARAMETER => {
				TupleTypeInnerChildren::RequiredParameter(RequiredParameter { syntax })
			}
			SyntaxKind::REST_TYPE => TupleTypeInnerChildren::RestType(RestType { syntax }),
			SyntaxKind::UNION_TYPE => TupleTypeInnerChildren::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				TupleTypeInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			TupleTypeInnerChildren::ConstructorType(it) => &it.syntax,
			TupleTypeInnerChildren::FunctionType(it) => &it.syntax,
			TupleTypeInnerChildren::InferType(it) => &it.syntax,
			TupleTypeInnerChildren::IntersectionType(it) => &it.syntax,
			TupleTypeInnerChildren::OptionalParameter(it) => &it.syntax,
			TupleTypeInnerChildren::OptionalType(it) => &it.syntax,
			TupleTypeInnerChildren::ReadonlyType(it) => &it.syntax,
			TupleTypeInnerChildren::RequiredParameter(it) => &it.syntax,
			TupleTypeInnerChildren::RestType(it) => &it.syntax,
			TupleTypeInnerChildren::UnionType(it) => &it.syntax,
			TupleTypeInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<ConstructorType> for TypeAliasDeclarationValue {
	fn from(node: ConstructorType) -> TypeAliasDeclarationValue {
		TypeAliasDeclarationValue::ConstructorType(node)
	}
}
impl From<FunctionType> for TypeAliasDeclarationValue {
	fn from(node: FunctionType) -> TypeAliasDeclarationValue {
		TypeAliasDeclarationValue::FunctionType(node)
	}
}
impl From<InferType> for TypeAliasDeclarationValue {
	fn from(node: InferType) -> TypeAliasDeclarationValue {
		TypeAliasDeclarationValue::InferType(node)
	}
}
impl From<IntersectionType> for TypeAliasDeclarationValue {
	fn from(node: IntersectionType) -> TypeAliasDeclarationValue {
		TypeAliasDeclarationValue::IntersectionType(node)
	}
}
impl From<PrimaryType> for TypeAliasDeclarationValue {
	fn from(node: PrimaryType) -> TypeAliasDeclarationValue {
		TypeAliasDeclarationValue::PrimaryType(node)
	}
}
impl From<ReadonlyType> for TypeAliasDeclarationValue {
	fn from(node: ReadonlyType) -> TypeAliasDeclarationValue {
		TypeAliasDeclarationValue::ReadonlyType(node)
	}
}
impl From<UnionType> for TypeAliasDeclarationValue {
	fn from(node: UnionType) -> TypeAliasDeclarationValue {
		TypeAliasDeclarationValue::UnionType(node)
	}
}
impl AstNode for TypeAliasDeclarationValue {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				TypeAliasDeclarationValue::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				TypeAliasDeclarationValue::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => TypeAliasDeclarationValue::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				TypeAliasDeclarationValue::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				TypeAliasDeclarationValue::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => TypeAliasDeclarationValue::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				TypeAliasDeclarationValue::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			TypeAliasDeclarationValue::ConstructorType(it) => &it.syntax,
			TypeAliasDeclarationValue::FunctionType(it) => &it.syntax,
			TypeAliasDeclarationValue::InferType(it) => &it.syntax,
			TypeAliasDeclarationValue::IntersectionType(it) => &it.syntax,
			TypeAliasDeclarationValue::ReadonlyType(it) => &it.syntax,
			TypeAliasDeclarationValue::UnionType(it) => &it.syntax,
			TypeAliasDeclarationValue::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<ConstructorType> for TypeAnnotationInnerChildren {
	fn from(node: ConstructorType) -> TypeAnnotationInnerChildren {
		TypeAnnotationInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for TypeAnnotationInnerChildren {
	fn from(node: FunctionType) -> TypeAnnotationInnerChildren {
		TypeAnnotationInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for TypeAnnotationInnerChildren {
	fn from(node: InferType) -> TypeAnnotationInnerChildren {
		TypeAnnotationInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for TypeAnnotationInnerChildren {
	fn from(node: IntersectionType) -> TypeAnnotationInnerChildren {
		TypeAnnotationInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for TypeAnnotationInnerChildren {
	fn from(node: PrimaryType) -> TypeAnnotationInnerChildren {
		TypeAnnotationInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for TypeAnnotationInnerChildren {
	fn from(node: ReadonlyType) -> TypeAnnotationInnerChildren {
		TypeAnnotationInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for TypeAnnotationInnerChildren {
	fn from(node: UnionType) -> TypeAnnotationInnerChildren {
		TypeAnnotationInnerChildren::UnionType(node)
	}
}
impl AstNode for TypeAnnotationInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				TypeAnnotationInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				TypeAnnotationInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => TypeAnnotationInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				TypeAnnotationInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				TypeAnnotationInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => TypeAnnotationInnerChildren::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				TypeAnnotationInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			TypeAnnotationInnerChildren::ConstructorType(it) => &it.syntax,
			TypeAnnotationInnerChildren::FunctionType(it) => &it.syntax,
			TypeAnnotationInnerChildren::InferType(it) => &it.syntax,
			TypeAnnotationInnerChildren::IntersectionType(it) => &it.syntax,
			TypeAnnotationInnerChildren::ReadonlyType(it) => &it.syntax,
			TypeAnnotationInnerChildren::UnionType(it) => &it.syntax,
			TypeAnnotationInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<ConstructorType> for TypeArgumentsInnerChildren {
	fn from(node: ConstructorType) -> TypeArgumentsInnerChildren {
		TypeArgumentsInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for TypeArgumentsInnerChildren {
	fn from(node: FunctionType) -> TypeArgumentsInnerChildren {
		TypeArgumentsInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for TypeArgumentsInnerChildren {
	fn from(node: InferType) -> TypeArgumentsInnerChildren {
		TypeArgumentsInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for TypeArgumentsInnerChildren {
	fn from(node: IntersectionType) -> TypeArgumentsInnerChildren {
		TypeArgumentsInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for TypeArgumentsInnerChildren {
	fn from(node: PrimaryType) -> TypeArgumentsInnerChildren {
		TypeArgumentsInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for TypeArgumentsInnerChildren {
	fn from(node: ReadonlyType) -> TypeArgumentsInnerChildren {
		TypeArgumentsInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for TypeArgumentsInnerChildren {
	fn from(node: UnionType) -> TypeArgumentsInnerChildren {
		TypeArgumentsInnerChildren::UnionType(node)
	}
}
impl AstNode for TypeArgumentsInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				TypeArgumentsInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				TypeArgumentsInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => TypeArgumentsInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				TypeArgumentsInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				TypeArgumentsInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => TypeArgumentsInnerChildren::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				TypeArgumentsInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			TypeArgumentsInnerChildren::ConstructorType(it) => &it.syntax,
			TypeArgumentsInnerChildren::FunctionType(it) => &it.syntax,
			TypeArgumentsInnerChildren::InferType(it) => &it.syntax,
			TypeArgumentsInnerChildren::IntersectionType(it) => &it.syntax,
			TypeArgumentsInnerChildren::ReadonlyType(it) => &it.syntax,
			TypeArgumentsInnerChildren::UnionType(it) => &it.syntax,
			TypeArgumentsInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<Expression> for TypeAssertionInnerChildren {
	fn from(node: Expression) -> TypeAssertionInnerChildren {
		TypeAssertionInnerChildren::Expression(node)
	}
}
impl From<TypeArguments> for TypeAssertionInnerChildren {
	fn from(node: TypeArguments) -> TypeAssertionInnerChildren {
		TypeAssertionInnerChildren::TypeArguments(node)
	}
}
impl AstNode for TypeAssertionInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::TYPE_ARGUMENTS => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::TYPE_ARGUMENTS => {
				TypeAssertionInnerChildren::TypeArguments(TypeArguments { syntax })
			}
			kind if Expression::can_cast(kind) => {
				TypeAssertionInnerChildren::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			TypeAssertionInnerChildren::TypeArguments(it) => &it.syntax,
			TypeAssertionInnerChildren::Expression(it) => &it.syntax(),
		}
	}
}
impl From<Constraint> for TypeParameterInnerChildren {
	fn from(node: Constraint) -> TypeParameterInnerChildren {
		TypeParameterInnerChildren::Constraint(node)
	}
}
impl From<DefaultType> for TypeParameterInnerChildren {
	fn from(node: DefaultType) -> TypeParameterInnerChildren {
		TypeParameterInnerChildren::DefaultType(node)
	}
}
impl From<TypeIdentifier> for TypeParameterInnerChildren {
	fn from(node: TypeIdentifier) -> TypeParameterInnerChildren {
		TypeParameterInnerChildren::TypeIdentifier(node)
	}
}
impl AstNode for TypeParameterInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRAINT | SyntaxKind::DEFAULT_TYPE | SyntaxKind::TYPE_IDENTIFIER => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRAINT => TypeParameterInnerChildren::Constraint(Constraint { syntax }),
			SyntaxKind::DEFAULT_TYPE => {
				TypeParameterInnerChildren::DefaultType(DefaultType { syntax })
			}
			SyntaxKind::TYPE_IDENTIFIER => {
				TypeParameterInnerChildren::TypeIdentifier(TypeIdentifier { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			TypeParameterInnerChildren::Constraint(it) => &it.syntax,
			TypeParameterInnerChildren::DefaultType(it) => &it.syntax,
			TypeParameterInnerChildren::TypeIdentifier(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for TypePredicateInnerChildren {
	fn from(node: ConstructorType) -> TypePredicateInnerChildren {
		TypePredicateInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for TypePredicateInnerChildren {
	fn from(node: FunctionType) -> TypePredicateInnerChildren {
		TypePredicateInnerChildren::FunctionType(node)
	}
}
impl From<Identifier> for TypePredicateInnerChildren {
	fn from(node: Identifier) -> TypePredicateInnerChildren {
		TypePredicateInnerChildren::Identifier(node)
	}
}
impl From<InferType> for TypePredicateInnerChildren {
	fn from(node: InferType) -> TypePredicateInnerChildren {
		TypePredicateInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for TypePredicateInnerChildren {
	fn from(node: IntersectionType) -> TypePredicateInnerChildren {
		TypePredicateInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for TypePredicateInnerChildren {
	fn from(node: PrimaryType) -> TypePredicateInnerChildren {
		TypePredicateInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for TypePredicateInnerChildren {
	fn from(node: ReadonlyType) -> TypePredicateInnerChildren {
		TypePredicateInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for TypePredicateInnerChildren {
	fn from(node: UnionType) -> TypePredicateInnerChildren {
		TypePredicateInnerChildren::UnionType(node)
	}
}
impl AstNode for TypePredicateInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::IDENTIFIER
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				TypePredicateInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				TypePredicateInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::IDENTIFIER => TypePredicateInnerChildren::Identifier(Identifier { syntax }),
			SyntaxKind::INFER_TYPE => TypePredicateInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				TypePredicateInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				TypePredicateInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => TypePredicateInnerChildren::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				TypePredicateInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			TypePredicateInnerChildren::ConstructorType(it) => &it.syntax,
			TypePredicateInnerChildren::FunctionType(it) => &it.syntax,
			TypePredicateInnerChildren::Identifier(it) => &it.syntax,
			TypePredicateInnerChildren::InferType(it) => &it.syntax,
			TypePredicateInnerChildren::IntersectionType(it) => &it.syntax,
			TypePredicateInnerChildren::ReadonlyType(it) => &it.syntax,
			TypePredicateInnerChildren::UnionType(it) => &it.syntax,
			TypePredicateInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<GenericType> for TypeQueryInnerChildren {
	fn from(node: GenericType) -> TypeQueryInnerChildren {
		TypeQueryInnerChildren::GenericType(node)
	}
}
impl From<PrimaryExpression> for TypeQueryInnerChildren {
	fn from(node: PrimaryExpression) -> TypeQueryInnerChildren {
		TypeQueryInnerChildren::PrimaryExpression(node)
	}
}
impl AstNode for TypeQueryInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::GENERIC_TYPE => true,
			_ => PrimaryExpression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::GENERIC_TYPE => TypeQueryInnerChildren::GenericType(GenericType { syntax }),
			kind if PrimaryExpression::can_cast(kind) => {
				TypeQueryInnerChildren::PrimaryExpression(PrimaryExpression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			TypeQueryInnerChildren::GenericType(it) => &it.syntax,
			TypeQueryInnerChildren::PrimaryExpression(it) => &it.syntax(),
		}
	}
}
impl From<Expression> for UnaryExpressionArgument {
	fn from(node: Expression) -> UnaryExpressionArgument {
		UnaryExpressionArgument::Expression(node)
	}
}
impl From<Number> for UnaryExpressionArgument {
	fn from(node: Number) -> UnaryExpressionArgument {
		UnaryExpressionArgument::Number(node)
	}
}
impl AstNode for UnaryExpressionArgument {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::NUMBER => true,
			_ => Expression::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::NUMBER => UnaryExpressionArgument::Number(Number { syntax }),
			kind if Expression::can_cast(kind) => {
				UnaryExpressionArgument::Expression(Expression::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			UnaryExpressionArgument::Number(it) => &it.syntax,
			UnaryExpressionArgument::Expression(it) => &it.syntax(),
		}
	}
}
impl From<BangToken> for UnaryExpressionOperator {
	fn from(node: BangToken) -> UnaryExpressionOperator {
		UnaryExpressionOperator::BangToken(node)
	}
}
impl From<DashToken> for UnaryExpressionOperator {
	fn from(node: DashToken) -> UnaryExpressionOperator {
		UnaryExpressionOperator::DashToken(node)
	}
}
impl From<DeleteToken> for UnaryExpressionOperator {
	fn from(node: DeleteToken) -> UnaryExpressionOperator {
		UnaryExpressionOperator::DeleteToken(node)
	}
}
impl From<PlusToken> for UnaryExpressionOperator {
	fn from(node: PlusToken) -> UnaryExpressionOperator {
		UnaryExpressionOperator::PlusToken(node)
	}
}
impl From<TildeToken> for UnaryExpressionOperator {
	fn from(node: TildeToken) -> UnaryExpressionOperator {
		UnaryExpressionOperator::TildeToken(node)
	}
}
impl From<TypeofToken> for UnaryExpressionOperator {
	fn from(node: TypeofToken) -> UnaryExpressionOperator {
		UnaryExpressionOperator::TypeofToken(node)
	}
}
impl From<VoidToken> for UnaryExpressionOperator {
	fn from(node: VoidToken) -> UnaryExpressionOperator {
		UnaryExpressionOperator::VoidToken(node)
	}
}
impl AstNode for UnaryExpressionOperator {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::BANG_TOKEN
			| SyntaxKind::DASH_TOKEN
			| SyntaxKind::DELETE_TOKEN
			| SyntaxKind::PLUS_TOKEN
			| SyntaxKind::TILDE_TOKEN
			| SyntaxKind::TYPEOF_TOKEN
			| SyntaxKind::VOID_TOKEN => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::BANG_TOKEN => UnaryExpressionOperator::BangToken(BangToken { syntax }),
			SyntaxKind::DASH_TOKEN => UnaryExpressionOperator::DashToken(DashToken { syntax }),
			SyntaxKind::DELETE_TOKEN => {
				UnaryExpressionOperator::DeleteToken(DeleteToken { syntax })
			}
			SyntaxKind::PLUS_TOKEN => UnaryExpressionOperator::PlusToken(PlusToken { syntax }),
			SyntaxKind::TILDE_TOKEN => UnaryExpressionOperator::TildeToken(TildeToken { syntax }),
			SyntaxKind::TYPEOF_TOKEN => {
				UnaryExpressionOperator::TypeofToken(TypeofToken { syntax })
			}
			SyntaxKind::VOID_TOKEN => UnaryExpressionOperator::VoidToken(VoidToken { syntax }),
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			UnaryExpressionOperator::BangToken(it) => &it.syntax,
			UnaryExpressionOperator::DashToken(it) => &it.syntax,
			UnaryExpressionOperator::DeleteToken(it) => &it.syntax,
			UnaryExpressionOperator::PlusToken(it) => &it.syntax,
			UnaryExpressionOperator::TildeToken(it) => &it.syntax,
			UnaryExpressionOperator::TypeofToken(it) => &it.syntax,
			UnaryExpressionOperator::VoidToken(it) => &it.syntax,
		}
	}
}
impl From<ConstructorType> for UnionTypeInnerChildren {
	fn from(node: ConstructorType) -> UnionTypeInnerChildren {
		UnionTypeInnerChildren::ConstructorType(node)
	}
}
impl From<FunctionType> for UnionTypeInnerChildren {
	fn from(node: FunctionType) -> UnionTypeInnerChildren {
		UnionTypeInnerChildren::FunctionType(node)
	}
}
impl From<InferType> for UnionTypeInnerChildren {
	fn from(node: InferType) -> UnionTypeInnerChildren {
		UnionTypeInnerChildren::InferType(node)
	}
}
impl From<IntersectionType> for UnionTypeInnerChildren {
	fn from(node: IntersectionType) -> UnionTypeInnerChildren {
		UnionTypeInnerChildren::IntersectionType(node)
	}
}
impl From<PrimaryType> for UnionTypeInnerChildren {
	fn from(node: PrimaryType) -> UnionTypeInnerChildren {
		UnionTypeInnerChildren::PrimaryType(node)
	}
}
impl From<ReadonlyType> for UnionTypeInnerChildren {
	fn from(node: ReadonlyType) -> UnionTypeInnerChildren {
		UnionTypeInnerChildren::ReadonlyType(node)
	}
}
impl From<UnionType> for UnionTypeInnerChildren {
	fn from(node: UnionType) -> UnionTypeInnerChildren {
		UnionTypeInnerChildren::UnionType(node)
	}
}
impl AstNode for UnionTypeInnerChildren {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::CONSTRUCTOR_TYPE
			| SyntaxKind::FUNCTION_TYPE
			| SyntaxKind::INFER_TYPE
			| SyntaxKind::INTERSECTION_TYPE
			| SyntaxKind::READONLY_TYPE
			| SyntaxKind::UNION_TYPE => true,
			_ => PrimaryType::can_cast(kind),
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::CONSTRUCTOR_TYPE => {
				UnionTypeInnerChildren::ConstructorType(ConstructorType { syntax })
			}
			SyntaxKind::FUNCTION_TYPE => {
				UnionTypeInnerChildren::FunctionType(FunctionType { syntax })
			}
			SyntaxKind::INFER_TYPE => UnionTypeInnerChildren::InferType(InferType { syntax }),
			SyntaxKind::INTERSECTION_TYPE => {
				UnionTypeInnerChildren::IntersectionType(IntersectionType { syntax })
			}
			SyntaxKind::READONLY_TYPE => {
				UnionTypeInnerChildren::ReadonlyType(ReadonlyType { syntax })
			}
			SyntaxKind::UNION_TYPE => UnionTypeInnerChildren::UnionType(UnionType { syntax }),
			kind if PrimaryType::can_cast(kind) => {
				UnionTypeInnerChildren::PrimaryType(PrimaryType::cast(syntax)?)
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			UnionTypeInnerChildren::ConstructorType(it) => &it.syntax,
			UnionTypeInnerChildren::FunctionType(it) => &it.syntax,
			UnionTypeInnerChildren::InferType(it) => &it.syntax,
			UnionTypeInnerChildren::IntersectionType(it) => &it.syntax,
			UnionTypeInnerChildren::ReadonlyType(it) => &it.syntax,
			UnionTypeInnerChildren::UnionType(it) => &it.syntax,
			UnionTypeInnerChildren::PrimaryType(it) => &it.syntax(),
		}
	}
}
impl From<DashDashToken> for UpdateExpressionOperator {
	fn from(node: DashDashToken) -> UpdateExpressionOperator {
		UpdateExpressionOperator::DashDashToken(node)
	}
}
impl From<PlusPlusToken> for UpdateExpressionOperator {
	fn from(node: PlusPlusToken) -> UpdateExpressionOperator {
		UpdateExpressionOperator::PlusPlusToken(node)
	}
}
impl AstNode for UpdateExpressionOperator {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::DASH_DASH_TOKEN | SyntaxKind::PLUS_PLUS_TOKEN => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::DASH_DASH_TOKEN => {
				UpdateExpressionOperator::DashDashToken(DashDashToken { syntax })
			}
			SyntaxKind::PLUS_PLUS_TOKEN => {
				UpdateExpressionOperator::PlusPlusToken(PlusPlusToken { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			UpdateExpressionOperator::DashDashToken(it) => &it.syntax,
			UpdateExpressionOperator::PlusPlusToken(it) => &it.syntax,
		}
	}
}
impl From<ArrayPattern> for VariableDeclaratorName {
	fn from(node: ArrayPattern) -> VariableDeclaratorName {
		VariableDeclaratorName::ArrayPattern(node)
	}
}
impl From<Identifier> for VariableDeclaratorName {
	fn from(node: Identifier) -> VariableDeclaratorName {
		VariableDeclaratorName::Identifier(node)
	}
}
impl From<ObjectPattern> for VariableDeclaratorName {
	fn from(node: ObjectPattern) -> VariableDeclaratorName {
		VariableDeclaratorName::ObjectPattern(node)
	}
}
impl AstNode for VariableDeclaratorName {
	fn can_cast(kind: SyntaxKind) -> bool {
		match kind {
			SyntaxKind::ARRAY_PATTERN | SyntaxKind::IDENTIFIER | SyntaxKind::OBJECT_PATTERN => true,
			_ => false,
		}
	}
	fn cast(syntax: SyntaxNode) -> Option<Self> {
		let res = match syntax.kind() {
			SyntaxKind::ARRAY_PATTERN => {
				VariableDeclaratorName::ArrayPattern(ArrayPattern { syntax })
			}
			SyntaxKind::IDENTIFIER => VariableDeclaratorName::Identifier(Identifier { syntax }),
			SyntaxKind::OBJECT_PATTERN => {
				VariableDeclaratorName::ObjectPattern(ObjectPattern { syntax })
			}
			_ => return None,
		};
		Some(res)
	}
	fn syntax(&self) -> &SyntaxNode {
		match self {
			VariableDeclaratorName::ArrayPattern(it) => &it.syntax,
			VariableDeclaratorName::Identifier(it) => &it.syntax,
			VariableDeclaratorName::ObjectPattern(it) => &it.syntax,
		}
	}
}
impl std::fmt::Display for AbstractMethodSignatureName {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AbstractMethodSignatureReturnType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AmbientDeclarationInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ArgumentsInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ArrayInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ArrayPatternInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ArrowFunctionBody {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ArrowFunctionReturnType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AsExpressionInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AssertsInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AssignmentExpressionLeft {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AugmentedAssignmentExpressionLeft {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for BinaryExpressionOperator {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for CallExpressionArguments {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for CallSignatureReturnType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for CatchClauseParameter {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ClassBodyInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ClassHeritageInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ConditionalTypeAlternative {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ConditionalTypeConsequence {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ConditionalTypeLeft {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ConditionalTypeRight {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ConstraintInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ConstructSignatureInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ConstructorTypeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Declaration {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DecoratorInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DefaultTypeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for EnumAssignmentInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for EnumBodyInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ExportStatementInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Expression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ExpressionStatementInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ExtendsClauseInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ForInStatementLeft {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ForInStatementRight {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ForStatementCondition {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ForStatementIncrement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ForStatementInitializer {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for FormalParametersInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for FunctionDeclarationReturnType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for FunctionReturnType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for FunctionSignatureReturnType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for FunctionTypeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for GeneratorFunctionDeclarationReturnType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for GeneratorFunctionReturnType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for GenericTypeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ImplementsClauseInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ImportAliasInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ImportClauseInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ImportRequireClauseInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ImportStatementInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for IndexSignatureInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for IndexTypeQueryInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for InternalModuleName {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for IntersectionTypeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxAttributeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxClosingElementName {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxElementInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxExpressionInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxFragmentInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxOpeningElementAttribute {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxOpeningElementName {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxSelfClosingElementAttribute {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxSelfClosingElementName {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LiteralTypeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LookupTypeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for MappedTypeClauseInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for MethodDefinitionName {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for MethodDefinitionReturnType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for MethodSignatureName {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for MethodSignatureReturnType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ModuleName {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for NestedIdentifierInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for NestedTypeIdentifierModule {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ObjectAssignmentPatternLeft {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ObjectInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ObjectPatternInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ObjectTypeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for OmittingTypeAnnotationInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for OptingTypeAnnotationInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for OptionalParameterInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for OptionalTypeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PairKey {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PairPatternKey {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ParenthesizedExpressionInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ParenthesizedTypeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Pattern {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PrimaryExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PrimaryType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ProgramInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PropertySignatureName {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PublicFieldDefinitionName {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ReadonlyTypeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for RequiredParameterInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for RestPatternInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for RestTypeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ReturnStatementInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SequenceExpressionRight {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Statement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SubscriptExpressionIndex {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SwitchBodyInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SwitchCaseValue {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TemplateStringInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TemplateSubstitutionInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ThrowStatementInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TupleTypeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeAliasDeclarationValue {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeAnnotationInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeArgumentsInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeAssertionInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeParameterInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypePredicateInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeQueryInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for UnaryExpressionArgument {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for UnaryExpressionOperator {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for UnionTypeInnerChildren {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for UpdateExpressionOperator {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for VariableDeclaratorName {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AbstractClassDeclaration {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AbstractMethodSignature {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AbstractToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AccessibilityModifier {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AmbientDeclaration {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AmpAmpEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AmpAmpToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AmpEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AmpToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AnyToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Arguments {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Array {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ArrayPattern {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ArrayType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ArrowFunction {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AsExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AsToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Asserts {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AssertsToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AssignmentExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AssignmentPattern {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AsyncToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AtToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AugmentedAssignmentExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AwaitExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for AwaitToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for BangEqEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for BangEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for BangToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for BinaryExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for BooleanToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for BquoteToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for BreakStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for BreakToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for CallExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for CallSignature {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for CaretEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for CaretToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for CaseToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for CatchClause {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for CatchToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Class {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ClassBody {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ClassDeclaration {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ClassHeritage {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ClassToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ColonToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for CommaToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Comment {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ComputedPropertyName {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ConditionalType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ConstToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Constraint {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ConstructSignature {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ConstructorType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ContinueStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ContinueToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DashDashToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DashEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DashQmarkColonToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DashToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DebuggerStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DebuggerToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DeclareToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Decorator {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DefaultToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DefaultType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DeleteToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DoStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DoToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DollarLbraceToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DotDotDotToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DotToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for DquoteToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ElseClause {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ElseToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for EmptyStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for EnumAssignment {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for EnumBody {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for EnumDeclaration {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for EnumToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for EqEqEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for EqEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for EqGtToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for EqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for EscapeSequence {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ExistentialType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ExportClause {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ExportSpecifier {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ExportStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ExportToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ExpressionStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ExtendsClause {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ExtendsToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for False {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for FinallyClause {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for FinallyToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for FlowMaybeType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ForInStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ForStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ForToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for FormalParameters {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for FromToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Function {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for FunctionDeclaration {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for FunctionSignature {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for FunctionToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for FunctionType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for GeneratorFunction {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for GeneratorFunctionDeclaration {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for GenericType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for GetToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for GlobalToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for GtEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for GtGtEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for GtGtGtEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for GtGtGtToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for GtGtToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for GtToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for HashBangLine {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Identifier {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for IfStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for IfToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ImplementsClause {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ImplementsToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Import {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ImportAlias {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ImportClause {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ImportRequireClause {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ImportSpecifier {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ImportStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ImportToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for InToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for IndexSignature {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for IndexTypeQuery {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for InferToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for InferType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for InstanceofToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for InterfaceDeclaration {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for InterfaceToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for InternalModule {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for IntersectionType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for IsToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxAttribute {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxClosingElement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxElement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxFragment {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxNamespaceName {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxOpeningElement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxSelfClosingElement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for JsxText {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for KeyofToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LabeledStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LbracePipeToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LbraceToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LbrackToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LetToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LexicalDeclaration {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LiteralType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LookupType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LparenToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LtEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LtLtEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LtLtToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for LtToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for MappedTypeClause {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for MemberExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for MetaProperty {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for MethodDefinition {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for MethodSignature {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Module {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ModuleToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for NamedImports {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for NamespaceImport {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for NamespaceToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for NestedIdentifier {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for NestedTypeIdentifier {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for NewExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for NewToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for NonNullExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Null {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Number {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for NumberToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Object {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ObjectAssignmentPattern {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ObjectPattern {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ObjectType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for OfToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for OmittingTypeAnnotation {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for OptingTypeAnnotation {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for OptionalParameter {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for OptionalType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Pair {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PairPattern {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ParenthesizedExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ParenthesizedType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PercentEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PercentToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PipeEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PipePipeEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PipePipeToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PipeRbraceToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PipeToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PlusEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PlusPlusToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PlusToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PredefinedType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PrivateToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Program {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PropertyIdentifier {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PropertySignature {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ProtectedToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PublicFieldDefinition {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for PublicToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for QmarkColonToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for QmarkDotToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for QmarkQmarkEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for QmarkQmarkToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for QmarkToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for RbraceToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for RbrackToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ReadonlyToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ReadonlyType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Regex {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for RegexFlags {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for RegexPattern {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for RequireToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for RequiredParameter {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for RestPattern {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for RestType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ReturnStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ReturnToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for RparenToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SemiToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SequenceExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SetToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ShorthandPropertyIdentifier {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ShorthandPropertyIdentifierPattern {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SlashEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SlashToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SpreadElement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SquoteToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for StarEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for StarStarEqToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for StarStarToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for StarToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for StatementBlock {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for StatementIdentifier {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for StaticToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for StringLiteral {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for StringToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SubscriptExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Super {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SwitchBody {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SwitchCase {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SwitchDefault {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SwitchStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SwitchToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for SymbolToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TargetToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TemplateString {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TemplateSubstitution {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TernaryExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for This {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ThrowStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for ThrowToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TildeToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for True {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TryStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TryToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TupleType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeAliasDeclaration {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeAnnotation {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeArguments {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeAssertion {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeIdentifier {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeParameter {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeParameters {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypePredicate {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypePredicateAnnotation {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeQuery {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for TypeofToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for UnaryExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for Undefined {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for UnionType {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for UpdateExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for VarToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for VariableDeclaration {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for VariableDeclarator {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for VoidToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for WhileStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for WhileToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for WithStatement {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for WithToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for YieldExpression {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
impl std::fmt::Display for YieldToken {
	fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
		std::fmt::Display::fmt(self.syntax(), f)
	}
}
